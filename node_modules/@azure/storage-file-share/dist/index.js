'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreHttp = require('@azure/core-http');
var tslib = require('tslib');
var logger$1 = require('@azure/logger');
var abortController = require('@azure/abort-controller');
var os = require('os');
require('@azure/core-paging');
var fs = require('fs');
var coreTracing = require('@azure/core-tracing');
var stream = require('stream');
var events = require('events');
var util = require('util');
var crypto = require('crypto');

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant permissions for that operation. Once all the
 * values are set, this should be serialized with toString and set as the permissions field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 *
 * @export
 * @class AccountSASPermissions
 */
var AccountSASPermissions = /** @class */ (function () {
    function AccountSASPermissions() {
        /**
         * Permission to read resources and list queues and tables granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.read = false;
        /**
         * Permission to write resources granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.write = false;
        /**
         * Permission to delete blobs and files granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.delete = false;
        /**
         * Permission to list blob containers, blobs, shares, directories, and files granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.list = false;
        /**
         * Permission to add messages, table entities, and append to blobs granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.add = false;
        /**
         * Permission to create blobs and files granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.create = false;
        /**
         * Permissions to update messages and table entities granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.update = false;
        /**
         * Permission to get and delete messages granted.
         *
         * @type {boolean}
         * @memberof AccountSASPermissions
         */
        this.process = false;
    }
    /**
     * Parse initializes the AccountSASPermissions fields from a string.
     *
     * @static
     * @param {string} permissions
     * @returns {AccountSASPermissions}
     * @memberof AccountSASPermissions
     */
    AccountSASPermissions.parse = function (permissions) {
        var accountSASPermissions = new AccountSASPermissions();
        for (var _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
            var c = permissions_1[_i];
            switch (c) {
                case "r":
                    accountSASPermissions.read = true;
                    break;
                case "w":
                    accountSASPermissions.write = true;
                    break;
                case "d":
                    accountSASPermissions.delete = true;
                    break;
                case "l":
                    accountSASPermissions.list = true;
                    break;
                case "a":
                    accountSASPermissions.add = true;
                    break;
                case "c":
                    accountSASPermissions.create = true;
                    break;
                case "u":
                    accountSASPermissions.update = true;
                    break;
                case "p":
                    accountSASPermissions.process = true;
                    break;
                default:
                    throw new RangeError("Invalid permission character: " + c);
            }
        }
        return accountSASPermissions;
    };
    /**
     * Produces the SAS permissions string for an Azure Storage account.
     * Call this method to set AccountSASSignatureValues Permissions field.
     *
     * Using this method will guarantee the resource types are in
     * an order accepted by the service.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     * @returns {string}
     * @memberof AccountSASPermissions
     */
    AccountSASPermissions.prototype.toString = function () {
        // The order of the characters should be as specified here to ensure correctness:
        // https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
        // Use a string array instead of string concatenating += operator for performance
        var permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.list) {
            permissions.push("l");
        }
        if (this.add) {
            permissions.push("a");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.update) {
            permissions.push("u");
        }
        if (this.process) {
            permissions.push("p");
        }
        return permissions.join("");
    };
    return AccountSASPermissions;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the resources accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that resource type. Once all the
 * values are set, this should be serialized with toString and set as the resources field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the resources string without this class, but
 * the order of the resources is particular and this class guarantees correctness.
 *
 * @export
 * @class AccountSASResourceTypes
 */
var AccountSASResourceTypes = /** @class */ (function () {
    function AccountSASResourceTypes() {
        /**
         * Permission to access service level APIs granted.
         *
         * @type {boolean}
         * @memberof AccountSASResourceTypes
         */
        this.service = false;
        /**
         * Permission to access container level APIs (Blob Containers, Tables, Queues, File Shares) granted.
         *
         * @type {boolean}
         * @memberof AccountSASResourceTypes
         */
        this.container = false;
        /**
         * Permission to access object level APIs (Blobs, Table Entities, Queue Messages, Files) granted.
         *
         * @type {boolean}
         * @memberof AccountSASResourceTypes
         */
        this.object = false;
    }
    /**
     * Creates an {@link AccountSASResourceTypes} from the specified resource types string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid resource type.
     *
     * @static
     * @param {string} resourceTypes
     * @returns {AccountSASResourceTypes}
     * @memberof AccountSASResourceTypes
     */
    AccountSASResourceTypes.parse = function (resourceTypes) {
        var accountSASResourceTypes = new AccountSASResourceTypes();
        for (var _i = 0, resourceTypes_1 = resourceTypes; _i < resourceTypes_1.length; _i++) {
            var c = resourceTypes_1[_i];
            switch (c) {
                case "s":
                    accountSASResourceTypes.service = true;
                    break;
                case "c":
                    accountSASResourceTypes.container = true;
                    break;
                case "o":
                    accountSASResourceTypes.object = true;
                    break;
                default:
                    throw new RangeError("Invalid resource type: " + c);
            }
        }
        return accountSASResourceTypes;
    };
    /**
     * Converts the given resource types to a string.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     * @returns {string}
     * @memberof AccountSASResourceTypes
     */
    AccountSASResourceTypes.prototype.toString = function () {
        var resourceTypes = [];
        if (this.service) {
            resourceTypes.push("s");
        }
        if (this.container) {
            resourceTypes.push("c");
        }
        if (this.object) {
            resourceTypes.push("o");
        }
        return resourceTypes.join("");
    };
    return AccountSASResourceTypes;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the services accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that service. Once all the
 * values are set, this should be serialized with toString and set as the services field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the services string without this class, but
 * the order of the services is particular and this class guarantees correctness.
 *
 * @export
 * @class AccountSASServices
 */
var AccountSASServices = /** @class */ (function () {
    function AccountSASServices() {
        /**
         * Permission to access blob resources granted.
         *
         * @type {boolean}
         * @memberof AccountSASServices
         */
        this.blob = false;
        /**
         * Permission to access file resources granted.
         *
         * @type {boolean}
         * @memberof AccountSASServices
         */
        this.file = false;
        /**
         * Permission to access queue resources granted.
         *
         * @type {boolean}
         * @memberof AccountSASServices
         */
        this.queue = false;
        /**
         * Permission to access table resources granted.
         *
         * @type {boolean}
         * @memberof AccountSASServices
         */
        this.table = false;
    }
    /**
     * Creates an {@link AccountSASServices} from the specified services string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid service.
     *
     * @static
     * @param {string} services
     * @returns {AccountSASServices}
     * @memberof AccountSASServices
     */
    AccountSASServices.parse = function (services) {
        var accountSASServices = new AccountSASServices();
        for (var _i = 0, services_1 = services; _i < services_1.length; _i++) {
            var c = services_1[_i];
            switch (c) {
                case "b":
                    accountSASServices.blob = true;
                    break;
                case "f":
                    accountSASServices.file = true;
                    break;
                case "q":
                    accountSASServices.queue = true;
                    break;
                case "t":
                    accountSASServices.table = true;
                    break;
                default:
                    throw new RangeError("Invalid service character: " + c);
            }
        }
        return accountSASServices;
    };
    /**
     * Converts the given services to a string.
     *
     * @returns {string}
     * @memberof AccountSASServices
     */
    AccountSASServices.prototype.toString = function () {
        var services = [];
        if (this.blob) {
            services.push("b");
        }
        if (this.table) {
            services.push("t");
        }
        if (this.queue) {
            services.push("q");
        }
        if (this.file) {
            services.push("f");
        }
        return services.join("");
    };
    return AccountSASServices;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * Generate SasIPRange format string. For example:
 *
 * "8.8.8.8" or "1.1.1.1-255.255.255.255"
 *
 * @export
 * @param {SasIPRange} ipRange A range of IP addresses.
 * @returns {string} string representation of the IP range.
 */
function ipRangeToString(ipRange) {
    return ipRange.end ? ipRange.start + "-" + ipRange.end : ipRange.start;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var SDK_VERSION = "12.0.0-preview.6";
var SERVICE_VERSION = "2019-02-02";
var FILE_MAX_SIZE_BYTES = 1024 * 1024 * 1024 * 1024; // 1TB
var FILE_RANGE_MAX_SIZE_BYTES = 4 * 1024 * 1024; // 4MB
var DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
var DEFAULT_HIGH_LEVEL_CONCURRENCY = 5;
var URLConstants = {
    Parameters: {
        FORCE_BROWSER_NO_CACHE: "_",
        SHARE_SNAPSHOT: "sharesnapshot",
        SIGNATURE: "sig",
        TIMEOUT: "timeout"
    }
};
var HeaderConstants = {
    AUTHORIZATION: "authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "content-encoding",
    CONTENT_LANGUAGE: "content-language",
    CONTENT_LENGTH: "content-length",
    CONTENT_MD5: "content-md5",
    CONTENT_TYPE: "content-type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date"
};
var StorageFileLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "x-ms-cache-control",
    "x-ms-content-disposition",
    "x-ms-content-encoding",
    "x-ms-content-language",
    "x-ms-content-length",
    "x-ms-content-md5",
    "x-ms-content-type",
    "x-ms-file-attributes",
    "x-ms-file-change-time",
    "x-ms-file-creation-time",
    "x-ms-file-id",
    "x-ms-file-last-write-time",
    "x-ms-file-parent-id",
    "x-ms-handle-id",
    "x-ms-number-of-handles-closed",
    "x-ms-recursive",
    "x-ms-share-quota",
    "x-ms-type",
    "x-ms-write"
];
var StorageFileLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "copyid",
    "restype"
];

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Reserved URL characters must be properly escaped for Storage services like Blob or File.
 *
 * ## URL encode and escape strategy for JS SDKs
 *
 * When customers pass a URL string into XXXClient classes constructor, the URL string may already be URL encoded or not.
 * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL
 * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XXXClient constructors.
 *
 * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.
 *
 * This is what legacy V2 SDK does, simple and works for most of the cases.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b:",
 *   SDK will encode it to "http://account.blob.core.windows.net/con/b%3A" and send to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%3A",
 *   SDK will encode it to "http://account.blob.core.windows.net/con/b%253A" and send to server. A blob named "b%3A" will be created.
 *
 * But this strategy will make it not possible to create a blob with "?" in it's name. Because when customer URL string is
 * "http://account.blob.core.windows.net/con/blob?name", the "?name" will be treated as URL paramter instead of blob name.
 * If customer URL string is "http://account.blob.core.windows.net/con/blob%3Fname", a blob named "blob%3Fname" will be created.
 * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.
 * We cannot accept a SDK cannot create a blob name with "?". So we implement strategy two:
 *
 * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.
 *
 * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b:",
 *   SDK will escape ":" like "http://account.blob.core.windows.net/con/b%3A" and send to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%3A",
 *   There is no special characters, so send "http://account.blob.core.windows.net/con/b%3A" to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%253A",
 *   There is no special characters, so send "http://account.blob.core.windows.net/con/b%253A" to server. A blob named "b%3A" will be created.
 *
 * This strategy gives us flexibility to create with any special characters. But "%" will be treated as a special characters, if the URL string
 * is not encoded, there shouldn't a "%" in the URL string, otherwise the URL is not a valid URL.
 * If customer needs to create a blob with "%" in it's blob name, use "%25" insead of "%". Just like above 3rd sample.
 * And following URL strings are invalid:
 * - "http://account.blob.core.windows.net/con/b%"
 * - "http://account.blob.core.windows.net/con/b%2"
 * - "http://account.blob.core.windows.net/con/b%G"
 *
 * Another special character is "?", use "%2F" to represent a blob name with "?" in a URL string.
 *
 * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `ContainerClient.getBlobClient(blobName)`
 *
 * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata
 *
 * @export
 * @param {string} url
 * @returns {string}
 */
function escapeURLPath(url) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    var path = urlParsed.getPath();
    path = path || "/";
    path = escape(path);
    urlParsed.setPath(path);
    return urlParsed.toString();
}
function getValueInConnString(connectionString, argument) {
    var elements = connectionString.split(";");
    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var element = elements_1[_i];
        if (element.trim().startsWith(argument)) {
            return element.trim().match(argument + "=(.*)")[1];
        }
    }
    return "";
}
/**
 * Extracts the parts of an Azure Storage account connection string.
 *
 * @export
 * @param {string} connectionString Connection string.
 * @returns {ConnectionString} String key value pairs of the storage account's url and credentials.
 */
function extractConnectionStringParts(connectionString) {
    // Matching FileEndpoint in the Account connection string
    var fileEndpoint = getValueInConnString(connectionString, "FileEndpoint");
    // Slicing off '/' at the end if exists
    // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)
    fileEndpoint = fileEndpoint.endsWith("/") ? fileEndpoint.slice(0, -1) : fileEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 &&
        connectionString.search("AccountKey=") !== -1) {
        // Account connection string
        var defaultEndpointsProtocol = "";
        var accountName = "";
        var accountKey = Buffer.from("accountKey", "base64");
        var endpointSuffix = "";
        // Get account name and key
        accountName = getValueInConnString(connectionString, "AccountName");
        accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
        if (!fileEndpoint) {
            // FileEndpoint is not present in the Account connection string
            // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.file.${endpointSuffix}`
            defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
            var protocol = defaultEndpointsProtocol.toLowerCase();
            if (protocol !== "https" && protocol !== "http") {
                throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
            }
            endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
            if (!endpointSuffix) {
                throw new Error("Invalid EndpointSuffix in the provided Connection String");
            }
            fileEndpoint = defaultEndpointsProtocol + "://" + accountName + ".file." + endpointSuffix;
        }
        if (!accountName) {
            throw new Error("Invalid AccountName in the provided Connection String");
        }
        else if (accountKey.length === 0) {
            throw new Error("Invalid AccountKey in the provided Connection String");
        }
        return {
            kind: "AccountConnString",
            url: fileEndpoint,
            accountName: accountName,
            accountKey: accountKey
        };
    }
    else {
        // SAS connection string
        var accountName = getAccountNameFromUrl(fileEndpoint);
        var accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
        if (!fileEndpoint) {
            throw new Error("Invalid FileEndpoint in the provided SAS Connection String");
        }
        else if (!accountSas) {
            throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
        }
        else if (!accountName) {
            throw new Error("Invalid AccountName in the provided SAS Connection String");
        }
        return { kind: "SASConnString", url: fileEndpoint, accountName: accountName, accountSas: accountSas };
    }
}
/**
 * Internal escape method implemented Strategy Two mentioned in escapeURL() description.
 *
 * @param {string} text
 * @returns {string}
 */
function escape(text) {
    return encodeURIComponent(text)
        .replace(/%2F/g, "/") // Don't escape for "/"
        .replace(/'/g, "%27") // Escape for "'"
        .replace(/\+/g, "%20")
        .replace(/%25/g, "%"); // Revert encoded "%"
}
/**
 * Append a string to URL path. Will remove duplicated "/" in front of the string
 * when URL path ends with a "/".
 *
 * @export
 * @param {string} url Source URL string
 * @param {string} name String to be appended to URL
 * @returns {string} An updated URL string
 */
function appendToURLPath(url, name) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    var path = urlParsed.getPath();
    path = path ? (path.endsWith("/") ? "" + path + name : path + "/" + name) : name;
    urlParsed.setPath(path);
    return urlParsed.toString();
}
/**
 * Set URL parameter name and value. If name exists in URL parameters, old value
 * will be replaced by name key. If not provide value, the parameter will be deleted.
 *
 * @export
 * @param {string} url Source URL string
 * @param {string} name Parameter name
 * @param {string} [value] Parameter value
 * @returns {string} An updated URL string
 */
function setURLParameter(url, name, value) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    urlParsed.setQueryParameter(name, value);
    return urlParsed.toString();
}
/**
 * Get URL path from an URL string.
 *
 * @export
 * @param {string} url Source URL string
 * @returns {(string | undefined)}
 */
function getURLPath(url) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    return urlParsed.getPath();
}
/**
 * Get URL query key value pairs from an URL string.
 *
 * @export
 * @param {string} url
 * @returns {{[key: string]: string}}
 */
function getURLQueries(url) {
    var queryString = coreHttp.URLBuilder.parse(url).getQuery();
    if (!queryString) {
        return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substr(1) : queryString;
    var querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter(function (value) {
        var indexOfEqual = value.indexOf("=");
        var lastIndexOfEqual = value.lastIndexOf("=");
        return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual;
    });
    var queries = {};
    for (var _i = 0, querySubStrings_1 = querySubStrings; _i < querySubStrings_1.length; _i++) {
        var querySubString = querySubStrings_1[_i];
        var splitResults = querySubString.split("=");
        var key = splitResults[0];
        var value = splitResults[1];
        queries[key] = value;
    }
    return queries;
}
/**
 * Rounds a date off to seconds.
 *
 * @export
 * @param {Date} date
 * @param {boolean} [withMilliseconds=true] If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;
 *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.
 * @returns {string} Date string in ISO8061 format, with or without 7 milliseconds component
 */
function truncatedISO8061Date(date, withMilliseconds) {
    if (withMilliseconds === void 0) { withMilliseconds = true; }
    // Date.toISOString() will return like "2018-10-29T06:34:36.139Z"
    var dateString = date.toISOString();
    return withMilliseconds
        ? dateString.substring(0, dateString.length - 1) + "0000" + "Z"
        : dateString.substring(0, dateString.length - 5) + "Z";
}
/**
 * Delay specified time interval.
 *
 * @export
 * @param {number} timeInMs
 * @param {AbortSignalLike} [aborter]
 * @param {Error} [abortError]
 */
function delay(timeInMs, aborter, abortError) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var timeout;
                    var abortHandler = function () {
                        if (timeout !== undefined) {
                            clearTimeout(timeout);
                        }
                        reject(abortError);
                    };
                    var resolveHandler = function () {
                        if (aborter !== undefined) {
                            aborter.removeEventListener("abort", abortHandler);
                        }
                        resolve();
                    };
                    timeout = setTimeout(resolveHandler, timeInMs);
                    if (aborter !== undefined) {
                        aborter.addEventListener("abort", abortHandler);
                    }
                })];
        });
    });
}
function getAccountNameFromUrl(url) {
    // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
    // Slicing off '/' at the end if exists
    try {
        url = url.endsWith("/") ? url.slice(0, -1) : url;
        var accountName = url.substring(url.lastIndexOf("://") + 3, url.lastIndexOf(".file."));
        if (!accountName) {
            throw new Error("Provided accountName is invalid.");
        }
        return accountName;
    }
    catch (error) {
        throw new Error("Unable to extract accountName with provided information.");
    }
}
function getShareNameAndPathFromUrl(url) {
    //  URL may look like the following
    // "https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString";
    // "https://myaccount.file.core.windows.net/myshare/mydirectory/file";
    // "https://myaccount.file.core.windows.net/myshare/mydirectory?sasString";
    // "https://myaccount.file.core.windows.net/myshare/mydirectory";
    // "https://myaccount.file.core.windows.net/myshare?sasString";
    // "https://myaccount.file.core.windows.net/myshare";
    // mydirectory can consist of multiple directories - dir1/dir2/dir3
    try {
        var urlWithoutSAS = url.split("?")[0]; // removing the sas part of url if present
        urlWithoutSAS = urlWithoutSAS.endsWith("/") ? urlWithoutSAS.slice(0, -1) : urlWithoutSAS; // Slicing off '/' at the end if exists
        var shareNameAndFilePath = urlWithoutSAS.match("([^/]*)://([^/]*)/([^/]*)(/(.*))?");
        // decode the encoded shareName and filePath - to get all the special characters that might be present in it
        var shareName = decodeURIComponent(shareNameAndFilePath[3]);
        var filePathOrDirectoryPath = decodeURIComponent(shareNameAndFilePath[5]);
        if (!shareName) {
            throw new Error("Provided shareName is invalid.");
        }
        else {
            return { shareName: shareName, filePathOrDirectoryPath: filePathOrDirectoryPath };
        }
    }
    catch (error) {
        throw new Error("Unable to extract shareName and filePath/directoryPath with provided information.");
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (SASProtocol) {
    /**
     * Protocol that allows HTTPS only
     */
    SASProtocol["Https"] = "https";
    /**
     * Protocol that allows both HTTPS and HTTP
     */
    SASProtocol["HttpsAndHttp"] = "https,http";
})(exports.SASProtocol || (exports.SASProtocol = {}));
/**
 * Represents the components that make up an Azure Storage SAS' query parameters. This type is not constructed directly
 * by the user; it is only generated by the {@link AccountSASSignatureValues} and {@link FileSASSignatureValues}
 * types. Once generated, it can be encoded into a {@code String} and appended to a URL directly (though caution should
 * be taken here in case there are existing query parameters, which might affect the appropriate means of appending
 * these query parameters).
 *
 * NOTE: Instances of this class are immutable.
 *
 * @export
 * @class SASQueryParameters
 */
var SASQueryParameters = /** @class */ (function () {
    /**
     * Creates an instance of SASQueryParameters.
     *
     * @param {string} version Representing the storage version
     * @param {string} signature Representing the signature for the SAS token
     * @param {string} [permissions] Representing the storage permissions
     * @param {string} [services] Representing the storage services being accessed (only for Account SAS)
     * @param {string} [resourceTypes] Representing the storage resource types being accessed (only for Account SAS)
     * @param {SASProtocol} [protocol] Representing the allowed HTTP protocol(s)
     * @param {Date} [startTime] Representing the start time for this SAS token
     * @param {Date} [expiryTime] Representing the expiry time for this SAS token
     * @param {SasIPRange} [ipRange] Representing the range of valid IP addresses for this SAS token
     * @param {string} [identifier] Representing the signed identifier (only for Service SAS)
     * @param {string} [resource] Representing the storage container or blob (only for Service SAS)
     * @param {string} [cacheControl] Representing the cache-control header (only for Blob/File Service SAS)
     * @param {string} [contentDisposition] Representing the content-disposition header (only for Blob/File Service SAS)
     * @param {string} [contentEncoding] Representing the content-encoding header (only for Blob/File Service SAS)
     * @param {string} [contentLanguage] Representing the content-language header (only for Blob/File Service SAS)
     * @param {string} [contentType] Representing the content-type header (only for Blob/File Service SAS)
     * @memberof SASQueryParameters
     */
    function SASQueryParameters(version, signature, permissions, services, resourceTypes, protocol, startTime, expiryTime, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType) {
        this.version = version;
        this.services = services;
        this.resourceTypes = resourceTypes;
        this.expiryTime = expiryTime;
        this.permissions = permissions;
        this.protocol = protocol;
        this.startTime = startTime;
        this.ipRangeInner = ipRange;
        this.identifier = identifier;
        this.resource = resource;
        this.signature = signature;
        this.cacheControl = cacheControl;
        this.contentDisposition = contentDisposition;
        this.contentEncoding = contentEncoding;
        this.contentLanguage = contentLanguage;
        this.contentType = contentType;
    }
    Object.defineProperty(SASQueryParameters.prototype, "ipRange", {
        /**
         * Optional. IP range allowed for this SAS.
         *
         * @readonly
         * @type {(SasIPRange | undefined)}
         * @memberof SASQueryParameters
         */
        get: function () {
            if (this.ipRangeInner) {
                return {
                    end: this.ipRangeInner.end,
                    start: this.ipRangeInner.start
                };
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Encodes all SAS query parameters into a string that can be appended to a URL.
     *
     * @returns {string}
     * @memberof SASQueryParameters
     */
    SASQueryParameters.prototype.toString = function () {
        var params = [
            "sv",
            "ss",
            "srt",
            "spr",
            "st",
            "se",
            "sip",
            "si",
            "sr",
            "sp",
            "sig",
            "rscc",
            "rscd",
            "rsce",
            "rscl",
            "rsct"
        ];
        var queries = [];
        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
            var param = params_1[_i];
            switch (param) {
                case "sv":
                    this.tryAppendQueryParameter(queries, param, this.version);
                    break;
                case "ss":
                    this.tryAppendQueryParameter(queries, param, this.services);
                    break;
                case "srt":
                    this.tryAppendQueryParameter(queries, param, this.resourceTypes);
                    break;
                case "spr":
                    this.tryAppendQueryParameter(queries, param, this.protocol);
                    break;
                case "st":
                    this.tryAppendQueryParameter(queries, param, this.startTime ? truncatedISO8061Date(this.startTime, false) : undefined);
                    break;
                case "se":
                    this.tryAppendQueryParameter(queries, param, this.expiryTime ? truncatedISO8061Date(this.expiryTime, false) : undefined);
                    break;
                case "sip":
                    this.tryAppendQueryParameter(queries, param, this.ipRange ? ipRangeToString(this.ipRange) : undefined);
                    break;
                case "si":
                    this.tryAppendQueryParameter(queries, param, this.identifier);
                    break;
                case "sr":
                    this.tryAppendQueryParameter(queries, param, this.resource);
                    break;
                case "sp":
                    this.tryAppendQueryParameter(queries, param, this.permissions);
                    break;
                case "sig":
                    this.tryAppendQueryParameter(queries, param, this.signature);
                    break;
                case "rscc":
                    this.tryAppendQueryParameter(queries, param, this.cacheControl);
                    break;
                case "rscd":
                    this.tryAppendQueryParameter(queries, param, this.contentDisposition);
                    break;
                case "rsce":
                    this.tryAppendQueryParameter(queries, param, this.contentEncoding);
                    break;
                case "rscl":
                    this.tryAppendQueryParameter(queries, param, this.contentLanguage);
                    break;
                case "rsct":
                    this.tryAppendQueryParameter(queries, param, this.contentType);
                    break;
            }
        }
        return queries.join("&");
    };
    /**
     * A private helper method used to filter and append query key/value pairs into an array.
     *
     * @private
     * @param {string[]} queries
     * @param {string} key
     * @param {string} [value]
     * @returns {void}
     * @memberof SASQueryParameters
     */
    SASQueryParameters.prototype.tryAppendQueryParameter = function (queries, key, value) {
        if (!value) {
            return;
        }
        key = encodeURIComponent(key);
        value = encodeURIComponent(value);
        if (key.length > 0 && value.length > 0) {
            queries.push(key + "=" + value);
        }
    };
    return SASQueryParameters;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Generates a {@link SASQueryParameters} object which contains all SAS query parameters needed to make an actual
 * REST request.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
 *
 * @param {StorageSharedKeyCredential} sharedKeyCredential
 * @returns {SASQueryParameters}
 * @memberof AccountSASSignatureValues
 */
function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    var version = accountSASSignatureValues.version
        ? accountSASSignatureValues.version
        : SERVICE_VERSION;
    var parsedPermissions = AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString()).toString();
    var parsedServices = AccountSASServices.parse(accountSASSignatureValues.services).toString();
    var parsedResourceTypes = AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
    var stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startTime
            ? truncatedISO8061Date(accountSASSignatureValues.startTime, false)
            : "",
        truncatedISO8061Date(accountSASSignatureValues.expiryTime, false),
        accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version,
        "" // Account SAS requires an additional newline character
    ].join("\n");
    var signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, parsedPermissions, parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startTime, accountSASSignatureValues.expiryTime, accountSASSignatureValues.ipRange);
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a file. Setting
 * a value to true means that any SAS which uses these permissions will grant permissions for that operation. Once all
 * the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link FileSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 *
 * @export
 * @class FileSASPermissions
 */
var FileSASPermissions = /** @class */ (function () {
    function FileSASPermissions() {
        /**
         * Specifies Read access granted.
         *
         * @type {boolean}
         * @memberof FileSASPermissions
         */
        this.read = false;
        /**
         * Specifies Create access granted.
         *
         * @type {boolean}
         * @memberof FileSASPermissions
         */
        this.create = false;
        /**
         * Specifies Write access granted.
         *
         * @type {boolean}
         * @memberof FileSASPermissions
         */
        this.write = false;
        /**
         * Specifies Delete access granted.
         *
         * @type {boolean}
         * @memberof FileSASPermissions
         */
        this.delete = false;
    }
    /**
     * Creates a FileSASPermissions from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @static
     * @param {string} permissions
     * @returns {FileSASPermissions}
     * @memberof FileSASPermissions
     */
    FileSASPermissions.parse = function (permissions) {
        var fileSASPermissions = new FileSASPermissions();
        for (var _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
            var char = permissions_1[_i];
            switch (char) {
                case "r":
                    fileSASPermissions.read = true;
                    break;
                case "c":
                    fileSASPermissions.create = true;
                    break;
                case "w":
                    fileSASPermissions.write = true;
                    break;
                case "d":
                    fileSASPermissions.delete = true;
                    break;
                default:
                    throw new RangeError("Invalid permission: " + char);
            }
        }
        return fileSASPermissions;
    };
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * @returns {string} A string which represents the FileSASPermissions
     * @memberof FileSASPermissions
     */
    FileSASPermissions.prototype.toString = function () {
        var permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        return permissions.join("");
    };
    return FileSASPermissions;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a share.
 * Setting a value to true means that any SAS which uses these permissions will grant permissions for that operation.
 * Once all the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link FileSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 *
 * @export
 * @class ShareSASPermissions
 */
var ShareSASPermissions = /** @class */ (function () {
    function ShareSASPermissions() {
        /**
         * Specifies Read access granted.
         *
         * @type {boolean}
         * @memberof ShareSASPermissions
         */
        this.read = false;
        /**
         * Specifies Create access granted.
         *
         * @type {boolean}
         * @memberof ShareSASPermissions
         */
        this.create = false;
        /**
         * Specifies Write access granted.
         *
         * @type {boolean}
         * @memberof ShareSASPermissions
         */
        this.write = false;
        /**
         * Specifies Delete access granted.
         *
         * @type {boolean}
         * @memberof ShareSASPermissions
         */
        this.delete = false;
        /**
         * Specifies List access granted.
         *
         * @type {boolean}
         * @memberof ShareSASPermissions
         */
        this.list = false;
    }
    /**
     * Creates an {@link ShareSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @static
     * @param {string} permissions
     * @returns
     * @memberof ShareSASPermissions
     */
    ShareSASPermissions.parse = function (permissions) {
        var shareSASPermissions = new ShareSASPermissions();
        for (var _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
            var char = permissions_1[_i];
            switch (char) {
                case "r":
                    shareSASPermissions.read = true;
                    break;
                case "c":
                    shareSASPermissions.create = true;
                    break;
                case "w":
                    shareSASPermissions.write = true;
                    break;
                case "d":
                    shareSASPermissions.delete = true;
                    break;
                case "l":
                    shareSASPermissions.list = true;
                    break;
                default:
                    throw new RangeError("Invalid permission " + char);
            }
        }
        return shareSASPermissions;
    };
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * The order of the characters should be as specified here to ensure correctness.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @returns {string}
     * @memberof ShareSASPermissions
     */
    ShareSASPermissions.prototype.toString = function () {
        var permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.list) {
            permissions.push("l");
        }
        return permissions.join("");
    };
    return ShareSASPermissions;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startTime and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiryTime are required.
 * You MUST assign value to identifier or expiryTime & permissions manually if you initial with
 * this constructor.
 *
 * @export
 * @param {FileSASSignatureValues} fileSASSignatureValues
 * @param {StorageSharedKeyCredential} sharedKeyCredential
 * @returns {SASQueryParameters}
 */
function generateFileSASQueryParameters(fileSASSignatureValues, sharedKeyCredential) {
    if (!fileSASSignatureValues.identifier &&
        (!fileSASSignatureValues.permissions && !fileSASSignatureValues.expiryTime)) {
        throw new RangeError("Must provide 'permissions' and 'expiryTime' for File SAS generation when 'identifier' is not provided.");
    }
    var version = fileSASSignatureValues.version ? fileSASSignatureValues.version : SERVICE_VERSION;
    var resource = "s";
    var verifiedPermissions;
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    if (fileSASSignatureValues.permissions) {
        if (fileSASSignatureValues.filePath) {
            verifiedPermissions = FileSASPermissions.parse(fileSASSignatureValues.permissions.toString()).toString();
            resource = "f";
        }
        else {
            verifiedPermissions = ShareSASPermissions.parse(fileSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    var stringToSign = [
        verifiedPermissions,
        fileSASSignatureValues.startTime
            ? truncatedISO8061Date(fileSASSignatureValues.startTime, false)
            : "",
        fileSASSignatureValues.expiryTime
            ? truncatedISO8061Date(fileSASSignatureValues.expiryTime, false)
            : "",
        getCanonicalName(sharedKeyCredential.accountName, fileSASSignatureValues.shareName, fileSASSignatureValues.filePath),
        fileSASSignatureValues.identifier,
        fileSASSignatureValues.ipRange ? ipRangeToString(fileSASSignatureValues.ipRange) : "",
        fileSASSignatureValues.protocol,
        version,
        fileSASSignatureValues.cacheControl,
        fileSASSignatureValues.contentDisposition,
        fileSASSignatureValues.contentEncoding,
        fileSASSignatureValues.contentLanguage,
        fileSASSignatureValues.contentType
    ].join("\n");
    var signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, verifiedPermissions, undefined, undefined, fileSASSignatureValues.protocol, fileSASSignatureValues.startTime, fileSASSignatureValues.expiryTime, fileSASSignatureValues.ipRange, fileSASSignatureValues.identifier, resource, fileSASSignatureValues.cacheControl, fileSASSignatureValues.contentDisposition, fileSASSignatureValues.contentEncoding, fileSASSignatureValues.contentLanguage, fileSASSignatureValues.contentType);
}
function getCanonicalName(accountName, shareName, filePath) {
    // Share: "/file/account/sharename"
    // File:  "/file/account/sharename/filename"
    // File:  "/file/account/sharename/directoryname/filename"
    var elements = ["/file/" + accountName + "/" + shareName];
    if (filePath) {
        elements.push("/" + filePath);
    }
    return elements.join("");
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var AccessPolicy = {
    serializedName: "AccessPolicy",
    type: {
        name: "Composite",
        className: "AccessPolicy",
        modelProperties: {
            start: {
                xmlName: "Start",
                serializedName: "Start",
                type: {
                    name: "String"
                }
            },
            expiry: {
                xmlName: "Expiry",
                serializedName: "Expiry",
                type: {
                    name: "String"
                }
            },
            permissions: {
                xmlName: "Permission",
                serializedName: "Permission",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var CorsRule = {
    serializedName: "CorsRule",
    type: {
        name: "Composite",
        className: "CorsRule",
        modelProperties: {
            allowedOrigins: {
                xmlName: "AllowedOrigins",
                required: true,
                serializedName: "AllowedOrigins",
                type: {
                    name: "String"
                }
            },
            allowedMethods: {
                xmlName: "AllowedMethods",
                required: true,
                serializedName: "AllowedMethods",
                type: {
                    name: "String"
                }
            },
            allowedHeaders: {
                xmlName: "AllowedHeaders",
                required: true,
                serializedName: "AllowedHeaders",
                type: {
                    name: "String"
                }
            },
            exposedHeaders: {
                xmlName: "ExposedHeaders",
                required: true,
                serializedName: "ExposedHeaders",
                type: {
                    name: "String"
                }
            },
            maxAgeInSeconds: {
                xmlName: "MaxAgeInSeconds",
                required: true,
                serializedName: "MaxAgeInSeconds",
                constraints: {
                    InclusiveMinimum: 0
                },
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var DirectoryItem = {
    xmlName: "Directory",
    serializedName: "DirectoryItem",
    type: {
        name: "Composite",
        className: "DirectoryItem",
        modelProperties: {
            name: {
                xmlName: "Name",
                required: true,
                serializedName: "Name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileProperty = {
    serializedName: "FileProperty",
    type: {
        name: "Composite",
        className: "FileProperty",
        modelProperties: {
            contentLength: {
                xmlName: "Content-Length",
                required: true,
                serializedName: "Content-Length",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var FileItem = {
    xmlName: "File",
    serializedName: "FileItem",
    type: {
        name: "Composite",
        className: "FileItem",
        modelProperties: {
            name: {
                xmlName: "Name",
                required: true,
                serializedName: "Name",
                type: {
                    name: "String"
                }
            },
            properties: {
                xmlName: "Properties",
                required: true,
                serializedName: "Properties",
                type: {
                    name: "Composite",
                    className: "FileProperty"
                }
            }
        }
    }
};
var FilesAndDirectoriesListSegment = {
    xmlName: "Entries",
    serializedName: "FilesAndDirectoriesListSegment",
    type: {
        name: "Composite",
        className: "FilesAndDirectoriesListSegment",
        modelProperties: {
            directoryItems: {
                xmlName: "DirectoryItems",
                xmlElementName: "Directory",
                required: true,
                serializedName: "DirectoryItems",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DirectoryItem"
                        }
                    }
                }
            },
            fileItems: {
                xmlName: "FileItems",
                xmlElementName: "File",
                required: true,
                serializedName: "FileItems",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FileItem"
                        }
                    }
                }
            }
        }
    }
};
var HandleItem = {
    xmlName: "Handle",
    serializedName: "HandleItem",
    type: {
        name: "Composite",
        className: "HandleItem",
        modelProperties: {
            handleId: {
                xmlName: "HandleId",
                required: true,
                serializedName: "HandleId",
                type: {
                    name: "String"
                }
            },
            path: {
                xmlName: "Path",
                required: true,
                serializedName: "Path",
                type: {
                    name: "String"
                }
            },
            fileId: {
                xmlName: "FileId",
                required: true,
                serializedName: "FileId",
                type: {
                    name: "String"
                }
            },
            parentId: {
                xmlName: "ParentId",
                serializedName: "ParentId",
                type: {
                    name: "String"
                }
            },
            sessionId: {
                xmlName: "SessionId",
                required: true,
                serializedName: "SessionId",
                type: {
                    name: "String"
                }
            },
            clientIp: {
                xmlName: "ClientIp",
                required: true,
                serializedName: "ClientIp",
                type: {
                    name: "String"
                }
            },
            openTime: {
                xmlName: "OpenTime",
                required: true,
                serializedName: "OpenTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            lastReconnectTime: {
                xmlName: "LastReconnectTime",
                serializedName: "LastReconnectTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var ListFilesAndDirectoriesSegmentResponse = {
    xmlName: "EnumerationResults",
    serializedName: "ListFilesAndDirectoriesSegmentResponse",
    type: {
        name: "Composite",
        className: "ListFilesAndDirectoriesSegmentResponse",
        modelProperties: {
            serviceEndpoint: {
                xmlIsAttribute: true,
                xmlName: "ServiceEndpoint",
                required: true,
                serializedName: "ServiceEndpoint",
                type: {
                    name: "String"
                }
            },
            shareName: {
                xmlIsAttribute: true,
                xmlName: "ShareName",
                required: true,
                serializedName: "ShareName",
                type: {
                    name: "String"
                }
            },
            shareSnapshot: {
                xmlIsAttribute: true,
                xmlName: "ShareSnapshot",
                serializedName: "ShareSnapshot",
                type: {
                    name: "String"
                }
            },
            directoryPath: {
                xmlIsAttribute: true,
                xmlName: "DirectoryPath",
                required: true,
                serializedName: "DirectoryPath",
                type: {
                    name: "String"
                }
            },
            prefix: {
                xmlName: "Prefix",
                required: true,
                serializedName: "Prefix",
                type: {
                    name: "String"
                }
            },
            marker: {
                xmlName: "Marker",
                serializedName: "Marker",
                type: {
                    name: "String"
                }
            },
            maxResults: {
                xmlName: "MaxResults",
                serializedName: "MaxResults",
                type: {
                    name: "Number"
                }
            },
            segment: {
                xmlName: "Entries",
                required: true,
                serializedName: "Segment",
                type: {
                    name: "Composite",
                    className: "FilesAndDirectoriesListSegment"
                }
            },
            continuationToken: {
                xmlName: "NextMarker",
                required: true,
                serializedName: "NextMarker",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ListHandlesResponse = {
    xmlName: "EnumerationResults",
    serializedName: "ListHandlesResponse",
    type: {
        name: "Composite",
        className: "ListHandlesResponse",
        modelProperties: {
            handleList: {
                xmlIsWrapped: true,
                xmlName: "Entries",
                xmlElementName: "Handle",
                serializedName: "HandleList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HandleItem"
                        }
                    }
                }
            },
            continuationToken: {
                xmlName: "NextMarker",
                required: true,
                serializedName: "NextMarker",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareProperties = {
    serializedName: "ShareProperties",
    type: {
        name: "Composite",
        className: "ShareProperties",
        modelProperties: {
            lastModified: {
                xmlName: "Last-Modified",
                required: true,
                serializedName: "Last-Modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                xmlName: "Etag",
                required: true,
                serializedName: "Etag",
                type: {
                    name: "String"
                }
            },
            quota: {
                xmlName: "Quota",
                required: true,
                serializedName: "Quota",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var ShareItem = {
    xmlName: "Share",
    serializedName: "ShareItem",
    type: {
        name: "Composite",
        className: "ShareItem",
        modelProperties: {
            name: {
                xmlName: "Name",
                required: true,
                serializedName: "Name",
                type: {
                    name: "String"
                }
            },
            snapshot: {
                xmlName: "Snapshot",
                serializedName: "Snapshot",
                type: {
                    name: "String"
                }
            },
            properties: {
                xmlName: "Properties",
                required: true,
                serializedName: "Properties",
                type: {
                    name: "Composite",
                    className: "ShareProperties"
                }
            },
            metadata: {
                xmlName: "Metadata",
                serializedName: "Metadata",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var ListSharesResponse = {
    xmlName: "EnumerationResults",
    serializedName: "ListSharesResponse",
    type: {
        name: "Composite",
        className: "ListSharesResponse",
        modelProperties: {
            serviceEndpoint: {
                xmlIsAttribute: true,
                xmlName: "ServiceEndpoint",
                required: true,
                serializedName: "ServiceEndpoint",
                type: {
                    name: "String"
                }
            },
            prefix: {
                xmlName: "Prefix",
                serializedName: "Prefix",
                type: {
                    name: "String"
                }
            },
            marker: {
                xmlName: "Marker",
                serializedName: "Marker",
                type: {
                    name: "String"
                }
            },
            maxResults: {
                xmlName: "MaxResults",
                serializedName: "MaxResults",
                type: {
                    name: "Number"
                }
            },
            shareItems: {
                xmlIsWrapped: true,
                xmlName: "Shares",
                xmlElementName: "Share",
                serializedName: "ShareItems",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ShareItem"
                        }
                    }
                }
            },
            continuationToken: {
                xmlName: "NextMarker",
                required: true,
                serializedName: "NextMarker",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var RetentionPolicy = {
    serializedName: "RetentionPolicy",
    type: {
        name: "Composite",
        className: "RetentionPolicy",
        modelProperties: {
            enabled: {
                xmlName: "Enabled",
                required: true,
                serializedName: "Enabled",
                type: {
                    name: "Boolean"
                }
            },
            days: {
                xmlName: "Days",
                serializedName: "Days",
                constraints: {
                    InclusiveMaximum: 365,
                    InclusiveMinimum: 1
                },
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var Metrics = {
    serializedName: "Metrics",
    type: {
        name: "Composite",
        className: "Metrics",
        modelProperties: {
            version: {
                xmlName: "Version",
                required: true,
                serializedName: "Version",
                type: {
                    name: "String"
                }
            },
            enabled: {
                xmlName: "Enabled",
                required: true,
                serializedName: "Enabled",
                type: {
                    name: "Boolean"
                }
            },
            includeAPIs: {
                xmlName: "IncludeAPIs",
                serializedName: "IncludeAPIs",
                type: {
                    name: "Boolean"
                }
            },
            retentionPolicy: {
                xmlName: "RetentionPolicy",
                serializedName: "RetentionPolicy",
                type: {
                    name: "Composite",
                    className: "RetentionPolicy"
                }
            }
        }
    }
};
var Range = {
    serializedName: "Range",
    type: {
        name: "Composite",
        className: "Range",
        modelProperties: {
            start: {
                xmlName: "Start",
                required: true,
                serializedName: "Start",
                type: {
                    name: "Number"
                }
            },
            end: {
                xmlName: "End",
                required: true,
                serializedName: "End",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var StorageError = {
    serializedName: "StorageError",
    type: {
        name: "Composite",
        className: "StorageError",
        modelProperties: {
            message: {
                xmlName: "Message",
                serializedName: "Message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareStats = {
    serializedName: "ShareStats",
    type: {
        name: "Composite",
        className: "ShareStats",
        modelProperties: {
            shareUsageBytes: {
                xmlName: "ShareUsageBytes",
                required: true,
                serializedName: "ShareUsageBytes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var SignedIdentifier = {
    serializedName: "SignedIdentifier",
    type: {
        name: "Composite",
        className: "SignedIdentifier",
        modelProperties: {
            id: {
                xmlName: "Id",
                required: true,
                serializedName: "Id",
                type: {
                    name: "String"
                }
            },
            accessPolicy: {
                xmlName: "AccessPolicy",
                serializedName: "AccessPolicy",
                type: {
                    name: "Composite",
                    className: "AccessPolicy"
                }
            }
        }
    }
};
var Permission = {
    serializedName: "Permission",
    type: {
        name: "Composite",
        className: "Permission",
        modelProperties: {
            permission: {
                xmlName: "Permission",
                required: true,
                serializedName: "Permission",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileServiceProperties = {
    xmlName: "StorageServiceProperties",
    serializedName: "FileServiceProperties",
    type: {
        name: "Composite",
        className: "FileServiceProperties",
        modelProperties: {
            hourMetrics: {
                xmlName: "HourMetrics",
                serializedName: "HourMetrics",
                type: {
                    name: "Composite",
                    className: "Metrics"
                }
            },
            minuteMetrics: {
                xmlName: "MinuteMetrics",
                serializedName: "MinuteMetrics",
                type: {
                    name: "Composite",
                    className: "Metrics"
                }
            },
            cors: {
                xmlIsWrapped: true,
                xmlName: "Cors",
                xmlElementName: "CorsRule",
                serializedName: "Cors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CorsRule"
                        }
                    }
                }
            }
        }
    }
};
var ServiceSetPropertiesHeaders = {
    serializedName: "service-setproperties-headers",
    type: {
        name: "Composite",
        className: "ServiceSetPropertiesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ServiceGetPropertiesHeaders = {
    serializedName: "service-getproperties-headers",
    type: {
        name: "Composite",
        className: "ServiceGetPropertiesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ServiceListSharesSegmentHeaders = {
    serializedName: "service-listsharessegment-headers",
    type: {
        name: "Composite",
        className: "ServiceListSharesSegmentHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareCreateHeaders = {
    serializedName: "share-create-headers",
    type: {
        name: "Composite",
        className: "ShareCreateHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetPropertiesHeaders = {
    serializedName: "share-getproperties-headers",
    type: {
        name: "Composite",
        className: "ShareGetPropertiesHeaders",
        modelProperties: {
            metadata: {
                serializedName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            quota: {
                serializedName: "x-ms-share-quota",
                type: {
                    name: "Number"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareDeleteHeaders = {
    serializedName: "share-delete-headers",
    type: {
        name: "Composite",
        className: "ShareDeleteHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareCreateSnapshotHeaders = {
    serializedName: "share-createsnapshot-headers",
    type: {
        name: "Composite",
        className: "ShareCreateSnapshotHeaders",
        modelProperties: {
            snapshot: {
                serializedName: "x-ms-snapshot",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareCreatePermissionHeaders = {
    serializedName: "share-createpermission-headers",
    type: {
        name: "Composite",
        className: "ShareCreatePermissionHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetPermissionHeaders = {
    serializedName: "share-getpermission-headers",
    type: {
        name: "Composite",
        className: "ShareGetPermissionHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareSetQuotaHeaders = {
    serializedName: "share-setquota-headers",
    type: {
        name: "Composite",
        className: "ShareSetQuotaHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareSetMetadataHeaders = {
    serializedName: "share-setmetadata-headers",
    type: {
        name: "Composite",
        className: "ShareSetMetadataHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetAccessPolicyHeaders = {
    serializedName: "share-getaccesspolicy-headers",
    type: {
        name: "Composite",
        className: "ShareGetAccessPolicyHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareSetAccessPolicyHeaders = {
    serializedName: "share-setaccesspolicy-headers",
    type: {
        name: "Composite",
        className: "ShareSetAccessPolicyHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetStatisticsHeaders = {
    serializedName: "share-getstatistics-headers",
    type: {
        name: "Composite",
        className: "ShareGetStatisticsHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryCreateHeaders = {
    serializedName: "directory-create-headers",
    type: {
        name: "Composite",
        className: "DirectoryCreateHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryGetPropertiesHeaders = {
    serializedName: "directory-getproperties-headers",
    type: {
        name: "Composite",
        className: "DirectoryGetPropertiesHeaders",
        modelProperties: {
            metadata: {
                serializedName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryDeleteHeaders = {
    serializedName: "directory-delete-headers",
    type: {
        name: "Composite",
        className: "DirectoryDeleteHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectorySetPropertiesHeaders = {
    serializedName: "directory-setproperties-headers",
    type: {
        name: "Composite",
        className: "DirectorySetPropertiesHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectorySetMetadataHeaders = {
    serializedName: "directory-setmetadata-headers",
    type: {
        name: "Composite",
        className: "DirectorySetMetadataHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryListFilesAndDirectoriesSegmentHeaders = {
    serializedName: "directory-listfilesanddirectoriessegment-headers",
    type: {
        name: "Composite",
        className: "DirectoryListFilesAndDirectoriesSegmentHeaders",
        modelProperties: {
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryListHandlesHeaders = {
    serializedName: "directory-listhandles-headers",
    type: {
        name: "Composite",
        className: "DirectoryListHandlesHeaders",
        modelProperties: {
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryForceCloseHandlesHeaders = {
    serializedName: "directory-forceclosehandles-headers",
    type: {
        name: "Composite",
        className: "DirectoryForceCloseHandlesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            marker: {
                serializedName: "x-ms-marker",
                type: {
                    name: "String"
                }
            },
            numberOfHandlesClosed: {
                serializedName: "x-ms-number-of-handles-closed",
                type: {
                    name: "Number"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileCreateHeaders = {
    serializedName: "file-create-headers",
    type: {
        name: "Composite",
        className: "FileCreateHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileDownloadHeaders = {
    serializedName: "file-download-headers",
    type: {
        name: "Composite",
        className: "FileDownloadHeaders",
        modelProperties: {
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            metadata: {
                serializedName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            contentRange: {
                serializedName: "content-range",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            contentEncoding: {
                serializedName: "content-encoding",
                type: {
                    name: "String"
                }
            },
            cacheControl: {
                serializedName: "cache-control",
                type: {
                    name: "String"
                }
            },
            contentDisposition: {
                serializedName: "content-disposition",
                type: {
                    name: "String"
                }
            },
            contentLanguage: {
                serializedName: "content-language",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            acceptRanges: {
                serializedName: "accept-ranges",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyCompletedOn: {
                serializedName: "x-ms-copy-completion-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyStatusDescription: {
                serializedName: "x-ms-copy-status-description",
                type: {
                    name: "String"
                }
            },
            copyId: {
                serializedName: "x-ms-copy-id",
                type: {
                    name: "String"
                }
            },
            copyProgress: {
                serializedName: "x-ms-copy-progress",
                type: {
                    name: "String"
                }
            },
            copySource: {
                serializedName: "x-ms-copy-source",
                type: {
                    name: "String"
                }
            },
            copyStatus: {
                serializedName: "x-ms-copy-status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "pending",
                        "success",
                        "aborted",
                        "failed"
                    ]
                }
            },
            fileContentMD5: {
                serializedName: "x-ms-content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileGetPropertiesHeaders = {
    serializedName: "file-getproperties-headers",
    type: {
        name: "Composite",
        className: "FileGetPropertiesHeaders",
        modelProperties: {
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            metadata: {
                serializedName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            fileType: {
                serializedName: "x-ms-type",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            contentEncoding: {
                serializedName: "content-encoding",
                type: {
                    name: "String"
                }
            },
            cacheControl: {
                serializedName: "cache-control",
                type: {
                    name: "String"
                }
            },
            contentDisposition: {
                serializedName: "content-disposition",
                type: {
                    name: "String"
                }
            },
            contentLanguage: {
                serializedName: "content-language",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyCompletedOn: {
                serializedName: "x-ms-copy-completion-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyStatusDescription: {
                serializedName: "x-ms-copy-status-description",
                type: {
                    name: "String"
                }
            },
            copyId: {
                serializedName: "x-ms-copy-id",
                type: {
                    name: "String"
                }
            },
            copyProgress: {
                serializedName: "x-ms-copy-progress",
                type: {
                    name: "String"
                }
            },
            copySource: {
                serializedName: "x-ms-copy-source",
                type: {
                    name: "String"
                }
            },
            copyStatus: {
                serializedName: "x-ms-copy-status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "pending",
                        "success",
                        "aborted",
                        "failed"
                    ]
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileDeleteHeaders = {
    serializedName: "file-delete-headers",
    type: {
        name: "Composite",
        className: "FileDeleteHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileSetHTTPHeadersHeaders = {
    serializedName: "file-sethttpheaders-headers",
    type: {
        name: "Composite",
        className: "FileSetHTTPHeadersHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileSetMetadataHeaders = {
    serializedName: "file-setmetadata-headers",
    type: {
        name: "Composite",
        className: "FileSetMetadataHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileUploadRangeHeaders = {
    serializedName: "file-uploadrange-headers",
    type: {
        name: "Composite",
        className: "FileUploadRangeHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileUploadRangeFromURLHeaders = {
    serializedName: "file-uploadrangefromurl-headers",
    type: {
        name: "Composite",
        className: "FileUploadRangeFromURLHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            xMsContentCrc64: {
                serializedName: "x-ms-content-crc64",
                type: {
                    name: "ByteArray"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileGetRangeListHeaders = {
    serializedName: "file-getrangelist-headers",
    type: {
        name: "Composite",
        className: "FileGetRangeListHeaders",
        modelProperties: {
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            fileContentLength: {
                serializedName: "x-ms-content-length",
                type: {
                    name: "Number"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileStartCopyHeaders = {
    serializedName: "file-startcopy-headers",
    type: {
        name: "Composite",
        className: "FileStartCopyHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyId: {
                serializedName: "x-ms-copy-id",
                type: {
                    name: "String"
                }
            },
            copyStatus: {
                serializedName: "x-ms-copy-status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "pending",
                        "success",
                        "aborted",
                        "failed"
                    ]
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileAbortCopyHeaders = {
    serializedName: "file-abortcopy-headers",
    type: {
        name: "Composite",
        className: "FileAbortCopyHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileListHandlesHeaders = {
    serializedName: "file-listhandles-headers",
    type: {
        name: "Composite",
        className: "FileListHandlesHeaders",
        modelProperties: {
            contentType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileForceCloseHandlesHeaders = {
    serializedName: "file-forceclosehandles-headers",
    type: {
        name: "Composite",
        className: "FileForceCloseHandlesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            marker: {
                serializedName: "x-ms-marker",
                type: {
                    name: "String"
                }
            },
            numberOfHandlesClosed: {
                serializedName: "x-ms-number-of-handles-closed",
                type: {
                    name: "Number"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CorsRule: CorsRule,
    FileServiceProperties: FileServiceProperties,
    ListSharesResponse: ListSharesResponse,
    Metrics: Metrics,
    RetentionPolicy: RetentionPolicy,
    ServiceGetPropertiesHeaders: ServiceGetPropertiesHeaders,
    ServiceListSharesSegmentHeaders: ServiceListSharesSegmentHeaders,
    ServiceSetPropertiesHeaders: ServiceSetPropertiesHeaders,
    ShareItem: ShareItem,
    ShareProperties: ShareProperties,
    StorageError: StorageError
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var comp0 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'properties',
        type: {
            name: "String"
        }
    }
};
var comp1 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'list',
        type: {
            name: "String"
        }
    }
};
var comp10 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'rangelist',
        type: {
            name: "String"
        }
    }
};
var comp11 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'copy',
        type: {
            name: "String"
        }
    }
};
var comp2 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'snapshot',
        type: {
            name: "String"
        }
    }
};
var comp3 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'filepermission',
        type: {
            name: "String"
        }
    }
};
var comp4 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'metadata',
        type: {
            name: "String"
        }
    }
};
var comp5 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'acl',
        type: {
            name: "String"
        }
    }
};
var comp6 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'stats',
        type: {
            name: "String"
        }
    }
};
var comp7 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'listhandles',
        type: {
            name: "String"
        }
    }
};
var comp8 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'forceclosehandles',
        type: {
            name: "String"
        }
    }
};
var comp9 = {
    parameterPath: "comp",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "comp",
        defaultValue: 'range',
        type: {
            name: "String"
        }
    }
};
var contentLength = {
    parameterPath: "contentLength",
    mapper: {
        required: true,
        serializedName: "Content-Length",
        type: {
            name: "Number"
        }
    }
};
var contentMD5 = {
    parameterPath: [
        "options",
        "contentMD5"
    ],
    mapper: {
        serializedName: "Content-MD5",
        type: {
            name: "ByteArray"
        }
    }
};
var copyActionAbortConstant = {
    parameterPath: "copyActionAbortConstant",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "x-ms-copy-action",
        defaultValue: 'abort',
        type: {
            name: "String"
        }
    }
};
var copyId = {
    parameterPath: "copyId",
    mapper: {
        required: true,
        serializedName: "copyid",
        type: {
            name: "String"
        }
    }
};
var copySource = {
    parameterPath: "copySource",
    mapper: {
        required: true,
        serializedName: "x-ms-copy-source",
        type: {
            name: "String"
        }
    }
};
var deleteSnapshots = {
    parameterPath: [
        "options",
        "deleteSnapshots"
    ],
    mapper: {
        serializedName: "x-ms-delete-snapshots",
        type: {
            name: "Enum",
            allowedValues: [
                "include"
            ]
        }
    }
};
var fileAttributes = {
    parameterPath: "fileAttributes",
    mapper: {
        required: true,
        serializedName: "x-ms-file-attributes",
        type: {
            name: "String"
        }
    }
};
var fileCacheControl = {
    parameterPath: [
        "options",
        "fileHttpHeaders",
        "fileCacheControl"
    ],
    mapper: {
        serializedName: "x-ms-cache-control",
        type: {
            name: "String"
        }
    }
};
var fileContentDisposition = {
    parameterPath: [
        "options",
        "fileHttpHeaders",
        "fileContentDisposition"
    ],
    mapper: {
        serializedName: "x-ms-content-disposition",
        type: {
            name: "String"
        }
    }
};
var fileContentEncoding = {
    parameterPath: [
        "options",
        "fileHttpHeaders",
        "fileContentEncoding"
    ],
    mapper: {
        serializedName: "x-ms-content-encoding",
        type: {
            name: "String"
        }
    }
};
var fileContentLanguage = {
    parameterPath: [
        "options",
        "fileHttpHeaders",
        "fileContentLanguage"
    ],
    mapper: {
        serializedName: "x-ms-content-language",
        type: {
            name: "String"
        }
    }
};
var fileContentLength0 = {
    parameterPath: "fileContentLength",
    mapper: {
        required: true,
        serializedName: "x-ms-content-length",
        type: {
            name: "Number"
        }
    }
};
var fileContentLength1 = {
    parameterPath: [
        "options",
        "fileContentLength"
    ],
    mapper: {
        serializedName: "x-ms-content-length",
        type: {
            name: "Number"
        }
    }
};
var fileContentMD5 = {
    parameterPath: [
        "options",
        "fileHttpHeaders",
        "fileContentMD5"
    ],
    mapper: {
        serializedName: "x-ms-content-md5",
        type: {
            name: "ByteArray"
        }
    }
};
var fileContentType = {
    parameterPath: [
        "options",
        "fileHttpHeaders",
        "fileContentType"
    ],
    mapper: {
        serializedName: "x-ms-content-type",
        type: {
            name: "String"
        }
    }
};
var fileCreatedOn = {
    parameterPath: "fileCreatedOn",
    mapper: {
        required: true,
        serializedName: "x-ms-file-creation-time",
        type: {
            name: "String"
        }
    }
};
var fileLastWriteOn = {
    parameterPath: "fileLastWriteOn",
    mapper: {
        required: true,
        serializedName: "x-ms-file-last-write-time",
        type: {
            name: "String"
        }
    }
};
var filePermission = {
    parameterPath: [
        "options",
        "filePermission"
    ],
    mapper: {
        serializedName: "x-ms-file-permission",
        type: {
            name: "String"
        }
    }
};
var filePermissionKey0 = {
    parameterPath: "filePermissionKey",
    mapper: {
        required: true,
        serializedName: "x-ms-file-permission-key",
        type: {
            name: "String"
        }
    }
};
var filePermissionKey1 = {
    parameterPath: [
        "options",
        "filePermissionKey"
    ],
    mapper: {
        serializedName: "x-ms-file-permission-key",
        type: {
            name: "String"
        }
    }
};
var fileRangeWrite = {
    parameterPath: "fileRangeWrite",
    mapper: {
        required: true,
        serializedName: "x-ms-write",
        defaultValue: 'update',
        type: {
            name: "Enum",
            allowedValues: [
                "update",
                "clear"
            ]
        }
    }
};
var fileRangeWriteFromUrl = {
    parameterPath: "fileRangeWriteFromUrl",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "x-ms-write",
        defaultValue: 'update',
        type: {
            name: "String"
        }
    }
};
var fileTypeConstant = {
    parameterPath: "fileTypeConstant",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "x-ms-type",
        defaultValue: 'file',
        type: {
            name: "String"
        }
    }
};
var handleId = {
    parameterPath: "handleId",
    mapper: {
        required: true,
        serializedName: "x-ms-handle-id",
        type: {
            name: "String"
        }
    }
};
var include = {
    parameterPath: [
        "options",
        "include"
    ],
    mapper: {
        serializedName: "include",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Enum",
                    allowedValues: [
                        "snapshots",
                        "metadata"
                    ]
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
var marker = {
    parameterPath: [
        "options",
        "marker"
    ],
    mapper: {
        serializedName: "marker",
        type: {
            name: "String"
        }
    }
};
var maxResults = {
    parameterPath: [
        "options",
        "maxResults"
    ],
    mapper: {
        serializedName: "maxresults",
        constraints: {
            InclusiveMinimum: 1
        },
        type: {
            name: "Number"
        }
    }
};
var metadata = {
    parameterPath: [
        "options",
        "metadata"
    ],
    mapper: {
        serializedName: "x-ms-meta",
        type: {
            name: "Dictionary",
            value: {
                type: {
                    name: "String"
                }
            }
        },
        headerCollectionPrefix: "x-ms-meta-"
    }
};
var prefix = {
    parameterPath: [
        "options",
        "prefix"
    ],
    mapper: {
        serializedName: "prefix",
        type: {
            name: "String"
        }
    }
};
var quota = {
    parameterPath: [
        "options",
        "quota"
    ],
    mapper: {
        serializedName: "x-ms-share-quota",
        constraints: {
            InclusiveMinimum: 1
        },
        type: {
            name: "Number"
        }
    }
};
var range0 = {
    parameterPath: [
        "options",
        "range"
    ],
    mapper: {
        serializedName: "x-ms-range",
        type: {
            name: "String"
        }
    }
};
var range1 = {
    parameterPath: "range",
    mapper: {
        required: true,
        serializedName: "x-ms-range",
        type: {
            name: "String"
        }
    }
};
var rangeGetContentMD5 = {
    parameterPath: [
        "options",
        "rangeGetContentMD5"
    ],
    mapper: {
        serializedName: "x-ms-range-get-content-md5",
        type: {
            name: "Boolean"
        }
    }
};
var recursive = {
    parameterPath: [
        "options",
        "recursive"
    ],
    mapper: {
        serializedName: "x-ms-recursive",
        type: {
            name: "Boolean"
        }
    }
};
var restype0 = {
    parameterPath: "restype",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "restype",
        defaultValue: 'service',
        type: {
            name: "String"
        }
    }
};
var restype1 = {
    parameterPath: "restype",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "restype",
        defaultValue: 'share',
        type: {
            name: "String"
        }
    }
};
var restype2 = {
    parameterPath: "restype",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "restype",
        defaultValue: 'directory',
        type: {
            name: "String"
        }
    }
};
var shareSnapshot = {
    parameterPath: [
        "options",
        "shareSnapshot"
    ],
    mapper: {
        serializedName: "sharesnapshot",
        type: {
            name: "String"
        }
    }
};
var sourceContentCrc64 = {
    parameterPath: [
        "options",
        "sourceContentCrc64"
    ],
    mapper: {
        serializedName: "x-ms-source-content-crc64",
        type: {
            name: "ByteArray"
        }
    }
};
var sourceIfMatchCrc64 = {
    parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfMatchCrc64"
    ],
    mapper: {
        serializedName: "x-ms-source-if-match-crc64",
        type: {
            name: "ByteArray"
        }
    }
};
var sourceIfNoneMatchCrc64 = {
    parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfNoneMatchCrc64"
    ],
    mapper: {
        serializedName: "x-ms-source-if-none-match-crc64",
        type: {
            name: "ByteArray"
        }
    }
};
var sourceRange = {
    parameterPath: "sourceRange",
    mapper: {
        required: true,
        serializedName: "x-ms-source-range",
        type: {
            name: "String"
        }
    }
};
var timeoutInSeconds = {
    parameterPath: [
        "options",
        "timeoutInSeconds"
    ],
    mapper: {
        serializedName: "timeout",
        constraints: {
            InclusiveMinimum: 0
        },
        type: {
            name: "Number"
        }
    }
};
var url = {
    parameterPath: "url",
    mapper: {
        required: true,
        serializedName: "url",
        defaultValue: '',
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
var version = {
    parameterPath: "version",
    mapper: {
        required: true,
        serializedName: "x-ms-version",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a Service. */
var Service = /** @class */ (function () {
    /**
     * Create a Service.
     * @param {StorageClientContext} client Reference to the service client.
     */
    function Service(client) {
        this.client = client;
    }
    Service.prototype.setProperties = function (properties, options, callback) {
        return this.client.sendOperationRequest({
            properties: properties,
            options: options
        }, setPropertiesOperationSpec, callback);
    };
    Service.prototype.getProperties = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, getPropertiesOperationSpec, callback);
    };
    Service.prototype.listSharesSegment = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, listSharesSegmentOperationSpec, callback);
    };
    return Service;
}());
// Operation Specifications
var serializer = new coreHttp.Serializer(Mappers, true);
var setPropertiesOperationSpec = {
    httpMethod: "PUT",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype0,
        comp0
    ],
    headerParameters: [
        version
    ],
    requestBody: {
        parameterPath: "properties",
        mapper: tslib.__assign(tslib.__assign({}, FileServiceProperties), { required: true })
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        202: {
            headersMapper: ServiceSetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ServiceSetPropertiesHeaders
        }
    },
    isXML: true,
    serializer: serializer
};
var getPropertiesOperationSpec = {
    httpMethod: "GET",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype0,
        comp0
    ],
    headerParameters: [
        version
    ],
    responses: {
        200: {
            bodyMapper: FileServiceProperties,
            headersMapper: ServiceGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ServiceGetPropertiesHeaders
        }
    },
    isXML: true,
    serializer: serializer
};
var listSharesSegmentOperationSpec = {
    httpMethod: "GET",
    urlParameters: [
        url
    ],
    queryParameters: [
        prefix,
        marker,
        maxResults,
        include,
        timeoutInSeconds,
        comp1
    ],
    headerParameters: [
        version
    ],
    responses: {
        200: {
            bodyMapper: ListSharesResponse,
            headersMapper: ServiceListSharesSegmentHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ServiceListSharesSegmentHeaders
        }
    },
    isXML: true,
    serializer: serializer
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AccessPolicy: AccessPolicy,
    Permission: Permission,
    ShareCreateHeaders: ShareCreateHeaders,
    ShareCreatePermissionHeaders: ShareCreatePermissionHeaders,
    ShareCreateSnapshotHeaders: ShareCreateSnapshotHeaders,
    ShareDeleteHeaders: ShareDeleteHeaders,
    ShareGetAccessPolicyHeaders: ShareGetAccessPolicyHeaders,
    ShareGetPermissionHeaders: ShareGetPermissionHeaders,
    ShareGetPropertiesHeaders: ShareGetPropertiesHeaders,
    ShareGetStatisticsHeaders: ShareGetStatisticsHeaders,
    ShareSetAccessPolicyHeaders: ShareSetAccessPolicyHeaders,
    ShareSetMetadataHeaders: ShareSetMetadataHeaders,
    ShareSetQuotaHeaders: ShareSetQuotaHeaders,
    ShareStats: ShareStats,
    SignedIdentifier: SignedIdentifier,
    StorageError: StorageError
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a Share. */
var Share = /** @class */ (function () {
    /**
     * Create a Share.
     * @param {StorageClientContext} client Reference to the service client.
     */
    function Share(client) {
        this.client = client;
    }
    Share.prototype.create = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, createOperationSpec, callback);
    };
    Share.prototype.getProperties = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, getPropertiesOperationSpec$1, callback);
    };
    Share.prototype.deleteMethod = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, deleteMethodOperationSpec, callback);
    };
    Share.prototype.createSnapshot = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, createSnapshotOperationSpec, callback);
    };
    Share.prototype.createPermission = function (permission, options, callback) {
        return this.client.sendOperationRequest({
            permission: permission,
            options: options
        }, createPermissionOperationSpec, callback);
    };
    Share.prototype.getPermission = function (filePermissionKey, options, callback) {
        return this.client.sendOperationRequest({
            filePermissionKey: filePermissionKey,
            options: options
        }, getPermissionOperationSpec, callback);
    };
    Share.prototype.setQuota = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, setQuotaOperationSpec, callback);
    };
    Share.prototype.setMetadata = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, setMetadataOperationSpec, callback);
    };
    Share.prototype.getAccessPolicy = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, getAccessPolicyOperationSpec, callback);
    };
    Share.prototype.setAccessPolicy = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, setAccessPolicyOperationSpec, callback);
    };
    Share.prototype.getStatistics = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, getStatisticsOperationSpec, callback);
    };
    return Share;
}());
// Operation Specifications
var serializer$1 = new coreHttp.Serializer(Mappers$1, true);
var createOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype1
    ],
    headerParameters: [
        metadata,
        quota,
        version
    ],
    responses: {
        201: {
            headersMapper: ShareCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareCreateHeaders
        }
    },
    isXML: true,
    serializer: serializer$1
};
var getPropertiesOperationSpec$1 = {
    httpMethod: "GET",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        shareSnapshot,
        timeoutInSeconds,
        restype1
    ],
    headerParameters: [
        version
    ],
    responses: {
        200: {
            headersMapper: ShareGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetPropertiesHeaders
        }
    },
    isXML: true,
    serializer: serializer$1
};
var deleteMethodOperationSpec = {
    httpMethod: "DELETE",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        shareSnapshot,
        timeoutInSeconds,
        restype1
    ],
    headerParameters: [
        version,
        deleteSnapshots
    ],
    responses: {
        202: {
            headersMapper: ShareDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareDeleteHeaders
        }
    },
    isXML: true,
    serializer: serializer$1
};
var createSnapshotOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp2
    ],
    headerParameters: [
        metadata,
        version
    ],
    responses: {
        201: {
            headersMapper: ShareCreateSnapshotHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareCreateSnapshotHeaders
        }
    },
    isXML: true,
    serializer: serializer$1
};
var createPermissionOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp3
    ],
    headerParameters: [
        version
    ],
    requestBody: {
        parameterPath: "permission",
        mapper: tslib.__assign(tslib.__assign({}, Permission), { required: true })
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        201: {
            headersMapper: ShareCreatePermissionHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareCreatePermissionHeaders
        }
    },
    isXML: false,
    serializer: serializer$1
};
var getPermissionOperationSpec = {
    httpMethod: "GET",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp3
    ],
    headerParameters: [
        filePermissionKey0,
        version
    ],
    responses: {
        200: {
            bodyMapper: Permission,
            headersMapper: ShareGetPermissionHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetPermissionHeaders
        }
    },
    isXML: true,
    serializer: serializer$1
};
var setQuotaOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp0
    ],
    headerParameters: [
        version,
        quota
    ],
    responses: {
        200: {
            headersMapper: ShareSetQuotaHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareSetQuotaHeaders
        }
    },
    isXML: true,
    serializer: serializer$1
};
var setMetadataOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp4
    ],
    headerParameters: [
        metadata,
        version
    ],
    responses: {
        200: {
            headersMapper: ShareSetMetadataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareSetMetadataHeaders
        }
    },
    isXML: true,
    serializer: serializer$1
};
var getAccessPolicyOperationSpec = {
    httpMethod: "GET",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp5
    ],
    headerParameters: [
        version
    ],
    responses: {
        200: {
            bodyMapper: {
                xmlElementName: "SignedIdentifier",
                serializedName: "parsedResponse",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SignedIdentifier"
                        }
                    }
                }
            },
            headersMapper: ShareGetAccessPolicyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetAccessPolicyHeaders
        }
    },
    isXML: true,
    serializer: serializer$1
};
var setAccessPolicyOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp5
    ],
    headerParameters: [
        version
    ],
    requestBody: {
        parameterPath: [
            "options",
            "shareAcl"
        ],
        mapper: {
            xmlName: "SignedIdentifiers",
            xmlElementName: "SignedIdentifier",
            serializedName: "shareAcl",
            type: {
                name: "Sequence",
                element: {
                    type: {
                        name: "Composite",
                        className: "SignedIdentifier"
                    }
                }
            }
        }
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        200: {
            headersMapper: ShareSetAccessPolicyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareSetAccessPolicyHeaders
        }
    },
    isXML: true,
    serializer: serializer$1
};
var getStatisticsOperationSpec = {
    httpMethod: "GET",
    path: "{shareName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp6
    ],
    headerParameters: [
        version
    ],
    responses: {
        200: {
            bodyMapper: ShareStats,
            headersMapper: ShareGetStatisticsHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetStatisticsHeaders
        }
    },
    isXML: true,
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DirectoryCreateHeaders: DirectoryCreateHeaders,
    DirectoryDeleteHeaders: DirectoryDeleteHeaders,
    DirectoryForceCloseHandlesHeaders: DirectoryForceCloseHandlesHeaders,
    DirectoryGetPropertiesHeaders: DirectoryGetPropertiesHeaders,
    DirectoryItem: DirectoryItem,
    DirectoryListFilesAndDirectoriesSegmentHeaders: DirectoryListFilesAndDirectoriesSegmentHeaders,
    DirectoryListHandlesHeaders: DirectoryListHandlesHeaders,
    DirectorySetMetadataHeaders: DirectorySetMetadataHeaders,
    DirectorySetPropertiesHeaders: DirectorySetPropertiesHeaders,
    FileItem: FileItem,
    FileProperty: FileProperty,
    FilesAndDirectoriesListSegment: FilesAndDirectoriesListSegment,
    HandleItem: HandleItem,
    ListFilesAndDirectoriesSegmentResponse: ListFilesAndDirectoriesSegmentResponse,
    ListHandlesResponse: ListHandlesResponse,
    StorageError: StorageError
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a Directory. */
var Directory = /** @class */ (function () {
    /**
     * Create a Directory.
     * @param {StorageClientContext} client Reference to the service client.
     */
    function Directory(client) {
        this.client = client;
    }
    Directory.prototype.create = function (fileAttributes, fileCreatedOn, fileLastWriteOn, options, callback) {
        return this.client.sendOperationRequest({
            fileAttributes: fileAttributes,
            fileCreatedOn: fileCreatedOn,
            fileLastWriteOn: fileLastWriteOn,
            options: options
        }, createOperationSpec$1, callback);
    };
    Directory.prototype.getProperties = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, getPropertiesOperationSpec$2, callback);
    };
    Directory.prototype.deleteMethod = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, deleteMethodOperationSpec$1, callback);
    };
    Directory.prototype.setProperties = function (fileAttributes, fileCreatedOn, fileLastWriteOn, options, callback) {
        return this.client.sendOperationRequest({
            fileAttributes: fileAttributes,
            fileCreatedOn: fileCreatedOn,
            fileLastWriteOn: fileLastWriteOn,
            options: options
        }, setPropertiesOperationSpec$1, callback);
    };
    Directory.prototype.setMetadata = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, setMetadataOperationSpec$1, callback);
    };
    Directory.prototype.listFilesAndDirectoriesSegment = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, listFilesAndDirectoriesSegmentOperationSpec, callback);
    };
    Directory.prototype.listHandles = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, listHandlesOperationSpec, callback);
    };
    Directory.prototype.forceCloseHandles = function (handleId, options, callback) {
        return this.client.sendOperationRequest({
            handleId: handleId,
            options: options
        }, forceCloseHandlesOperationSpec, callback);
    };
    return Directory;
}());
// Operation Specifications
var serializer$2 = new coreHttp.Serializer(Mappers$2, true);
var createOperationSpec$1 = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype2
    ],
    headerParameters: [
        metadata,
        version,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn
    ],
    responses: {
        201: {
            headersMapper: DirectoryCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryCreateHeaders
        }
    },
    isXML: true,
    serializer: serializer$2
};
var getPropertiesOperationSpec$2 = {
    httpMethod: "GET",
    path: "{shareName}/{directory}",
    urlParameters: [
        url
    ],
    queryParameters: [
        shareSnapshot,
        timeoutInSeconds,
        restype2
    ],
    headerParameters: [
        version
    ],
    responses: {
        200: {
            headersMapper: DirectoryGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryGetPropertiesHeaders
        }
    },
    isXML: true,
    serializer: serializer$2
};
var deleteMethodOperationSpec$1 = {
    httpMethod: "DELETE",
    path: "{shareName}/{directory}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype2
    ],
    headerParameters: [
        version
    ],
    responses: {
        202: {
            headersMapper: DirectoryDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryDeleteHeaders
        }
    },
    isXML: true,
    serializer: serializer$2
};
var setPropertiesOperationSpec$1 = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype2,
        comp0
    ],
    headerParameters: [
        version,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn
    ],
    responses: {
        200: {
            headersMapper: DirectorySetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectorySetPropertiesHeaders
        }
    },
    isXML: true,
    serializer: serializer$2
};
var setMetadataOperationSpec$1 = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        restype2,
        comp4
    ],
    headerParameters: [
        metadata,
        version
    ],
    responses: {
        200: {
            headersMapper: DirectorySetMetadataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectorySetMetadataHeaders
        }
    },
    isXML: true,
    serializer: serializer$2
};
var listFilesAndDirectoriesSegmentOperationSpec = {
    httpMethod: "GET",
    path: "{shareName}/{directory}",
    urlParameters: [
        url
    ],
    queryParameters: [
        prefix,
        shareSnapshot,
        marker,
        maxResults,
        timeoutInSeconds,
        restype2,
        comp1
    ],
    headerParameters: [
        version
    ],
    responses: {
        200: {
            bodyMapper: ListFilesAndDirectoriesSegmentResponse,
            headersMapper: DirectoryListFilesAndDirectoriesSegmentHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryListFilesAndDirectoriesSegmentHeaders
        }
    },
    isXML: true,
    serializer: serializer$2
};
var listHandlesOperationSpec = {
    httpMethod: "GET",
    path: "{shareName}/{directory}",
    urlParameters: [
        url
    ],
    queryParameters: [
        marker,
        maxResults,
        timeoutInSeconds,
        shareSnapshot,
        comp7
    ],
    headerParameters: [
        recursive,
        version
    ],
    responses: {
        200: {
            bodyMapper: ListHandlesResponse,
            headersMapper: DirectoryListHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryListHandlesHeaders
        }
    },
    isXML: true,
    serializer: serializer$2
};
var forceCloseHandlesOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        marker,
        shareSnapshot,
        comp8
    ],
    headerParameters: [
        handleId,
        recursive,
        version
    ],
    responses: {
        200: {
            headersMapper: DirectoryForceCloseHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryForceCloseHandlesHeaders
        }
    },
    isXML: true,
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FileAbortCopyHeaders: FileAbortCopyHeaders,
    FileCreateHeaders: FileCreateHeaders,
    FileDeleteHeaders: FileDeleteHeaders,
    FileDownloadHeaders: FileDownloadHeaders,
    FileForceCloseHandlesHeaders: FileForceCloseHandlesHeaders,
    FileGetPropertiesHeaders: FileGetPropertiesHeaders,
    FileGetRangeListHeaders: FileGetRangeListHeaders,
    FileListHandlesHeaders: FileListHandlesHeaders,
    FileSetHTTPHeadersHeaders: FileSetHTTPHeadersHeaders,
    FileSetMetadataHeaders: FileSetMetadataHeaders,
    FileStartCopyHeaders: FileStartCopyHeaders,
    FileUploadRangeFromURLHeaders: FileUploadRangeFromURLHeaders,
    FileUploadRangeHeaders: FileUploadRangeHeaders,
    HandleItem: HandleItem,
    ListHandlesResponse: ListHandlesResponse,
    Range: Range,
    StorageError: StorageError
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a File. */
var File = /** @class */ (function () {
    /**
     * Create a File.
     * @param {StorageClientContext} client Reference to the service client.
     */
    function File(client) {
        this.client = client;
    }
    File.prototype.create = function (fileContentLength, fileAttributes, fileCreatedOn, fileLastWriteOn, options, callback) {
        return this.client.sendOperationRequest({
            fileContentLength: fileContentLength,
            fileAttributes: fileAttributes,
            fileCreatedOn: fileCreatedOn,
            fileLastWriteOn: fileLastWriteOn,
            options: options
        }, createOperationSpec$2, callback);
    };
    File.prototype.download = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, downloadOperationSpec, callback);
    };
    File.prototype.getProperties = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, getPropertiesOperationSpec$3, callback);
    };
    File.prototype.deleteMethod = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, deleteMethodOperationSpec$2, callback);
    };
    File.prototype.setHTTPHeaders = function (fileAttributes, fileCreatedOn, fileLastWriteOn, options, callback) {
        return this.client.sendOperationRequest({
            fileAttributes: fileAttributes,
            fileCreatedOn: fileCreatedOn,
            fileLastWriteOn: fileLastWriteOn,
            options: options
        }, setHTTPHeadersOperationSpec, callback);
    };
    File.prototype.setMetadata = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, setMetadataOperationSpec$2, callback);
    };
    File.prototype.uploadRange = function (range, fileRangeWrite, contentLength, options, callback) {
        return this.client.sendOperationRequest({
            range: range,
            fileRangeWrite: fileRangeWrite,
            contentLength: contentLength,
            options: options
        }, uploadRangeOperationSpec, callback);
    };
    File.prototype.uploadRangeFromURL = function (range, copySource, sourceRange, contentLength, options, callback) {
        return this.client.sendOperationRequest({
            range: range,
            copySource: copySource,
            sourceRange: sourceRange,
            contentLength: contentLength,
            options: options
        }, uploadRangeFromURLOperationSpec, callback);
    };
    File.prototype.getRangeList = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, getRangeListOperationSpec, callback);
    };
    File.prototype.startCopy = function (copySource, options, callback) {
        return this.client.sendOperationRequest({
            copySource: copySource,
            options: options
        }, startCopyOperationSpec, callback);
    };
    File.prototype.abortCopy = function (copyId, options, callback) {
        return this.client.sendOperationRequest({
            copyId: copyId,
            options: options
        }, abortCopyOperationSpec, callback);
    };
    File.prototype.listHandles = function (options, callback) {
        return this.client.sendOperationRequest({
            options: options
        }, listHandlesOperationSpec$1, callback);
    };
    File.prototype.forceCloseHandles = function (handleId, options, callback) {
        return this.client.sendOperationRequest({
            handleId: handleId,
            options: options
        }, forceCloseHandlesOperationSpec$1, callback);
    };
    return File;
}());
// Operation Specifications
var serializer$3 = new coreHttp.Serializer(Mappers$3, true);
var createOperationSpec$2 = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds
    ],
    headerParameters: [
        version,
        fileContentLength0,
        fileTypeConstant,
        metadata,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn,
        fileContentType,
        fileContentEncoding,
        fileContentLanguage,
        fileCacheControl,
        fileContentMD5,
        fileContentDisposition
    ],
    responses: {
        201: {
            headersMapper: FileCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileCreateHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var downloadOperationSpec = {
    httpMethod: "GET",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds
    ],
    headerParameters: [
        version,
        range0,
        rangeGetContentMD5
    ],
    responses: {
        200: {
            bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: FileDownloadHeaders
        },
        206: {
            bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: FileDownloadHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileDownloadHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var getPropertiesOperationSpec$3 = {
    httpMethod: "HEAD",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        shareSnapshot,
        timeoutInSeconds
    ],
    headerParameters: [
        version
    ],
    responses: {
        200: {
            headersMapper: FileGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileGetPropertiesHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var deleteMethodOperationSpec$2 = {
    httpMethod: "DELETE",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds
    ],
    headerParameters: [
        version
    ],
    responses: {
        202: {
            headersMapper: FileDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileDeleteHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var setHTTPHeadersOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        comp0
    ],
    headerParameters: [
        version,
        fileContentLength1,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn,
        fileContentType,
        fileContentEncoding,
        fileContentLanguage,
        fileCacheControl,
        fileContentMD5,
        fileContentDisposition
    ],
    responses: {
        200: {
            headersMapper: FileSetHTTPHeadersHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSetHTTPHeadersHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var setMetadataOperationSpec$2 = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        comp4
    ],
    headerParameters: [
        metadata,
        version
    ],
    responses: {
        200: {
            headersMapper: FileSetMetadataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSetMetadataHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var uploadRangeOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        comp9
    ],
    headerParameters: [
        range1,
        fileRangeWrite,
        contentLength,
        contentMD5,
        version
    ],
    requestBody: {
        parameterPath: [
            "options",
            "optionalbody"
        ],
        mapper: {
            serializedName: "optionalbody",
            type: {
                name: "Stream"
            }
        }
    },
    contentType: "application/octet-stream",
    responses: {
        201: {
            headersMapper: FileUploadRangeHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileUploadRangeHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var uploadRangeFromURLOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        comp9
    ],
    headerParameters: [
        range1,
        copySource,
        sourceRange,
        fileRangeWriteFromUrl,
        contentLength,
        sourceContentCrc64,
        version,
        sourceIfMatchCrc64,
        sourceIfNoneMatchCrc64
    ],
    responses: {
        201: {
            headersMapper: FileUploadRangeFromURLHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileUploadRangeFromURLHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var getRangeListOperationSpec = {
    httpMethod: "GET",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        shareSnapshot,
        timeoutInSeconds,
        comp10
    ],
    headerParameters: [
        version,
        range0
    ],
    responses: {
        200: {
            bodyMapper: {
                xmlElementName: "Range",
                serializedName: "parsedResponse",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Range"
                        }
                    }
                }
            },
            headersMapper: FileGetRangeListHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileGetRangeListHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var startCopyOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds
    ],
    headerParameters: [
        version,
        metadata,
        copySource
    ],
    responses: {
        202: {
            headersMapper: FileStartCopyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileStartCopyHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var abortCopyOperationSpec = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        copyId,
        timeoutInSeconds,
        comp11
    ],
    headerParameters: [
        copyActionAbortConstant,
        version
    ],
    responses: {
        204: {
            headersMapper: FileAbortCopyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileAbortCopyHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var listHandlesOperationSpec$1 = {
    httpMethod: "GET",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        marker,
        maxResults,
        timeoutInSeconds,
        shareSnapshot,
        comp7
    ],
    headerParameters: [
        version
    ],
    responses: {
        200: {
            bodyMapper: ListHandlesResponse,
            headersMapper: FileListHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileListHandlesHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};
var forceCloseHandlesOperationSpec$1 = {
    httpMethod: "PUT",
    path: "{shareName}/{directory}/{fileName}",
    urlParameters: [
        url
    ],
    queryParameters: [
        timeoutInSeconds,
        marker,
        shareSnapshot,
        comp8
    ],
    headerParameters: [
        handleId,
        version
    ],
    responses: {
        200: {
            headersMapper: FileForceCloseHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileForceCloseHandlesHeaders
        }
    },
    isXML: true,
    serializer: serializer$3
};

/**
 * This is a helper class to construct a string representing the NTFS attributes to a file or directory.
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file#file-system-attributes
 *
 * @export
 * @class FileSystemAttributes
 */
var FileSystemAttributes = /** @class */ (function () {
    function FileSystemAttributes() {
        /**
         * Specifies a directory or file that is read-only.
         *
         * @type {boolean}
         * @memberof FileSystemAttributes
         */
        this.readonly = false;
        /**
         * Specifies a directory or file is hidden.
         *
         * @type {boolean}
         * @memberof FileSystemAttributes
         */
        this.hidden = false;
        /**
         * Specifies a directory or file that the operating system uses a part of, or uses exclusively.
         *
         * @type {boolean}
         * @memberof FileSystemAttributes
         */
        this.system = false;
        /**
         * Specifies a directory or file that does not have other attributes set. This attribute is valid only when used alone.
         *
         * @type {boolean}
         * @memberof FileSystemAttributes
         */
        this.none = false;
        /**
         * Specifies the handle identifies a directory.
         *
         * @type {boolean}
         * @memberof FileSystemAttributes
         */
        this.directory = false;
        /**
         * Specifies a directory or file is an archive. Applications typically use this attribute to mark files for backup or removal.
         *
         * @type {boolean}
         * @memberof FileSystemAttributes
         */
        this.archive = false;
        /**
         * Specifies if a file is temporary.
         */
        this.temporary = false;
        /**
         * Specifies the data of a directory or file is not available immediately.
         * This file system attribute is presented primarily to provide compatibility with Windows - Azure Files does not support with offline storage options.
         *
         * @type {boolean}
         * @memberof FileSystemAttributes
         */
        this.offline = false;
        /**
         * Specifies the directory or file is not to be indexed by the content indexing service.
         *
         * @type {boolean}
         * @memberof FileSystemAttributes
         */
        this.notContentIndexed = false;
        /**
         * Specifies the user data stream not to be read by the background data integrity scanner.
         * This file system attribute is presented primarily to provide compatibility with Windows.
         * Applicable to directory or file.
         *
         * @type {boolean}
         * @memberof FileSystemAttributes
         */
        this.noScrubData = false;
    }
    /**
     * Creates a FileSystemAttributes from the specified attributes string. This method will throw an
     * Error if it encounters a string that does not correspond to a valid attributes.
     *
     * @static
     * @param {string} fileAttributes The value of header x-ms-file-attributes.
     * @returns {FileSystemAttributes}
     * @memberof FileSystemAttributes
     */
    FileSystemAttributes.parse = function (fileAttributes) {
        if (!fileAttributes) {
            throw new RangeError("Invalid fileAttributes: '" + fileAttributes + "'.");
        }
        var fileSystemAttributes = new FileSystemAttributes();
        var attributes = fileAttributes.trim().split('|');
        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
            var str = attributes_1[_i];
            str = str.trim();
            switch (str) {
                case "ReadOnly":
                    fileSystemAttributes.readonly = true;
                    break;
                case "Hidden":
                    fileSystemAttributes.hidden = true;
                    break;
                case "System":
                    fileSystemAttributes.system = true;
                    break;
                case "None":
                    fileSystemAttributes.none = true;
                    break;
                case "Temporary":
                    fileSystemAttributes.temporary = true;
                    break;
                case "Offline":
                    fileSystemAttributes.offline = true;
                    break;
                case "Directory":
                    fileSystemAttributes.directory = true;
                    break;
                case "Archive":
                    fileSystemAttributes.archive = true;
                    break;
                case "NotContentIndexed":
                    fileSystemAttributes.notContentIndexed = true;
                    break;
                case "NoScrubData":
                    fileSystemAttributes.noScrubData = true;
                    break;
                default:
                    throw new RangeError("Invalid attribute: " + str);
            }
        }
        return fileSystemAttributes;
    };
    /**
     * Converts the given attributes to a string.
     *
     * @returns {string} A string which represents the FileSystemAttributes
     * @memberof FileSystemAttributes
     */
    FileSystemAttributes.prototype.toString = function () {
        var attributes = [];
        if (this.readonly) {
            attributes.push("ReadOnly");
        }
        if (this.hidden) {
            attributes.push("Hidden");
        }
        if (this.system) {
            attributes.push("System");
        }
        if (this.none) {
            attributes.push("None");
        }
        if (this.temporary) {
            attributes.push("Temporary");
        }
        if (this.directory) {
            attributes.push("Directory");
        }
        if (this.archive) {
            attributes.push("Archive");
        }
        if (this.offline) {
            attributes.push("Offline");
        }
        if (this.notContentIndexed) {
            attributes.push("NotContentIndexed");
        }
        if (this.noScrubData) {
            attributes.push("NoScrubData");
        }
        return attributes.join("|");
    };
    return FileSystemAttributes;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
function validateFilePermissionOptions(filePermission, filePermissionKey) {
    if (filePermission && filePermissionKey) {
        throw new RangeError("Only one of filePermission or filePermissionKey can be specified.");
    }
}
function validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options) {
    // Would better deep copy params set by user.
    if (!options) {
        options = {};
    }
    validateFilePermissionOptions(options.filePermission, options.filePermissionKey);
    if (!options.creationTime) {
        options.creationTime = "now";
    }
    if (!options.lastWriteTime) {
        options.lastWriteTime = "now";
    }
    if (!options.filePermission && !options.filePermissionKey) {
        options.filePermission = "inherit";
    }
    return options;
}
function validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options) {
    // Would better deep copy params set by user.
    if (!options) {
        options = {};
    }
    validateFilePermissionOptions(options.filePermission, options.filePermissionKey);
    if (!options.creationTime) {
        options.creationTime = "preserve";
    }
    if (!options.lastWriteTime) {
        options.lastWriteTime = "preserve";
    }
    if (!options.fileAttributes) {
        options.fileAttributes = "preserve";
    }
    if (!options.filePermission && !options.filePermissionKey) {
        options.filePermission = "preserve";
    }
    return options;
}
function fileAttributesToString(fileAttributes) {
    return fileAttributes instanceof FileSystemAttributes
        ? fileAttributes.toString()
        : fileAttributes;
}
function fileCreationTimeToString(time) {
    return time instanceof Date ? truncatedISO8061Date(time) : time;
}
function fileLastWriteTimeToString(time) {
    return time instanceof Date ? truncatedISO8061Date(time) : time;
}

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
var logger = logger$1.createClientLogger("storage-file-share");

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * StorageBrowserPolicy will handle differences between Node.js and browser runtime, including:
 *
 * 1. Browsers cache GET/HEAD requests by adding conditional headers such as 'IF_MODIFIED_SINCE'.
 * StorageBrowserPolicy is a policy used to add a timestamp query to GET/HEAD request URL
 * thus avoid the browser cache.
 *
 * 2. Remove cookie header for security
 *
 * 3. Remove content-length header to avoid browsers warning
 *
 * @class StorageBrowserPolicy
 * @extends {BaseRequestPolicy}
 */
var StorageBrowserPolicy = /** @class */ (function (_super) {
    tslib.__extends(StorageBrowserPolicy, _super);
    /**
     * Creates an instance of StorageBrowserPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @memberof StorageBrowserPolicy
     */
    function StorageBrowserPolicy(nextPolicy, options) {
        return _super.call(this, nextPolicy, options) || this;
    }
    /**
     * Sends out request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof StorageBrowserPolicy
     */
    StorageBrowserPolicy.prototype.sendRequest = function (request) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                {
                    return [2 /*return*/, this._nextPolicy.sendRequest(request)];
                }
            });
        });
    };
    return StorageBrowserPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * StorageBrowserPolicyFactory is a factory class helping generating BrowserPolicy objects.
 *
 * @export
 * @class StorageBrowserPolicyFactory
 * @implements {RequestPolicyFactory}
 */
var StorageBrowserPolicyFactory = /** @class */ (function () {
    function StorageBrowserPolicyFactory() {
    }
    /**
     * Creates a StorageBrowserPolicyFactory object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {StorageBrowserPolicy}
     * @memberof StorageBrowserPolicyFactory
     */
    StorageBrowserPolicyFactory.prototype.create = function (nextPolicy, options) {
        return new StorageBrowserPolicy(nextPolicy, options);
    };
    return StorageBrowserPolicyFactory;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (StorageRetryPolicyType) {
    /**
     * Exponential retry. Retry time delay grows exponentially.
     */
    StorageRetryPolicyType[StorageRetryPolicyType["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    /**
     * Linear retry. Retry time delay grows linearly.
     */
    StorageRetryPolicyType[StorageRetryPolicyType["FIXED"] = 1] = "FIXED";
})(exports.StorageRetryPolicyType || (exports.StorageRetryPolicyType = {}));
// Default values of RetryOptions
var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: exports.StorageRetryPolicyType.EXPONENTIAL,
    tryTimeoutInMs: undefined // Use server side default timeout strategy
};
var RETRY_ABORT_ERROR = new abortController.AbortError("The operation was aborted.");
/**
 * Retry policy with exponential retry and linear retry implemented.
 *
 * @class RetryPolicy
 * @extends {BaseRequestPolicy}
 */
var StorageRetryPolicy = /** @class */ (function (_super) {
    tslib.__extends(StorageRetryPolicy, _super);
    /**
     * Creates an instance of RetryPolicy.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @param {StorageRetryOptions} [retryOptions=DEFAULT_RETRY_OPTIONS]
     * @memberof StorageRetryPolicy
     */
    function StorageRetryPolicy(nextPolicy, options, retryOptions) {
        if (retryOptions === void 0) { retryOptions = DEFAULT_RETRY_OPTIONS; }
        var _this = _super.call(this, nextPolicy, options) || this;
        // Initialize retry options
        _this.retryOptions = {
            retryPolicyType: retryOptions.retryPolicyType
                ? retryOptions.retryPolicyType
                : DEFAULT_RETRY_OPTIONS.retryPolicyType,
            maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1
                ? Math.floor(retryOptions.maxTries)
                : DEFAULT_RETRY_OPTIONS.maxTries,
            tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0
                ? retryOptions.tryTimeoutInMs
                : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
            retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0
                ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs
                    ? retryOptions.maxRetryDelayInMs
                    : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs)
                : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
            maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0
                ? retryOptions.maxRetryDelayInMs
                : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs
        };
        return _this;
    }
    /**
     * Sends request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof StorageRetryPolicy
     */
    StorageRetryPolicy.prototype.sendRequest = function (request) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, this.attemptSendRequest(request, false, 1)];
            });
        });
    };
    /**
     * Decide and perform next retry. Won't mutate request parameter.
     *
     * @protected
     * @param {WebResource} request
     * @param {HttpOperationResponse} response
     * @param {boolean} secondaryHas404  If attempt was against the secondary & it returned a StatusNotFound (404), then
     *                                   the resource was not found. This may be due to replication delay. So, in this
     *                                   case, we'll never try the secondary again for this operation.
     * @param {number} attempt           How many retries has been attempted to performed, starting from 1, which includes
     *                                   the attempt will be performed by this method call.
     * @returns {Promise<HttpOperationResponse>}
     * @memberof StorageRetryPolicy
     */
    StorageRetryPolicy.prototype.attemptSendRequest = function (request, secondaryHas404, attempt) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var newRequest, isPrimaryRetry, response, err_1;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newRequest = request.clone();
                        isPrimaryRetry = true;
                        // Set the server-side timeout query parameter "timeout=[seconds]"
                        if (this.retryOptions.tryTimeoutInMs) {
                            newRequest.url = setURLParameter(newRequest.url, URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        this.logf(coreHttp.HttpPipelineLogLevel.INFO, "RetryPolicy: =====> Try=" + attempt + " " + (isPrimaryRetry ? "Primary" : "Secondary"));
                        return [4 /*yield*/, this._nextPolicy.sendRequest(newRequest)];
                    case 2:
                        response = _a.sent();
                        if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
                            return [2 /*return*/, response];
                        }
                        secondaryHas404 = secondaryHas404 || (!isPrimaryRetry && response.status === 404);
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        this.logf(coreHttp.HttpPipelineLogLevel.ERROR, "RetryPolicy: Caught error, message: " + err_1.message + ", code: " + err_1.code);
                        if (!this.shouldRetry(isPrimaryRetry, attempt, response, err_1)) {
                            throw err_1;
                        }
                        return [3 /*break*/, 4];
                    case 4: return [4 /*yield*/, this.delay(isPrimaryRetry, attempt, request.abortSignal)];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, this.attemptSendRequest(request, secondaryHas404, ++attempt)];
                    case 6: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Decide whether to retry according to last HTTP response and retry counters.
     *
     * @protected
     * @param {boolean} isPrimaryRetry
     * @param {number} attempt
     * @param {HttpOperationResponse} [response]
     * @param {RestError} [err]
     * @returns {boolean}
     * @memberof StorageRetryPolicy
     */
    StorageRetryPolicy.prototype.shouldRetry = function (isPrimaryRetry, attempt, response, err) {
        if (attempt >= this.retryOptions.maxTries) {
            this.logf(coreHttp.HttpPipelineLogLevel.INFO, "RetryPolicy: Attempt(s) " + attempt + " >= maxTries " + this.retryOptions
                .maxTries + ", no further try.");
            return false;
        }
        // Handle network failures, you may need to customize the list when you implement
        // your own http client
        var retriableErrors = [
            "ETIMEDOUT",
            "ESOCKETTIMEDOUT",
            "ECONNREFUSED",
            "ECONNRESET",
            "ENOENT",
            "ENOTFOUND",
            "TIMEOUT",
            "REQUEST_SEND_ERROR" // For default xhr based http client provided in ms-rest-js
        ];
        if (err) {
            for (var _i = 0, retriableErrors_1 = retriableErrors; _i < retriableErrors_1.length; _i++) {
                var retriableError = retriableErrors_1[_i];
                if (err.name.toUpperCase().includes(retriableError) ||
                    err.message.toUpperCase().includes(retriableError) ||
                    (err.code &&
                        err.code
                            .toString()
                            .toUpperCase()
                            .includes(retriableError))) {
                    this.logf(coreHttp.HttpPipelineLogLevel.INFO, "RetryPolicy: Network error " + retriableError + " found, will retry.");
                    return true;
                }
            }
        }
        // If attempt was against the secondary & it returned a StatusNotFound (404), then
        // the resource was not found. This may be due to replication delay. So, in this
        // case, we'll never try the secondary again for this operation.
        if (response || err) {
            var statusCode = response ? response.status : err ? err.statusCode : 0;
            if (!isPrimaryRetry && statusCode === 404) {
                this.logf(coreHttp.HttpPipelineLogLevel.INFO, "RetryPolicy: Secondary access with 404, will retry.");
                return true;
            }
            // Server internal error or server timeout
            if (statusCode === 503 || statusCode === 500) {
                this.logf(coreHttp.HttpPipelineLogLevel.INFO, "RetryPolicy: Will retry for status code " + statusCode + ".");
                return true;
            }
        }
        return false;
    };
    /**
     * This is to log for debugging purposes only.
     * Comment/uncomment as necessary for releasing/debugging.
     *
     * @private
     * @param {HttpPipelineLogLevel} level
     * @param {string} message
     * @memberof StorageRetryPolicy
     */
    // tslint:disable-next-line:variable-name
    StorageRetryPolicy.prototype.logf = function (_level, _message) {
        // this.log(_level, _message);
    };
    /**
     * Delay a calculated time between retries.
     *
     * @private
     * @param {boolean} isPrimaryRetry
     * @param {number} attempt
     * @param {AbortSignalLike} [abortSignal]
     * @returns
     * @memberof StorageRetryPolicy
     */
    StorageRetryPolicy.prototype.delay = function (isPrimaryRetry, attempt, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var delayTimeInMs;
            return tslib.__generator(this, function (_a) {
                delayTimeInMs = 0;
                if (isPrimaryRetry) {
                    switch (this.retryOptions.retryPolicyType) {
                        case exports.StorageRetryPolicyType.EXPONENTIAL:
                            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
                            break;
                        case exports.StorageRetryPolicyType.FIXED:
                            delayTimeInMs = this.retryOptions.retryDelayInMs;
                            break;
                    }
                }
                else {
                    delayTimeInMs = Math.random() * 1000;
                }
                this.logf(coreHttp.HttpPipelineLogLevel.INFO, "RetryPolicy: Delay for " + delayTimeInMs + "ms");
                return [2 /*return*/, delay(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR)];
            });
        });
    };
    return StorageRetryPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * StorageRetryPolicyFactory is a factory class helping generating StorageRetryPolicy objects.
 *
 * @export
 * @class StorageRetryPolicyFactory
 * @implements {RequestPolicyFactory}
 */
var StorageRetryPolicyFactory = /** @class */ (function () {
    /**
     * Creates an instance of StorageRetryPolicyFactory.
     * @param {StorageRetryOptions} [retryOptions]
     * @memberof StorageRetryPolicyFactory
     */
    function StorageRetryPolicyFactory(retryOptions) {
        this.retryOptions = retryOptions;
    }
    /**
     * Creates a StorageRetryPolicy object.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {StorageRetryPolicy}
     * @memberof StorageRetryPolicyFactory
     */
    StorageRetryPolicyFactory.prototype.create = function (nextPolicy, options) {
        return new StorageRetryPolicy(nextPolicy, options, this.retryOptions);
    };
    return StorageRetryPolicyFactory;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * TelemetryPolicy is a policy used to tag user-agent header for every requests.
 *
 * @class TelemetryPolicy
 * @extends {BaseRequestPolicy}
 */
var TelemetryPolicy = /** @class */ (function (_super) {
    tslib.__extends(TelemetryPolicy, _super);
    /**
     * Creates an instance of TelemetryPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @param {TelemetryOptions} [telemetry]
     * @memberof TelemetryPolicy
     */
    function TelemetryPolicy(nextPolicy, options, telemetry) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.telemetry = telemetry;
        return _this;
    }
    /**
     * Sends out request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof TelemetryPolicy
     */
    TelemetryPolicy.prototype.sendRequest = function (request) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                {
                    if (!request.headers) {
                        request.headers = new coreHttp.HttpHeaders();
                    }
                    if (!request.headers.get(HeaderConstants.USER_AGENT)) {
                        request.headers.set(HeaderConstants.USER_AGENT, this.telemetry);
                    }
                }
                return [2 /*return*/, this._nextPolicy.sendRequest(request)];
            });
        });
    };
    return TelemetryPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * TelemetryPolicyFactory is a factory class helping generating TelemetryPolicy objects.
 *
 * @export
 * @class TelemetryPolicyFactory
 * @implements {RequestPolicyFactory}
 */
var TelemetryPolicyFactory = /** @class */ (function () {
    /**
     * Creates an instance of TelemetryPolicyFactory.
     * @param {UserAgentOptions} [telemetry]
     * @memberof TelemetryPolicyFactory
     */
    function TelemetryPolicyFactory(telemetry) {
        var userAgentInfo = [];
        {
            if (telemetry) {
                var telemetryString = (telemetry.userAgentPrefix || "").replace(" ", "");
                if (telemetryString.length > 0 && userAgentInfo.indexOf(telemetryString) === -1) {
                    userAgentInfo.push(telemetryString);
                }
            }
            // e.g. azsdk-js-storagefile/11.0.0
            var libInfo = "azsdk-js-storagefile/" + SDK_VERSION;
            if (userAgentInfo.indexOf(libInfo) === -1) {
                userAgentInfo.push(libInfo);
            }
            // e.g. (NODE-VERSION 4.9.1; Windows_NT 10.0.16299)
            var runtimeInfo = "(NODE-VERSION " + process.version + "; " + os.type() + " " + os.release() + ")";
            if (userAgentInfo.indexOf(runtimeInfo) === -1) {
                userAgentInfo.push(runtimeInfo);
            }
        }
        this.telemetryString = userAgentInfo.join(" ");
    }
    /**
     * Creates a RequestPolicy object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {TelemetryPolicy}
     * @memberof TelemetryPolicyFactory
     */
    TelemetryPolicyFactory.prototype.create = function (nextPolicy, options) {
        return new TelemetryPolicy(nextPolicy, options, this.telemetryString);
    };
    return TelemetryPolicyFactory;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A Pipeline class containing HTTP request policies.
 * You can create a default Pipeline by calling newPipeline().
 * Or you can create a Pipeline with your own policies by the constructor of Pipeline.
 * Refer to newPipeline() and provided policies as reference before
 * implementing your customized Pipeline.
 *
 * @export
 * @class Pipeline
 */
var Pipeline = /** @class */ (function () {
    /**
     * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
     *
     * @param {RequestPolicyFactory[]} factories
     * @param {PipelineOptions} [options={}]
     * @memberof Pipeline
     */
    function Pipeline(factories, options) {
        if (options === void 0) { options = {}; }
        this.factories = factories;
        this.options = options;
    }
    /**
     * Transfer Pipeline object to ServiceClientOptions object which required by
     * ServiceClient constructor.
     *
     * @returns {ServiceClientOptions} The ServiceClientOptions object from this Pipeline.
     * @memberof Pipeline
     */
    Pipeline.prototype.toServiceClientOptions = function () {
        return {
            httpClient: this.options.httpClient,
            requestPolicyFactories: this.factories
        };
    };
    return Pipeline;
}());
/**
 * Creates a new Pipeline object with Credential provided.
 *
 * @static
 * @param {Credential} credential Such as AnonymousCredential, StorageSharedKeyCredential.
 * @param {StoragePipelineOptions} [pipelineOptions] Optional. Options.
 * @returns {Pipeline} A new Pipeline object.
 * @memberof Pipeline
 */
function newPipeline(credential, pipelineOptions) {
    if (pipelineOptions === void 0) { pipelineOptions = {}; }
    // Order is important. Closer to the API at the top & closer to the network at the bottom.
    // The credential's policy factory must appear close to the wire so it can sign any
    // changes made by other factories (like UniqueRequestIDPolicyFactory)
    var factories = [
        coreHttp.tracingPolicy(),
        coreHttp.keepAlivePolicy(pipelineOptions.keepAliveOptions),
        new TelemetryPolicyFactory(pipelineOptions.userAgentOptions),
        coreHttp.generateClientRequestIdPolicy(),
        new StorageBrowserPolicyFactory(),
        coreHttp.deserializationPolicy(),
        new StorageRetryPolicyFactory(pipelineOptions.retryOptions),
        coreHttp.logPolicy({
            logger: logger.info,
            allowedHeaderNames: StorageFileLoggingAllowedHeaderNames,
            allowedQueryParameters: StorageFileLoggingAllowedQueryParameters
        })
    ];
    {
        // ProxyPolicy is only avaiable in Node.js runtime, not in browsers
        factories.push(coreHttp.proxyPolicy(pipelineOptions.proxyOptions));
    }
    factories.push(credential);
    return new Pipeline(factories, {
        httpClient: pipelineOptions.httpClient
    });
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var packageName = "azure-storage-file";
var packageVersion = "12.0.0-preview.6";
var StorageClientContext = /** @class */ (function (_super) {
    tslib.__extends(StorageClientContext, _super);
    /**
     * Initializes a new instance of the StorageClientContext class.
     * @param version Specifies the version of the operation to use for this request.
     * @param url The URL of the service account, share, directory or file that is the target of the
     * desired operation.
     * @param [options] The parameter options
     */
    function StorageClientContext(version, url, options) {
        var _this = this;
        if (version == undefined) {
            throw new Error("'version' cannot be null.");
        }
        if (url == undefined) {
            throw new Error("'url' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            var defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = packageName + "/" + packageVersion + " " + defaultUserAgent;
        }
        _this = _super.call(this, undefined, options) || this;
        _this.fileRangeWriteFromUrl = 'update';
        _this.baseUri = "{url}";
        _this.requestContentType = "application/json; charset=utf-8";
        _this.version = version;
        _this.url = url;
        return _this;
    }
    return StorageClientContext;
}(coreHttp.ServiceClient));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A StorageClient represents a base client class for ServiceClient, ContainerClient and etc.
 *
 * @export
 * @class StorageClient
 */
var StorageClient = /** @class */ (function () {
    /**
     * Creates an instance of StorageClient.
     * @param {string} url
     * @param {Pipeline} pipeline
     * @memberof StorageClient
     */
    function StorageClient(url, pipeline) {
        // URL should be encoded and only once, protocol layer shouldn't encode URL again
        this.url = escapeURLPath(url);
        this.accountName = getAccountNameFromUrl(url);
        this.pipeline = pipeline;
        this.storageClientContext = new StorageClientContext(SERVICE_VERSION, this.url, pipeline.toServiceClientOptions());
        // Remove the default content-type in generated code of StorageClientContext
        var storageClientContext = this.storageClientContext;
        if (storageClientContext.requestContentType) {
            storageClientContext.requestContentType = undefined;
        }
    }
    return StorageClient;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
var ABORT_ERROR = new abortController.AbortError("The operation was aborted.");
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * A Node.js ReadableStream will internally retry when internal ReadableStream unexpected ends.
 *
 * @class RetriableReadableStream
 * @extends {Readable}
 */
var RetriableReadableStream = /** @class */ (function (_super) {
    tslib.__extends(RetriableReadableStream, _super);
    /**
     * Creates an instance of RetriableReadableStream.
     *
     * @param {NodeJS.ReadableStream} source The current ReadableStream returned from getter
     * @param {ReadableStreamGetter} getter A method calling downloading request returning
     *                                      a new ReadableStream from specified offset
     * @param {number} offset Offset position in original data source to read
     * @param {number} count How much data in original data source to read
     * @param {RetriableReadableStreamOptions} [options={}]
     * @memberof RetriableReadableStream
     */
    function RetriableReadableStream(source, getter, offset, count, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.retries = 0;
        _this.abortHandler = function () {
            _this.source.pause();
            _this.emit("error", ABORT_ERROR);
        };
        var aborter = options.abortSignal || abortController.AbortSignal.none;
        _this.aborter = aborter;
        _this.getter = getter;
        _this.source = source;
        _this.start = offset;
        _this.offset = offset;
        _this.end = offset + count - 1;
        _this.maxRetryRequests =
            options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
        _this.onProgress = options.onProgress;
        _this.options = options;
        aborter.addEventListener("abort", _this.abortHandler);
        _this.setSourceDataHandler();
        _this.setSourceEndHandler();
        _this.setSourceErrorHandler();
        return _this;
    }
    RetriableReadableStream.prototype._read = function () {
        if (!this.aborter.aborted) {
            this.source.resume();
        }
    };
    RetriableReadableStream.prototype.setSourceDataHandler = function () {
        var _this = this;
        this.source.on("data", function (data) {
            if (_this.options.doInjectErrorOnce) {
                _this.options.doInjectErrorOnce = undefined;
                _this.source.pause();
                _this.source.removeAllListeners("data");
                _this.source.emit("end");
                return;
            }
            // console.log(
            //   `Offset: ${this.offset}, Received ${data.length} from internal stream`
            // );
            _this.offset += data.length;
            if (_this.onProgress) {
                _this.onProgress({ loadedBytes: _this.offset - _this.start });
            }
            if (!_this.push(data)) {
                _this.source.pause();
            }
        });
    };
    RetriableReadableStream.prototype.setSourceEndHandler = function () {
        var _this = this;
        this.source.on("end", function () {
            // console.log(
            //   `Source stream emits end, offset: ${
            //     this.offset
            //   }, dest end : ${this.end}`
            // );
            if (_this.offset - 1 === _this.end) {
                _this.aborter.removeEventListener("abort", _this.abortHandler);
                _this.push(null);
            }
            else if (_this.offset <= _this.end) {
                // console.log(
                //   `retries: ${this.retries}, max retries: ${this.maxRetries}`
                // );
                if (_this.retries < _this.maxRetryRequests) {
                    _this.retries += 1;
                    _this.getter(_this.offset)
                        .then(function (newSource) {
                        _this.source = newSource;
                        _this.setSourceDataHandler();
                        _this.setSourceEndHandler();
                        _this.setSourceErrorHandler();
                    })
                        .catch(function (error) {
                        _this.emit("error", error);
                    });
                }
                else {
                    _this.emit("error", new Error(
                    // tslint:disable-next-line:max-line-length
                    "Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: " + (_this
                        .offset - 1) + ", data needed offset: " + _this.end + ", retries: " + _this.retries + ", max retries: " + _this.maxRetryRequests));
                }
            }
            else {
                _this.emit("error", new Error("Data corruption failure: Received more data than original request, data needed offset is " + _this.end + ", received offset: " + (_this.offset - 1)));
            }
        });
    };
    RetriableReadableStream.prototype.setSourceErrorHandler = function () {
        var _this = this;
        this.source.on("error", function (error) {
            _this.emit("error", error);
        });
    };
    return RetriableReadableStream;
}(stream.Readable));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * FileDownloadResponse implements FileDownloadResponseModel interface, and in Node.js runtime it will
 * automatically retry when internal read stream unexpected ends. (This kind of unexpected ends cannot
 * trigger retries defined in pipeline retry policy.)
 *
 * The readableStreamBody stream will retry underlayer, you can just use it as a normal Node.js
 * Readable stream.
 *
 * @export
 * @class FileDownloadResponse
 * @implements {FileDownloadResponseModel}
 */
var FileDownloadResponse = /** @class */ (function () {
    /**
     * Creates an instance of FileDownloadResponse.
     *
     * @param {FileDownloadResponseModel} originalResponse
     * @param {ReadableStreamGetter} getter
     * @param {number} offset
     * @param {number} count
     * @param {RetriableReadableStreamOptions} [options={}]
     * @memberof FileDownloadResponse
     */
    function FileDownloadResponse(originalResponse, getter, offset, count, options) {
        if (options === void 0) { options = {}; }
        this.originalResponse = originalResponse;
        this.fileDownloadStream = new RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
    }
    Object.defineProperty(FileDownloadResponse.prototype, "acceptRanges", {
        /**
         * Indicates that the service supports
         * requests for partial file content.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.acceptRanges;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "cacheControl", {
        /**
         * Returnes if it was previously specified
         * for the file.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.cacheControl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentDisposition", {
        /**
         * Returns the value that was specified
         * for the 'x-ms-content-disposition' header and specifies how to process the
         * response.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.contentDisposition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentEncoding", {
        /**
         * Returns the value that was specified
         * for the Content-Encoding request header.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.contentEncoding;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentLanguage", {
        /**
         * Returns the value that was specified
         * for the Content-Language request header.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.contentLanguage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentLength", {
        /**
         * The number of bytes present in the
         * response body.
         *
         * @readonly
         * @type {(number | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.contentLength;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentMD5", {
        /**
         * If the file has an MD5 hash and the
         * request is to read the full file, this response header is returned so that
         * the client can check for message content integrity. If the request is to
         * read a specified range and the 'x-ms-range-get-content-md5' is set to
         * true, then the request returns an MD5 hash for the range, as long as the
         * range size is less than or equal to 4 MB. If neither of these sets of
         * conditions is true, then no value is returned for the 'Content-MD5'
         * header.
         *
         * @readonly
         * @type {(Uint8Array | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.contentMD5;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentRange", {
        /**
         * Indicates the range of bytes returned if
         * the client requested a subset of the file by setting the Range request
         * header.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.contentRange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentType", {
        /**
         * The content type specified for the file.
         * The default content type is 'application/octet-stream'
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.contentType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copyCompletedOn", {
        /**
         * Conclusion time of the last attempted
         * Copy File operation where this file was the destination file. This value
         * can specify the time of a completed, aborted, or failed copy attempt.
         *
         * @readonly
         * @type {(Date | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.copyCompletedOn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copyId", {
        /**
         * String identifier for the last attempted Copy
         * File operation where this file was the destination file.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.copyId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copyProgress", {
        /**
         * Contains the number of bytes copied and
         * the total bytes in the source in the last attempted Copy File operation
         * where this file was the destination file. Can show between 0 and
         * Content-Length bytes copied.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.copyProgress;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copySource", {
        /**
         * URL up to 2KB in length that specifies the
         * source file used in the last attempted Copy File operation where this file
         * was the destination file.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.copySource;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copyStatus", {
        /**
         * State of the copy operation
         * identified by 'x-ms-copy-id'. Possible values include: 'pending',
         * 'success', 'aborted', 'failed'
         *
         * @readonly
         * @type {(CopyStatusType | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.copyStatus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copyStatusDescription", {
        /**
         * Only appears when
         * x-ms-copy-status is failed or pending. Describes cause of fatal or
         * non-fatal copy operation failure.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.copyStatusDescription;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "date", {
        /**
         * A UTC date/time value generated by the service that
         * indicates the time at which the response was initiated.
         *
         * @readonly
         * @type {(Date | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.date;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "etag", {
        /**
         * The ETag contains a value that you can use to
         * perform operations conditionally, in quotes.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.etag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "errorCode", {
        get: function () {
            return this.originalResponse.errorCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileContentMD5", {
        /**
         * If the file has a MD5 hash, and if
         * request contains range header (Range or x-ms-range), this response header
         * is returned with the value of the whole file's MD5 value. This value may
         * or may not be equal to the value returned in Content-MD5 header, with the
         * latter calculated from the requested range.
         *
         * @readonly
         * @type {(Uint8Array | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.fileContentMD5;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "isServerEncrypted", {
        /**
         * The value of this header is set to
         * true if the file data and application metadata are completely encrypted
         * using the specified algorithm. Otherwise, the value is set to false (when
         * the file is unencrypted, or if only parts of the file/application metadata
         * are encrypted).
         *
         * @readonly
         * @type {(boolean | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.isServerEncrypted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "lastModified", {
        /**
         * Returns the date and time the file was last
         * modified. Any operation that modifies the file or its properties updates
         * the last modified time.
         *
         * @readonly
         * @type {(Date | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.lastModified;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "metadata", {
        /**
         * A name-value pair
         * to associate with a file storage object.
         *
         * @readonly
         * @type {(Metadata | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.metadata;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "requestId", {
        /**
         * This header uniquely identifies the request
         * that was made and can be used for troubleshooting the request.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.requestId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "version", {
        /**
         * Indicates the version of the File service used
         * to execute the request.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileAttributes", {
        /**
         * Attributes set for the file.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.fileAttributes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileCreatedOn", {
        /**
         * Creation time for the file.
         *
         * @readonly
         * @type {(Date | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.fileCreatedOn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileLastWriteOn", {
        /**
         * Last write time for the file.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.fileLastWriteOn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileChangeOn", {
        /**
         * Change time for the file.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.fileChangeOn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "filePermissionKey", {
        /**
         * Key of the permission set for the file.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.filePermissionKey;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileId", {
        /**
         * The fileId of the file.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.fileId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileParentId", {
        /**
         * The parent fileId of the file.
         *
         * @readonly
         * @type {(string | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.fileParentId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "blobBody", {
        /**
         * The response body as a browser Blob.
         * Always undefined in node.js.
         *
         * @readonly
         * @type {(Promise<Blob> | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return this.originalResponse.blobBody;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "readableStreamBody", {
        /**
         * The response body as a node.js Readable stream.
         * Always undefined in the browser.
         *
         * It will automatically retry when internal read stream unexpected ends.
         *
         * @readonly
         * @type {(NodeJS.ReadableStream | undefined)}
         * @memberof FileDownloadResponse
         */
        get: function () {
            return coreHttp.isNode ? this.fileDownloadStream : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "_response", {
        get: function () {
            return this.originalResponse._response;
        },
        enumerable: true,
        configurable: true
    });
    return FileDownloadResponse;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * Generate a range string. For example:
 *
 * "bytes=255-" or "bytes=0-511"
 *
 * @export
 * @param {Range} range A range of byte positions.
 * @returns {string} The string representation for the byte range.
 */
function rangeToString(range) {
    if (range.offset < 0) {
        throw new RangeError("Range.offset cannot be smaller than 0.");
    }
    if (range.count && range.count <= 0) {
        throw new RangeError("Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.");
    }
    return range.count
        ? "bytes=" + range.offset + "-" + (range.offset + range.count - 1)
        : "bytes=" + range.offset + "-";
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * Credential is an abstract class for Azure Storage HTTP requests signing. This
 * class will host an credentialPolicyCreator factory which generates CredentialPolicy.
 *
 * @export
 * @abstract
 * @class Credential
 */
var Credential = /** @class */ (function () {
    function Credential() {
    }
    /**
     * Creates a RequestPolicy object.
     *
     * @param {RequestPolicy} _nextPolicy
     * @param {RequestPolicyOptions} _options
     * @returns {RequestPolicy}
     * @memberof Credential
     */
    Credential.prototype.create = function (
    // tslint:disable-next-line:variable-name
    _nextPolicy, 
    // tslint:disable-next-line:variable-name
    _options) {
        throw new Error("Method should be implemented in children classes.");
    };
    return Credential;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * States for Batch.
 *
 * @enum {number}
 */
var BatchStates;
(function (BatchStates) {
    BatchStates[BatchStates["Good"] = 0] = "Good";
    BatchStates[BatchStates["Error"] = 1] = "Error";
})(BatchStates || (BatchStates = {}));
/**
 * Batch provides basic parallel execution with concurrency limits.
 * Will stop execute left operations when one of the executed operation throws an error.
 * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.
 *
 * @export
 * @class Batch
 */
var Batch = /** @class */ (function () {
    /**
     * Creates an instance of Batch.
     * @param {number} [concurrency=5]
     * @memberof Batch
     */
    function Batch(concurrency) {
        if (concurrency === void 0) { concurrency = 5; }
        /**
         * Number of active operations under execution.
         *
         * @private
         * @type {number}
         * @memberof Batch
         */
        this.actives = 0;
        /**
         * Number of completed operations under execution.
         *
         * @private
         * @type {number}
         * @memberof Batch
         */
        this.completed = 0;
        /**
         * Offset of next operation to be executed.
         *
         * @private
         * @type {number}
         * @memberof Batch
         */
        this.offset = 0;
        /**
         * Operation array to be executed.
         *
         * @private
         * @type {Operation[]}
         * @memberof Batch
         */
        this.operations = [];
        /**
         * States of Batch. When an error happens, state will turn into error.
         * Batch will stop execute left operations.
         *
         * @private
         * @type {BatchStates}
         * @memberof Batch
         */
        this.state = BatchStates.Good;
        if (concurrency < 1) {
            throw new RangeError("concurrency must be larger than 0");
        }
        this.concurrency = concurrency;
        this.emitter = new events.EventEmitter();
    }
    /**
     * Add a operation into queue.
     *
     * @param {Operation} operation
     * @memberof Batch
     */
    Batch.prototype.addOperation = function (operation) {
        var _this = this;
        this.operations.push(function () { return tslib.__awaiter(_this, void 0, void 0, function () {
            var error_1;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        this.actives++;
                        return [4 /*yield*/, operation()];
                    case 1:
                        _a.sent();
                        this.actives--;
                        this.completed++;
                        this.parallelExecute();
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        this.emitter.emit("error", error_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    };
    /**
     * Start execute operations in the queue.
     *
     * @returns {Promise<void>}
     * @memberof Batch
     */
    Batch.prototype.do = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib.__generator(this, function (_a) {
                this.parallelExecute();
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.emitter.on("finish", resolve);
                        _this.emitter.on("error", function (error) {
                            _this.state = BatchStates.Error;
                            reject(error);
                        });
                    })];
            });
        });
    };
    /**
     * Get next operation to be executed. Return null when reaching ends.
     *
     * @private
     * @returns {(Operation | null)}
     * @memberof Batch
     */
    Batch.prototype.nextOperation = function () {
        if (this.offset < this.operations.length) {
            return this.operations[this.offset++];
        }
        return null;
    };
    /**
     * Start execute operations. One one the most important difference between
     * this method with do() is that do() wraps as an sync method.
     *
     * @private
     * @returns {void}
     * @memberof Batch
     */
    Batch.prototype.parallelExecute = function () {
        if (this.state === BatchStates.Error) {
            return;
        }
        if (this.completed >= this.operations.length) {
            this.emitter.emit("finish");
            return;
        }
        while (this.actives < this.concurrency) {
            var operation = this.nextOperation();
            if (operation) {
                operation();
            }
            else {
                return;
            }
        }
    };
    return Batch;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * This class accepts a Node.js Readable stream as input, and keeps reading data
 * from the stream into the internal buffer structure, until it reaches maxBuffers.
 * Every available buffer will try to trigger outgoingHandler.
 *
 * The internal buffer structure includes an incoming buffer array, and a outgoing
 * buffer array. The incoming buffer array includes the "empty" buffers can be filled
 * with new incoming data. The outgoing array includes the filled buffers to be
 * handled by outgoingHandler. Every above buffer size is defined by parameter bufferSize.
 *
 * NUM_OF_ALL_BUFFERS = BUFFERS_IN_INCOMING + BUFFERS_IN_OUTGOING + BUFFERS_UNDER_HANDLING
 *
 * NUM_OF_ALL_BUFFERS <= maxBuffers
 *
 * PERFORMANCE IMPROVEMENT TIPS:
 * 1. Input stream highWaterMark is better to set a same value with bufferSize
 *    parameter, which will avoid Buffer.concat() operations.
 * 2. Concurrency should set a smaller value than maxBuffers, which is helpful to
 *    reduce the possibility when a outgoing handler waits for the stream data.
 *    in this situation, outgoing handlers are blocked.
 *    Outgoing queue shouldn't be empty.
 * @export
 * @class BufferScheduler
 */
var BufferScheduler = /** @class */ (function () {
    /**
     * Creates an instance of BufferScheduler.
     *
     * @param {Readable} readable A Node.js Readable stream
     * @param {number} bufferSize Buffer size of every maintained buffer
     * @param {number} maxBuffers How many buffers can be allocated
     * @param {OutgoingHandler} outgoingHandler An async function scheduled to be
     *                                          triggered when a buffer fully filled
     *                                          with stream data
     * @param {number} concurrency Concurrency of executing outgoingHandlers (>0)
     * @param {string} [encoding] [Optional] Encoding of Readable stream when it's a string stream
     * @memberof BufferScheduler
     */
    function BufferScheduler(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
        /**
         * An internal event emitter.
         *
         * @private
         * @type {EventEmitter}
         * @memberof BufferScheduler
         */
        this.emitter = new events.EventEmitter();
        /**
         * An internal offset marker to track data offset in bytes of next outgoingHandler.
         *
         * @private
         * @type {number}
         * @memberof BufferScheduler
         */
        this.offset = 0;
        /**
         * An internal marker to track whether stream is end.
         *
         * @private
         * @type {boolean}
         * @memberof BufferScheduler
         */
        this.isStreamEnd = false;
        /**
         * An internal marker to track whether stream or outgoingHandler returns error.
         *
         * @private
         * @type {boolean}
         * @memberof BufferScheduler
         */
        this.isError = false;
        /**
         * How many handlers are executing.
         *
         * @private
         * @type {number}
         * @memberof BufferScheduler
         */
        this.executingOutgoingHandlers = 0;
        /**
         * How many buffers have been allocated.
         *
         * @private
         * @type {number}
         * @memberof BufferScheduler
         */
        this.numBuffers = 0;
        /**
         * Because this class doesn't know how much data every time stream pops, which
         * is defined by highWaterMarker of the stream. So BufferScheduler will cache
         * data received from the stream, when data in unresolvedDataArray exceeds the
         * blockSize defined, it will try to concat a blockSize of buffer, fill into available
         * buffers from incoming and push to outgoing array.
         *
         * @private
         * @type {Buffer[]}
         * @memberof BufferScheduler
         */
        this.unresolvedDataArray = [];
        /**
         * How much data consisted in unresolvedDataArray.
         *
         * @private
         * @type {number}
         * @memberof BufferScheduler
         */
        this.unresolvedLength = 0;
        /**
         * The array includes all the available buffers can be used to fill data from stream.
         *
         * @private
         * @type {Buffer[]}
         * @memberof BufferScheduler
         */
        this.incoming = [];
        /**
         * The array (queue) includes all the buffers filled from stream data.
         *
         * @private
         * @type {Buffer[]}
         * @memberof BufferScheduler
         */
        this.outgoing = [];
        if (bufferSize <= 0) {
            throw new RangeError("bufferSize must be larger than 0, current is " + bufferSize);
        }
        if (maxBuffers <= 0) {
            throw new RangeError("maxBuffers must be larger than 0, current is " + maxBuffers);
        }
        if (concurrency <= 0) {
            throw new RangeError("concurrency must be larger than 0, current is " + concurrency);
        }
        this.bufferSize = bufferSize;
        this.maxBuffers = maxBuffers;
        this.readable = readable;
        this.outgoingHandler = outgoingHandler;
        this.concurrency = concurrency;
        this.encoding = encoding;
    }
    /**
     * Start the scheduler, will return error when stream of any of the outgoingHandlers
     * returns error.
     *
     * @returns {Promise<void>}
     * @memberof BufferScheduler
     */
    BufferScheduler.prototype.do = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.readable.on("data", function (data) {
                            data = typeof data === "string" ? Buffer.from(data, _this.encoding) : data;
                            _this.appendUnresolvedData(data);
                            if (!_this.resolveData()) {
                                _this.readable.pause();
                            }
                        });
                        _this.readable.on("error", function (err) {
                            _this.emitter.emit("error", err);
                        });
                        _this.readable.on("end", function () {
                            _this.isStreamEnd = true;
                            _this.emitter.emit("checkEnd");
                        });
                        _this.emitter.on("error", function (err) {
                            _this.isError = true;
                            _this.readable.pause();
                            reject(err);
                        });
                        _this.emitter.on("checkEnd", function () {
                            if (_this.outgoing.length > 0) {
                                _this.triggerOutgoingHandlers();
                                return;
                            }
                            if (_this.isStreamEnd && _this.executingOutgoingHandlers === 0) {
                                if (_this.unresolvedLength > 0 && _this.unresolvedLength < _this.bufferSize) {
                                    _this.outgoingHandler(_this.shiftBufferFromUnresolvedDataArray(), _this.offset)
                                        .then(resolve)
                                        .catch(reject);
                                }
                                else if (_this.unresolvedLength >= _this.bufferSize) {
                                    return;
                                }
                                else {
                                    resolve();
                                }
                            }
                        });
                    })];
            });
        });
    };
    /**
     * Insert a new data into unresolved array.
     *
     * @private
     * @param {Buffer} data
     * @memberof BufferScheduler
     */
    BufferScheduler.prototype.appendUnresolvedData = function (data) {
        this.unresolvedDataArray.push(data);
        this.unresolvedLength += data.length;
    };
    /**
     * Try to shift a buffer with size in blockSize. The buffer returned may be less
     * than blockSize when data in unresolvedDataArray is less than bufferSize.
     *
     * @private
     * @returns {Buffer}
     * @memberof BufferScheduler
     */
    BufferScheduler.prototype.shiftBufferFromUnresolvedDataArray = function () {
        if (this.unresolvedLength >= this.bufferSize) {
            if (this.bufferSize === this.unresolvedDataArray[0].length) {
                this.unresolvedLength -= this.bufferSize;
                return this.unresolvedDataArray.shift();
            }
            // Lazy concat because Buffer.concat highly drops performance
            var merged = Buffer.concat(this.unresolvedDataArray, this.unresolvedLength);
            var buffer = merged.slice(0, this.bufferSize);
            merged = merged.slice(this.bufferSize);
            this.unresolvedDataArray = [merged];
            this.unresolvedLength -= buffer.length;
            return buffer;
        }
        else if (this.unresolvedLength > 0) {
            var merged = Buffer.concat(this.unresolvedDataArray, this.unresolvedLength);
            this.unresolvedDataArray = [];
            this.unresolvedLength = 0;
            return merged;
        }
        else {
            return Buffer.allocUnsafe(0);
        }
    };
    /**
     * Resolve data in unresolvedDataArray. For every buffer with size in blockSize
     * shifted, it will try to get (or allocate a buffer) from incoming, and fill it,
     * then push it into outgoing to be handled by outgoing handler.
     *
     * Return false when available buffers in incoming are not enough, else true.
     *
     * @private
     * @returns {boolean} Return false when buffers in incoming are not enough, else true.
     * @memberof BufferScheduler
     */
    BufferScheduler.prototype.resolveData = function () {
        while (this.unresolvedLength >= this.bufferSize) {
            var buffer = void 0;
            if (this.incoming.length > 0) {
                buffer = this.incoming.shift();
            }
            else {
                if (this.numBuffers < this.maxBuffers) {
                    buffer = Buffer.allocUnsafe(this.bufferSize);
                    this.numBuffers++;
                }
                else {
                    // No available buffer, wait for buffer returned
                    return false;
                }
            }
            buffer.fill(this.shiftBufferFromUnresolvedDataArray());
            this.outgoing.push(buffer);
            this.triggerOutgoingHandlers();
        }
        return true;
    };
    /**
     * Try to trigger a outgoing handler for every buffer in outgoing. Stop when
     * concurrency reaches.
     *
     * @private
     * @memberof BufferScheduler
     */
    BufferScheduler.prototype.triggerOutgoingHandlers = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var buffer;
            return tslib.__generator(this, function (_a) {
                do {
                    if (this.executingOutgoingHandlers >= this.concurrency) {
                        return [2 /*return*/];
                    }
                    buffer = this.outgoing.shift();
                    if (buffer) {
                        this.triggerOutgoingHandler(buffer);
                    }
                } while (buffer);
                return [2 /*return*/];
            });
        });
    };
    /**
     * Trigger a outgoing handler for a buffer shifted from outgoing.
     *
     * @private
     * @param {Buffer} buffer
     * @returns {Promise<any>}
     * @memberof BufferScheduler
     */
    BufferScheduler.prototype.triggerOutgoingHandler = function (buffer) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var bufferLength, err_1;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bufferLength = buffer.length;
                        this.executingOutgoingHandlers++;
                        this.offset += bufferLength;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.outgoingHandler(buffer, this.offset - bufferLength)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        this.emitter.emit("error", err_1);
                        return [2 /*return*/];
                    case 4:
                        this.executingOutgoingHandlers--;
                        this.reuseBuffer(buffer);
                        this.emitter.emit("checkEnd");
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Return buffer used by outgoing handler into incoming.
     *
     * @private
     * @param {Buffer} buffer
     * @memberof BufferScheduler
     */
    BufferScheduler.prototype.reuseBuffer = function (buffer) {
        this.incoming.push(buffer);
        if (!this.isError && this.resolveData() && !this.isStreamEnd) {
            this.readable.resume();
        }
    };
    return BufferScheduler;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Reads a readable stream into buffer. Fill the buffer from offset to end.
 *
 * @export
 * @param {NodeJS.ReadableStream} stream A Node.js Readable stream
 * @param {Buffer} buffer Buffer to be filled, length must >= offset
 * @param {number} offset From which position in the buffer to be filled, inclusive
 * @param {number} end To which position in the buffer to be filled, exclusive
 * @param {string} [encoding] Encoding of the Readable stream
 * @returns {Promise<void>}
 */
function streamToBuffer(stream, buffer, offset, end, encoding) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        var pos, count;
        return tslib.__generator(this, function (_a) {
            pos = 0;
            count = end - offset;
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    stream.on("readable", function () {
                        if (pos >= count) {
                            resolve();
                            return;
                        }
                        var chunk = stream.read();
                        if (!chunk) {
                            return;
                        }
                        if (typeof chunk === "string") {
                            chunk = Buffer.from(chunk, encoding);
                        }
                        // How much data needed in this chunk
                        var chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
                        buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
                        pos += chunkLength;
                    });
                    stream.on("end", function () {
                        if (pos < count) {
                            reject(new Error("Stream drains before getting enough data needed. Data read: " + pos + ", data need: " + count));
                        }
                        resolve();
                    });
                    stream.on("error", reject);
                })];
        });
    });
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Writes the content of a readstream to a local file. Returns a Promise which is completed after the file handle is closed.
 * If Promise is rejected, the reason will be set to the first error raised by either the
 * ReadableStream or the fs.WriteStream.
 *
 * @export
 * @param {NodeJS.ReadableStream} rs The read stream.
 * @param {string} file Destination file path.
 * @returns {Promise<void>}
 */
function readStreamToLocalFile(rs, file) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var ws = fs.createWriteStream(file);
                    // Set STREAM_DEBUG env var to log stream events while running tests
                    if (process.env.STREAM_DEBUG) {
                        rs.on("close", function () { return console.log("rs.close"); });
                        rs.on("data", function () { return console.log("rs.data"); });
                        rs.on("end", function () { return console.log("rs.end"); });
                        rs.on("error", function () { return console.log("rs.error"); });
                        ws.on("close", function () { return console.log("ws.close"); });
                        ws.on("drain", function () { return console.log("ws.drain"); });
                        ws.on("error", function () { return console.log("ws.error"); });
                        ws.on("finish", function () { return console.log("ws.finish"); });
                        ws.on("pipe", function () { return console.log("ws.pipe"); });
                        ws.on("unpipe", function () { return console.log("ws.unpipe"); });
                    }
                    var error;
                    rs.on("error", function (err) {
                        // First error wins
                        if (!error) {
                            error = err;
                        }
                        // When rs.error is raised, rs.end will never be raised automatically, so it must be raised manually
                        // to ensure ws.close is eventually raised.
                        rs.emit("end");
                    });
                    ws.on("error", function (err) {
                        // First error wins
                        if (!error) {
                            error = err;
                        }
                    });
                    ws.on("close", function () {
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve();
                        }
                    });
                    rs.pipe(ws);
                })];
        });
    });
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Promisified version of fs.stat().
 */
var fsStat = util.promisify(coreHttp.isNode ? fs.stat : function stat() { });

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Credential policy used to sign HTTP(S) requests before sending. This is an
 * abstract class.
 *
 * @export
 * @abstract
 * @class CredentialPolicy
 * @extends {BaseRequestPolicy}
 */
var CredentialPolicy = /** @class */ (function (_super) {
    tslib.__extends(CredentialPolicy, _super);
    function CredentialPolicy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Sends out request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof CredentialPolicy
     */
    CredentialPolicy.prototype.sendRequest = function (request) {
        return this._nextPolicy.sendRequest(this.signRequest(request));
    };
    /**
     * Child classes must implement this method with request signing. This method
     * will be executed in sendRequest().
     *
     * @protected
     * @abstract
     * @param {WebResource} request
     * @returns {WebResource}
     * @memberof CredentialPolicy
     */
    CredentialPolicy.prototype.signRequest = function (request) {
        // Child classes must override this method with request signing. This method
        // will be executed in sendRequest().
        return request;
    };
    return CredentialPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * AnonymousCredentialPolicy is used with HTTP(S) requests that read public resources
 * or for use with Shared Access Signatures (SAS).
 *
 * @export
 * @class AnonymousCredentialPolicy
 * @extends {CredentialPolicy}
 */
var AnonymousCredentialPolicy = /** @class */ (function (_super) {
    tslib.__extends(AnonymousCredentialPolicy, _super);
    /**
     * Creates an instance of AnonymousCredentialPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @memberof AnonymousCredentialPolicy
     */
    function AnonymousCredentialPolicy(nextPolicy, options) {
        return _super.call(this, nextPolicy, options) || this;
    }
    return AnonymousCredentialPolicy;
}(CredentialPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * AnonymousCredential provides a credentialPolicyCreator member used to create
 * AnonymousCredentialPolicy objects. AnonymousCredentialPolicy is used with
 * HTTP(S) requests that read public resources or for use with Shared Access
 * Signatures (SAS).
 *
 * @export
 * @class AnonymousCredential
 * @extends {Credential}
 */
var AnonymousCredential = /** @class */ (function (_super) {
    tslib.__extends(AnonymousCredential, _super);
    function AnonymousCredential() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates an AnonymousCredentialPolicy object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {AnonymousCredentialPolicy}
     * @memberof AnonymousCredential
     */
    AnonymousCredential.prototype.create = function (nextPolicy, options) {
        return new AnonymousCredentialPolicy(nextPolicy, options);
    };
    return AnonymousCredential;
}(Credential));

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @param name The name of the operation being performed.
 * @param tracingOptions The tracingOptions for the underlying http request.
 */
function createSpan(operationName, tracingOptions) {
    if (tracingOptions === void 0) { tracingOptions = {}; }
    var tracer = coreTracing.getTracer();
    var spanOptions = tslib.__assign(tslib.__assign({}, tracingOptions.spanOptions), { kind: coreTracing.SpanKind.CLIENT });
    var span = tracer.startSpan("Azure.Storage.File." + operationName, spanOptions);
    span.setAttribute("component", "storage");
    var newOptions = tracingOptions.spanOptions || {};
    if (span.isRecordingEvents()) {
        newOptions = tslib.__assign(tslib.__assign({}, tracingOptions), { parent: span });
    }
    return {
        span: span,
        spanOptions: newOptions
    };
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A ShareFileClient represents a URL to an Azure Storage file.
 *
 * @export
 * @class ShareFileClient
 */
var ShareFileClient = /** @class */ (function (_super) {
    tslib.__extends(ShareFileClient, _super);
    function ShareFileClient(url, credentialOrPipeline, options) {
        var _a;
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        (_a = getShareNameAndPathFromUrl(_this.url), _this._shareName = _a.shareName, _this._path = _a.filePathOrDirectoryPath);
        _this.context = new File(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareFileClient.prototype, "shareName", {
        get: function () {
            return this._shareName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShareFileClient.prototype, "path", {
        get: function () {
            return this._path;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new file or replaces a file. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.
     * @param {FileCreateOptions} [options] Options to File Create operation.
     * @returns {Promise<FileCreateResponse>} Response data for the File Create  operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.create = function (size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, attributes;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (size < 0 || size > FILE_MAX_SIZE_BYTES) {
                        throw new RangeError("File size must >= 0 and < " + FILE_MAX_SIZE_BYTES + ".");
                    }
                    options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
                    if (!options.fileAttributes) {
                        attributes = new FileSystemAttributes();
                        attributes.none = true;
                        options.fileAttributes = attributes;
                    }
                    options.fileHttpHeaders = options.fileHttpHeaders || {};
                    return [2 /*return*/, this.context.create(size, fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), {
                            abortSignal: options.abortSignal,
                            fileHttpHeaders: options.fileHttpHeaders,
                            metadata: options.metadata,
                            filePermission: options.filePermission,
                            filePermissionKey: options.filePermissionKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Reads or downloads a file from the system, including its metadata and properties.
     *
     * * In Node.js, data returns in a Readable stream `readableStreamBody`
     * * In browsers, data returns in a promise `blobBody`
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file
     *
     * @param {number} [offset] From which position of the file to download, >= 0
     * @param {number} [count] How much data to be downloaded, > 0. Will download to the end when undefined
     * @param {FileDownloadOptions} [options] Options to File Download operation.
     * @returns {Promise<FileDownloadResponse>} Response data for the File Download operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.download = function (offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, downloadFullFile, res_1, e_1;
            var _this = this;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-download", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (options.rangeGetContentMD5 && offset === 0 && count === undefined) {
                            throw new RangeError("rangeGetContentMD5 only works with partial data downloading");
                        }
                        downloadFullFile = offset === 0 && !count;
                        return [4 /*yield*/, this.context.download({
                                abortSignal: options.abortSignal,
                                onDownloadProgress: !coreHttp.isNode ? options.onProgress : undefined,
                                range: downloadFullFile ? undefined : rangeToString({ offset: offset, count: count }),
                                rangeGetContentMD5: options.rangeGetContentMD5,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        res_1 = _b.sent();
                        // Return browser response immediately
                        if (!coreHttp.isNode) {
                            return [2 /*return*/, res_1];
                        }
                        // We support retrying when download stream unexpected ends in Node.js runtime
                        // Following code shouldn't be bundled into browser build, however some
                        // bundlers may try to bundle following code and "FileReadResponse.ts".
                        // In this case, "FileDownloadResponse.browser.ts" will be used as a shim of "FileDownloadResponse.ts"
                        // The config is in package.json "browser" field
                        if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {
                            // TODO: Default value or make it a required parameter?
                            options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
                        }
                        if (res_1.contentLength === undefined) {
                            throw new RangeError("File download response doesn't contain valid content length header");
                        }
                        return [2 /*return*/, new FileDownloadResponse(res_1, function (start) { return tslib.__awaiter(_this, void 0, void 0, function () {
                                var updatedOptions;
                                return tslib.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            updatedOptions = {
                                                range: rangeToString({
                                                    count: offset + res_1.contentLength - start,
                                                    offset: start
                                                })
                                            };
                                            return [4 /*yield*/, this.context.download(tslib.__assign(tslib.__assign({ abortSignal: options.abortSignal }, updatedOptions), { spanOptions: spanOptions }))];
                                        case 1: 
                                        // Debug purpose only
                                        // console.log(
                                        //   `Read from internal stream, range: ${
                                        //     updatedOptions.range
                                        //   }, options: ${JSON.stringify(updatedOptions)}`
                                        // );
                                        return [2 /*return*/, (_a.sent()).readableStreamBody];
                                    }
                                });
                            }); }, offset, res_1.contentLength, {
                                abortSignal: options.abortSignal,
                                maxRetryRequests: options.maxRetryRequests,
                                onProgress: options.onProgress
                            })];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the file. It does not return the content of the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-properties
     *
     * @param {FileGetPropertiesOptions} [options] Options to File Get Properties operation.
     * @returns {Promise<FileGetPropertiesResponse>} Response data for the File Get Properties operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.getProperties({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets properties on the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param {FileProperties} [properties] File properties. For file HTTP headers(e.g. Content-Type),
     *                                       if no values are provided, existing HTTP headers will be removed.
     *                                       For other file properties(e.g. fileAttributes), if no values are provided,
     *                                       existing values will be preserved.
     * @returns {Promise<SetPropertiesResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.setProperties = function (properties) {
        if (properties === void 0) { properties = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-setProperties", properties.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
                    properties.fileHttpHeaders = properties.fileHttpHeaders || {};
                    return [2 /*return*/, this.context.setHTTPHeaders(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), {
                            abortSignal: properties.abortSignal,
                            fileHttpHeaders: properties.fileHttpHeaders,
                            filePermission: properties.filePermission,
                            filePermissionKey: properties.filePermissionKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Removes the file from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param {FileDeleteOptions} [options] Options to File Delete operation.
     * @returns {Promise<FileDeleteResponse>} Response data for the File Delete operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.deleteMethod({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets HTTP headers on the file.
     *
     * If no option provided, or no value provided for the file HTTP headers in the options,
     * these file HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param {fileHttpHeaders} [FileHttpHeaders] File HTTP headers like Content-Type.
     *                                             Provide undefined will remove existing HTTP headers.
     * @param {FileSetHttpHeadersOptions} [options] Options to File Set HTTP Headers operation.
     * @returns {Promise<FileSetHTTPHeadersResponse>} Response data for the File Set HTTP Headers operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.setHttpHeaders = function (fileHttpHeaders, options) {
        if (fileHttpHeaders === void 0) { fileHttpHeaders = {}; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-setHTTPHeaders", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved
                    options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
                    return [2 /*return*/, this.context.setHTTPHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), {
                            abortSignal: options.abortSignal,
                            fileHttpHeaders: fileHttpHeaders,
                            filePermission: options.filePermission,
                            filePermissionKey: options.filePermissionKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Resize file.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param {number} length Resizes a file to the specified size in bytes.
     *                        If the specified byte value is less than the current size of the file,
     *                        then all ranges above the specified byte value are cleared.
     * @param {FileResizeOptions} [options] Options to File Resize operation.
     * @returns {Promise<FileSetHTTPHeadersResponse>} Response data for the File Set HTTP Headers operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.resize = function (length, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-resize", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (length < 0) {
                        throw new RangeError("Size cannot less than 0 when resizing file.");
                    }
                    // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved.
                    options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
                    return [2 /*return*/, this.context.setHTTPHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), {
                            abortSignal: options.abortSignal,
                            fileContentLength: length,
                            filePermission: options.filePermission,
                            filePermissionKey: options.filePermissionKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Updates user-defined metadata for the specified file.
     *
     * If no metadata defined in the option parameter, the file
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-metadata
     *
     * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed
     * @param {FileSetMetadataOptions} [options] Options to File Set Metadata operation.
     * @returns {Promise<FileSetMetadataResponse>} Response data for the File Set Metadata operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.setMetadata = function (metadata, options) {
        if (metadata === void 0) { metadata = {}; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.setMetadata({
                            abortSignal: options.abortSignal,
                            metadata: metadata,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Upload a range of bytes to a file. Both the start and count of the
     * range must be specified. The range can be up to 4 MB in size.
     *
     * @param {HttpRequestBody} body Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param {number} offset Offset position of the destination Azure File to upload.
     * @param {number} contentLength Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param {FileUploadRangeOptions} [options={}] Options to File Upload Range operation.
     * @returns {Promise<FileUploadRangeResponse>} Response data for the File Upload Range operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.uploadRange = function (body, offset, contentLength, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-uploadRange", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (offset < 0) {
                        throw new RangeError("offset must be >= 0");
                    }
                    if (contentLength <= 0 || contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                        throw new RangeError("contentLength must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                    }
                    if (contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                        throw new RangeError("offset must be < " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                    }
                    return [2 /*return*/, this.context.uploadRange(rangeToString({ count: contentLength, offset: offset }), "update", contentLength, {
                            abortSignal: options.abortSignal,
                            contentMD5: options.contentMD5,
                            onUploadProgress: options.onProgress,
                            optionalbody: body,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Upload a range of bytes to a file where the contents are read from a another file's URL.
     * The range can be up to 4 MB in size.
     *
     * @param {string} sourceURL Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication.
     * @param {number} sourceOffset The source offset to copy from. Pass 0 to copy from the beginning of source file.
     * @param {number} destOffset Offset of destination file.
     * @param {number} count Number of bytes to be uploaded from source file.
     * @param {FileUploadRangeFromURLOptions} [options={}] Options to configure File - Upload Range from URL operation.
     * @returns {Promise<FileUploadRangeFromURLResponse>}
     * @memberof FileURL
     */
    ShareFileClient.prototype.uploadRangeFromURL = function (sourceURL, sourceOffset, destOffset, count, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-uploadRangeFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (sourceOffset < 0 || destOffset < 0) {
                        throw new RangeError("sourceOffset and destOffset must be >= 0");
                    }
                    if (count <= 0 || count > FILE_RANGE_MAX_SIZE_BYTES) {
                        throw new RangeError("count must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                    }
                    return [2 /*return*/, this.context.uploadRangeFromURL(rangeToString({ offset: destOffset, count: count }), sourceURL, rangeToString({ offset: sourceOffset, count: count }), 0, tslib.__assign(tslib.__assign({ abortSignal: options.abortSignal, sourceModifiedAccessConditions: options.sourceConditions }, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Clears the specified range and
     * releases the space used in storage for that range.
     *
     * @param {number} offset
     * @param {number} contentLength
     * @param {FileClearRangeOptions} [options] Options to File Clear Range operation.
     * @returns {Promise<FileUploadRangeResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.clearRange = function (offset, contentLength, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-clearRange", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (offset < 0 || contentLength <= 0) {
                        throw new RangeError("offset must >= 0 and contentLength must be > 0");
                    }
                    return [2 /*return*/, this.context.uploadRange(rangeToString({ count: contentLength, offset: offset }), "clear", 0, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Returns the list of valid ranges for a file.
     *
     * @param {FileGetRangeListOptions} [options] Options to File Get range List operation.
     * @returns {Promise<FileGetRangeListResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.getRangeList = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, originalResponse, e_2;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-getRangeList", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getRangeList({
                                abortSignal: options.abortSignal,
                                range: options.range ? rangeToString(options.range) : undefined,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        originalResponse = _b.sent();
                        return [2 /*return*/, {
                                _response: originalResponse._response,
                                date: originalResponse.date,
                                etag: originalResponse.etag,
                                errorCode: originalResponse.errorCode,
                                fileContentLength: originalResponse.fileContentLength,
                                lastModified: originalResponse.lastModified,
                                rangeList: originalResponse.filter(function () {
                                    return true;
                                }),
                                requestId: originalResponse.requestId,
                                version: originalResponse.version
                            }];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Copies a blob or file to a destination file within the storage account.
     *
     * @param {string} copySource Specifies the URL of the source file or blob, up to 2 KB in length.
     * To copy a file to another file within the same storage account, you may use Shared Key to
     * authenticate the source file. If you are copying a file from another storage account, or if you
     * are copying a blob from the same storage account or another storage account, then you must
     * authenticate the source file or blob using a shared access signature. If the source is a public
     * blob, no authentication is required to perform the copy operation. A file in a share snapshot
     * can also be specified as a copy source.
     * @param {FileStartCopyOptions} [options] Options to File Start Copy operation.
     * @returns {Promise<FileStartCopyResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.startCopyFromURL = function (copySource, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-startCopyFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.startCopy(copySource, {
                            abortSignal: options.abortSignal,
                            metadata: options.metadata,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
     * metadata.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-file
     *
     * @param {string} copyId Id of the Copy File operation to abort.
     * @param {FileAbortCopyFromURLOptions} [options] Options to File Abort Copy From URL operation.
     * @returns {Promise<FileAbortCopyResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.abortCopyFromURL = function (copyId, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-abortCopyFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.abortCopy(copyId, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    // High Level functions
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to an Azure File.
     *
     * @param {Blob | ArrayBuffer | ArrayBufferView} browserData Blob, File, ArrayBuffer or ArrayBufferView
     * @param {FileParallelUploadOptions} [options]
     * @returns {Promise<void>}
     */
    ShareFileClient.prototype.uploadBrowserData = function (browserData, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, browserBlob_1;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-uploadBrowserData", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    browserBlob_1 = new Blob([browserData]);
                    return [2 /*return*/, this.uploadSeekableBlob(function (offset, size) {
                            return browserBlob_1.slice(offset, offset + size);
                        }, browserBlob_1.size, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob object to an Azure file. Requires a blobFactory as the data source,
     * which need to return a Blob object with the offset and size provided.
     *
     * @param {(offset: number, size: number) => Blob} blobFactory
     * @param {number} size
     * @param {FileParallelUploadOptions} [options]
     * @returns {Promise<void>}
     */
    ShareFileClient.prototype.uploadSeekableBlob = function (blobFactory, size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, numBlocks_1, transferProgress_1, batch, _loop_1, i, e_3;
            var _this = this;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-UploadSeekableBlob", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (!options.rangeSize) {
                            options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
                        }
                        if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("options.rangeSize must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES);
                        }
                        if (!options.fileHttpHeaders) {
                            options.fileHttpHeaders = {};
                        }
                        if (!options.concurrency) {
                            options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
                        }
                        if (options.concurrency < 0) {
                            throw new RangeError("options.concurrency cannot less than 0.");
                        }
                        // Create the file
                        return [4 /*yield*/, this.create(size, {
                                abortSignal: options.abortSignal,
                                fileHttpHeaders: options.fileHttpHeaders,
                                metadata: options.metadata,
                                tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                            })];
                    case 2:
                        // Create the file
                        _b.sent();
                        numBlocks_1 = Math.floor((size - 1) / options.rangeSize) + 1;
                        transferProgress_1 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_1 = function (i) {
                            batch.addOperation(function () { return tslib.__awaiter(_this, void 0, void 0, function () {
                                var start, end, contentLength;
                                return tslib.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            start = options.rangeSize * i;
                                            end = i === numBlocks_1 - 1 ? size : start + options.rangeSize;
                                            contentLength = end - start;
                                            return [4 /*yield*/, this.uploadRange(blobFactory(start, contentLength), start, contentLength, {
                                                    abortSignal: options.abortSignal,
                                                    tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                                })];
                                        case 1:
                                            _a.sent();
                                            // Update progress after block is successfully uploaded to server, in case of block trying
                                            // TODO: Hook with convenience layer progress event in finer level
                                            transferProgress_1 += contentLength;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_1 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (i = 0; i < numBlocks_1; i++) {
                            _loop_1(i);
                        }
                        return [2 /*return*/, batch.do()];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Uploads a local file to an Azure file.
     *
     * @param {string} filePath Full path of local file
     * @param {ShareFileClient} fileClient ShareFileClient
     * @param {FileParallelUploadOptions} [options]
     * @returns {(Promise<void>)}
     */
    ShareFileClient.prototype.uploadFile = function (filePath, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, size, e_4;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, fsStat(filePath)];
                    case 2:
                        size = (_b.sent()).size;
                        return [2 /*return*/, this.uploadResetableStream(function (offset, count) {
                                return fs.createReadStream(filePath, {
                                    autoClose: true,
                                    end: count ? offset + count - 1 : Infinity,
                                    start: offset
                                });
                            }, size, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Accepts a Node.js Readable stream factory, and uploads in blocks to an Azure File.
     * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset
     * is the offset in the Azure file to be uploaded.
     *
     * @export
     * @param {(offset: number) => NodeJS.ReadableStream} streamFactory Returns a Node.js Readable stream starting
     *                                                                  from the offset defined
     * @param {number} size Size of the Azure file
     * @param {ShareFileClient} fileClient ShareFileClient
     * @param {FileParallelUploadOptions} [options]
     * @returns {(Promise<void>)}
     */
    ShareFileClient.prototype.uploadResetableStream = function (streamFactory, size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, numBlocks_2, transferProgress_2, batch, _loop_2, i, e_5;
            var _this = this;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadResetableStream", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (!options.rangeSize) {
                            options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
                        }
                        if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("options.rangeSize must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES);
                        }
                        if (!options.fileHttpHeaders) {
                            options.fileHttpHeaders = {};
                        }
                        if (!options.concurrency) {
                            options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
                        }
                        if (options.concurrency < 0) {
                            throw new RangeError("options.concurrency cannot less than 0.");
                        }
                        // Create the file
                        return [4 /*yield*/, this.create(size, {
                                abortSignal: options.abortSignal,
                                fileHttpHeaders: options.fileHttpHeaders,
                                metadata: options.metadata,
                                tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                            })];
                    case 2:
                        // Create the file
                        _b.sent();
                        numBlocks_2 = Math.floor((size - 1) / options.rangeSize) + 1;
                        transferProgress_2 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_2 = function (i) {
                            batch.addOperation(function () { return tslib.__awaiter(_this, void 0, void 0, function () {
                                var start, end, contentLength;
                                return tslib.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            start = options.rangeSize * i;
                                            end = i === numBlocks_2 - 1 ? size : start + options.rangeSize;
                                            contentLength = end - start;
                                            return [4 /*yield*/, this.uploadRange(function () { return streamFactory(start, contentLength); }, start, contentLength, {
                                                    abortSignal: options.abortSignal,
                                                    tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                                })];
                                        case 1:
                                            _a.sent();
                                            // Update progress after block is successfully uploaded to server, in case of block trying
                                            transferProgress_2 += contentLength;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_2 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (i = 0; i < numBlocks_2; i++) {
                            _loop_2(i);
                        }
                        return [2 /*return*/, batch.do()];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure file in parallel to a buffer.
     * Offset and count are optional, pass 0 for both to download the entire file.
     *
     * @param {Buffer} buffer Buffer to be fill, must have length larger than count
     * @param {number} offset From which position of the Azure File to download
     * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined
     * @param {FileDownloadToBufferOptions} [options]
     * @returns {Promise<void>}
     */
    ShareFileClient.prototype.downloadToBuffer = function (buffer, offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, transferProgress_3, batch, _loop_3, off, e_6;
            var _this = this;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-downloadToBuffer", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        if (!options.rangeSize) {
                            options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
                        }
                        if (options.rangeSize < 0) {
                            throw new RangeError("rangeSize option must be > 0");
                        }
                        if (offset < 0) {
                            throw new RangeError("offset option must be >= 0");
                        }
                        if (count && count <= 0) {
                            throw new RangeError("count option must be > 0");
                        }
                        if (!options.concurrency) {
                            options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
                        }
                        if (options.concurrency < 0) {
                            throw new RangeError("options.concurrency cannot less than 0.");
                        }
                        if (!!count) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                            })];
                    case 2:
                        response = _b.sent();
                        count = response.contentLength - offset;
                        if (count < 0) {
                            throw new RangeError("offset " + offset + " shouldn't be larger than file size " + response.contentLength);
                        }
                        _b.label = 3;
                    case 3:
                        if (buffer.length < count) {
                            throw new RangeError("The buffer's size should be equal to or larger than the request count of bytes: " + count);
                        }
                        transferProgress_3 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_3 = function (off) {
                            batch.addOperation(function () { return tslib.__awaiter(_this, void 0, void 0, function () {
                                var chunkEnd, response, stream;
                                return tslib.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            chunkEnd = offset + count;
                                            if (off + options.rangeSize < chunkEnd) {
                                                chunkEnd = off + options.rangeSize;
                                            }
                                            return [4 /*yield*/, this.download(off, chunkEnd - off, {
                                                    abortSignal: options.abortSignal,
                                                    maxRetryRequests: options.maxRetryRequestsPerRange,
                                                    tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                                })];
                                        case 1:
                                            response = _a.sent();
                                            stream = response.readableStreamBody;
                                            return [4 /*yield*/, streamToBuffer(stream, buffer, off - offset, chunkEnd - offset)];
                                        case 2:
                                            _a.sent();
                                            // Update progress after block is downloaded, in case of block trying
                                            // Could provide finer grained progress updating inside HTTP requests,
                                            // only if convenience layer download try is enabled
                                            transferProgress_3 += chunkEnd - off;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_3 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (off = offset; off < offset + count; off = off + options.rangeSize) {
                            _loop_3(off);
                        }
                        return [4 /*yield*/, batch.do()];
                    case 4:
                        _b.sent();
                        return [3 /*break*/, 7];
                    case 5:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 6:
                        span.end();
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Uploads a Node.js Readable stream into an Azure file.
     * This method will try to create an Azure, then starts uploading chunk by chunk.
     * Size of chunk is defined by `bufferSize` parameter.
     * Please make sure potential size of stream doesn't exceed file size.
     *
     * PERFORMANCE IMPROVEMENT TIPS:
     * * Input stream highWaterMark is better to set a same value with bufferSize
     *   parameter, which will avoid Buffer.concat() operations.
     *
     * @param {Readable} stream Node.js Readable stream. Must be less or equal than file size.
     * @param {number} size Size of file to be created. Maxium size allowed is 1TB.
     *                      If this value is larger than stream size, there will be empty bytes in file tail.
     * @param {number} bufferSize Size of every buffer allocated in bytes, also the chunk/range size during
     *                            the uploaded file. Size must be > 0 and <= 4 * 1024 * 1024 (4MB)
     * @param {number} maxBuffers Max buffers will allocate during uploading, positive correlation
     *                            with max uploading concurrency
     * @param {FileUploadStreamOptions} [options]
     * @returns {Promise<void>}
     */
    ShareFileClient.prototype.uploadStream = function (stream, size, bufferSize, maxBuffers, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, transferProgress_4, scheduler, e_7;
            var _this = this;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadStream", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (!options.fileHttpHeaders) {
                            options.fileHttpHeaders = {};
                        }
                        if (bufferSize <= 0 || bufferSize > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("bufferSize must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES);
                        }
                        if (maxBuffers < 0) {
                            throw new RangeError("maxBuffers must be > 0.");
                        }
                        // Create the file
                        return [4 /*yield*/, this.create(size, {
                                abortSignal: options.abortSignal,
                                fileHttpHeaders: options.fileHttpHeaders,
                                metadata: options.metadata,
                                tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                            })];
                    case 2:
                        // Create the file
                        _b.sent();
                        transferProgress_4 = 0;
                        scheduler = new BufferScheduler(stream, bufferSize, maxBuffers, function (buffer, offset) { return tslib.__awaiter(_this, void 0, void 0, function () {
                            return tslib.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (transferProgress_4 + buffer.length > size) {
                                            throw new RangeError("Stream size is larger than file size " + size + " bytes, uploading failed. " +
                                                "Please make sure stream length is less or equal than file size.");
                                        }
                                        return [4 /*yield*/, this.uploadRange(buffer, offset, buffer.length, {
                                                abortSignal: options.abortSignal,
                                                tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                            })];
                                    case 1:
                                        _a.sent();
                                        // Update progress after block is successfully uploaded to server, in case of block trying
                                        transferProgress_4 += buffer.length;
                                        if (options.onProgress) {
                                            options.onProgress({ loadedBytes: transferProgress_4 });
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        }); }, 
                        // Concurrency should set a smaller value than maxBuffers, which is helpful to
                        // reduce the possibility when a outgoing handler waits for stream data, in
                        // this situation, outgoing handlers are blocked.
                        // Outgoing queue shouldn't be empty.
                        Math.ceil((maxBuffers / 4) * 3));
                        return [2 /*return*/, scheduler.do()];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure Blob to a local file.
     * Fails if the the given file path already exits.
     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
     *
     * @param {string} filePath
     * @param {number} [offset] From which position of the block blob to download.
     * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined.
     * @param {BlobDownloadOptions} [options] Options to Blob download options.
     * @returns {Promise<FileDownloadResponse>} The response data for blob download operation,
     *                                                 but with readableStreamBody set to undefined since its
     *                                                 content is already read and written into a local file
     *                                                 at the specified path.
     * @memberof BlobClient
     */
    ShareFileClient.prototype.downloadToFile = function (filePath, offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, e_8;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-downloadToFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        return [4 /*yield*/, this.download(offset, count, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        response = _b.sent();
                        if (!response.readableStreamBody) return [3 /*break*/, 4];
                        return [4 /*yield*/, readStreamToLocalFile(response.readableStreamBody, filePath)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        // The stream is no longer accessible so setting it to undefined.
                        response.fileDownloadStream = undefined;
                        return [2 /*return*/, response];
                    case 5:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_8.message
                        });
                        throw e_8;
                    case 6:
                        span.end();
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Lists handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {FileListHandlesSegmentOptions} [options={}]
     * @returns {Promise<FileListHandlesResponse>}
     * @memberof FileURL
     */
    ShareFileClient.prototype.listHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, e_9;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-listHandlesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.listHandles(tslib.__assign(tslib.__assign({ abortSignal: options.abortSignal, marker: marker }, options), { spanOptions: spanOptions }))];
                    case 2:
                        response = _b.sent();
                        // TODO: Protocol layer issue that when handle list is in returned XML
                        // response.handleList is an empty string
                        if (response.handleList === "") {
                            response.handleList = undefined;
                        }
                        return [2 /*return*/, response];
                    case 3:
                        e_9 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_9.message
                        });
                        throw e_9;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for FileListHandlesResponse
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {FileListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<FileListHandlesResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.iterateHandleSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function iterateHandleSegments_1() {
            var listHandlesResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!marker || marker === undefined)) return [3 /*break*/, 6];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(this.listHandlesSegment(marker, options))];
                    case 2:
                        listHandlesResponse = _a.sent();
                        marker = listHandlesResponse.continuationToken;
                        return [4 /*yield*/, tslib.__await(listHandlesResponse)];
                    case 3: return [4 /*yield*/, _a.sent()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @private
     * @param {FileListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<HandleItem>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.listHandleItems = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listHandleItems_1() {
            var marker, _a, _b, listHandlesResponse, _i, _c, handle, e_10_1;
            var e_10, _d;
            return tslib.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _e.trys.push([0, 9, 10, 15]);
                        _a = tslib.__asyncValues(this.iterateHandleSegments(marker, options));
                        _e.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 2:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 8];
                        listHandlesResponse = _b.value;
                        if (!listHandlesResponse.handleList) return [3 /*break*/, 7];
                        _i = 0, _c = listHandlesResponse.handleList;
                        _e.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3 /*break*/, 7];
                        handle = _c[_i];
                        return [4 /*yield*/, tslib.__await(handle)];
                    case 4: return [4 /*yield*/, _e.sent()];
                    case 5:
                        _e.sent();
                        _e.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 1];
                    case 8: return [3 /*break*/, 15];
                    case 9:
                        e_10_1 = _e.sent();
                        e_10 = { error: e_10_1 };
                        return [3 /*break*/, 15];
                    case 10:
                        _e.trys.push([10, , 13, 14]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 12];
                        return [4 /*yield*/, tslib.__await(_d.call(_a))];
                    case 11:
                        _e.sent();
                        _e.label = 12;
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        if (e_10) throw e_10.error;
                        return [7 /*endfinally*/];
                    case 14: return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * @param {FileListHandlesOptions} [options] Options to list handles operation.
     * @memberof ShareFileClient
     * @returns {PagedAsyncIterableIterator<HandleItem, FileListHandlesResponse>}
     * An asyncIterableIterator that supports paging.
     */
    ShareFileClient.prototype.listHandles = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        // an AsyncIterableIterator to iterate over handles
        var iter = this.listHandleItems(options);
        return _a = {
                /**
                 * @member {Promise} [next] The next method, part of the iteration protocol
                 */
                next: function () {
                    return tslib.__awaiter(this, void 0, void 0, function () {
                        return tslib.__generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateHandleSegments(settings.continuationToken, tslib.__assign({ maxPageSize: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param {FileForceCloseHandlesOptions} [options] Options to force close handles operation.
     * @returns {Promise<FileForceCloseHandlesResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.forceCloseHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-forceCloseHandlesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    marker = marker === "" ? undefined : marker;
                    return [2 /*return*/, this.context.forceCloseHandles("*", {
                            abortSignal: options.abortSignal,
                            marker: marker,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {FileForceCloseHandlesOptions} [options] Options to force close handles operation.
     * @returns {Promise<number>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.forceCloseAllHandles = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, handlesClosed, marker, response, e_11;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-forceCloseAllHandles", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        handlesClosed = 0;
                        marker = "";
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.forceCloseHandlesSegment(marker, { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) })];
                    case 3:
                        response = _b.sent();
                        marker = response.marker;
                        response.numberOfHandlesClosed && (handlesClosed += response.numberOfHandlesClosed);
                        _b.label = 4;
                    case 4:
                        if (marker) return [3 /*break*/, 2];
                        _b.label = 5;
                    case 5: return [2 /*return*/, handlesClosed];
                    case 6:
                        e_11 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_11.message
                        });
                        throw e_11;
                    case 7:
                        span.end();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close a specific handle for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {string} handleId Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseAllHandles() to close all handles.
     * @param {FileForceCloseHandlesOptions} [options] Options to force close handles operation.
     * @returns {Promise<FileForceCloseHandlesResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.forceCloseHandle = function (handleId, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-forceCloseHandle", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (handleId === "*") {
                        throw new RangeError("Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.");
                    }
                    return [2 /*return*/, this.context.forceCloseHandles(handleId, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    return ShareFileClient;
}(StorageClient));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A ShareDirectoryClient represents a URL to the Azure Storage directory allowing you to manipulate its files and directories.
 *
 * @export
 * @class ShareDirectoryClient
 */
var ShareDirectoryClient = /** @class */ (function (_super) {
    tslib.__extends(ShareDirectoryClient, _super);
    function ShareDirectoryClient(url, credentialOrPipeline, options) {
        var _a;
        if (options === void 0) { options = {}; }
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        (_a = getShareNameAndPathFromUrl(_this.url), _this._shareName = _a.shareName, _this._path = _a.filePathOrDirectoryPath);
        _this.context = new Directory(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareDirectoryClient.prototype, "shareName", {
        get: function () {
            return this._shareName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShareDirectoryClient.prototype, "path", {
        get: function () {
            return this._path;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new directory under the specified share or parent directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.
     * @returns {Promise<DirectoryCreateResponse>} Response data for the Directory  operation.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, attributes;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareDirectoryClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (!options.fileAttributes) {
                        options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
                        attributes = new FileSystemAttributes();
                        attributes.directory = true;
                        options.fileAttributes = attributes;
                    }
                    return [2 /*return*/, this.context.create(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), {
                            abortSignal: options.abortSignal,
                            metadata: options.metadata,
                            filePermission: options.filePermission,
                            filePermissionKey: options.filePermissionKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets properties on the directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-properties
     *
     * @param {properties} [DirectoryProperties] Directory properties. If no values are provided,
     *                                            existing values will be preserved.
     * @returns {Promise<DirectorySetPropertiesResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.setProperties = function (properties) {
        if (properties === void 0) { properties = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareDirectoryClient-setProperties", properties.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
                    return [2 /*return*/, this.context.setProperties(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), {
                            abortSignal: properties.abortSignal,
                            filePermission: properties.filePermission,
                            filePermissionKey: properties.filePermissionKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Creates a ShareDirectoryClient object for a sub directory.
     *
     * @param subDirectoryName A subdirectory name
     * @returns {ShareDirectoryClient} The ShareDirectoryClient object for the given subdirectory name.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.getDirectoryClient = function (subDirectoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(subDirectoryName)), this.pipeline);
    };
    /**
     * Creates a new subdirectory under this directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param {string} directoryName
     * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.
     * @returns {Promise<{ directoryClient: ShareDirectoryClient; directoryCreateResponse: DirectoryCreateResponse; }>} Directory create response data and the corresponding DirectoryClient instance.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.createSubdirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, directoryCreateResponse, e_1;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-createSubdirectory", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.create(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        directoryCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                directoryClient: directoryClient,
                                directoryCreateResponse: directoryCreateResponse
                            }];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty sub directory under this directory.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param {string} directoryName
     * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.
     * @returns {DirectoryDeleteResponse} Directory deletion response data.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.deleteSubdirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, e_2;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-deleteSubdirectory", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.delete(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new file or replaces a file under this directory. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param {string} fileName
     * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.
     * @param {FileCreateOptions} [options] Options to File Create operation.
     * @returns {Promise<{ fileClient: ShareFileClient, fileCreateResponse: FileCreateResponse }>} File creation response data and the corresponding file client.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.createFile = function (fileName, size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, fileClient, fileCreateResponse, e_3;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-createFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        fileClient = this.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.create(size, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        fileCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                fileClient: fileClient,
                                fileCreateResponse: fileCreateResponse
                            }];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified file under this directory from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param {string} fileName Name of the file to delete
     * @param {FileDeleteOptions} [options] Options to File Delete operation.
     * @returns {Promise<FileDeleteResponse>} File deletion response data.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.deleteFile = function (fileName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, fileClient, e_4;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-deleteFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        fileClient = this.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.delete(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a ShareFileClient object.
     *
     * @param {string} fileName A file name.
     * @returns {ShareFileClient} A new ShareFileClient object for the given file name.
     * @memberof ShareFileClient
     */
    ShareDirectoryClient.prototype.getFileClient = function (fileName) {
        return new ShareFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);
    };
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-directory-properties
     *
     * @param {DirectoryGetPropertiesOptions} [options] Options to Directory Get Properties operation.
     * @returns {Promise<DirectoryGetPropertiesResponse>} Response data for the Directory Get Properties operation.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareDirectoryClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.getProperties({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.
     * @returns {Promise<DirectoryDeleteResponse>} Response data for the Directory Delete operation.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareDirectoryClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.deleteMethod({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Updates user defined metadata for the specified directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-metadata
     *
     * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed
     * @param {DirectorySetMetadataOptions} [options] Options to Directory Set Metadata operation.
     * @returns {Promise<DirectorySetMetadataResponse>} Response data for the Directory Set Metadata operation.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareDirectoryClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.setMetadata({
                            abortSignal: options.abortSignal,
                            metadata: metadata,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for DirectoryListFilesAndDirectoriesSegmentResponses
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of
     *                          the list of files and directories to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all files and directories remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to list files and directories operation.
     * @returns {AsyncIterableIterator<DirectoryListFilesAndDirectoriesSegmentResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.iterateFilesAndDirectoriesSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function iterateFilesAndDirectoriesSegments_1() {
            var listFilesAndDirectoriesResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tslib.__await(this.listFilesAndDirectoriesSegment(marker, options))];
                    case 1:
                        listFilesAndDirectoriesResponse = _a.sent();
                        marker = listFilesAndDirectoriesResponse.continuationToken;
                        return [4 /*yield*/, tslib.__await(listFilesAndDirectoriesResponse)];
                    case 2: return [4 /*yield*/, tslib.__await.apply(void 0, [_a.sent()])];
                    case 3: return [4 /*yield*/, _a.sent()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (marker) return [3 /*break*/, 0];
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for file and directory items
     *
     * @private
     * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to list files and directories operation.
     * @returns {AsyncIterableIterator<{ kind: "file" } & FileItem | { kind: "directory" } & DirectoryItem>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.listFilesAndDirectoriesItems = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listFilesAndDirectoriesItems_1() {
            var marker, _a, _b, listFilesAndDirectoriesResponse, _i, _c, file, _d, _e, directory, e_5_1;
            var e_5, _f;
            return tslib.__generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        _g.trys.push([0, 14, 15, 20]);
                        _a = tslib.__asyncValues(this.iterateFilesAndDirectoriesSegments(marker, options));
                        _g.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 2:
                        if (!(_b = _g.sent(), !_b.done)) return [3 /*break*/, 13];
                        listFilesAndDirectoriesResponse = _b.value;
                        _i = 0, _c = listFilesAndDirectoriesResponse.segment.fileItems;
                        _g.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3 /*break*/, 7];
                        file = _c[_i];
                        return [4 /*yield*/, tslib.__await(tslib.__assign({ kind: "file" }, file))];
                    case 4: return [4 /*yield*/, _g.sent()];
                    case 5:
                        _g.sent();
                        _g.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7:
                        _d = 0, _e = listFilesAndDirectoriesResponse.segment.directoryItems;
                        _g.label = 8;
                    case 8:
                        if (!(_d < _e.length)) return [3 /*break*/, 12];
                        directory = _e[_d];
                        return [4 /*yield*/, tslib.__await(tslib.__assign({ kind: "directory" }, directory))];
                    case 9: return [4 /*yield*/, _g.sent()];
                    case 10:
                        _g.sent();
                        _g.label = 11;
                    case 11:
                        _d++;
                        return [3 /*break*/, 8];
                    case 12: return [3 /*break*/, 1];
                    case 13: return [3 /*break*/, 20];
                    case 14:
                        e_5_1 = _g.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 20];
                    case 15:
                        _g.trys.push([15, , 18, 19]);
                        if (!(_b && !_b.done && (_f = _a.return))) return [3 /*break*/, 17];
                        return [4 /*yield*/, tslib.__await(_f.call(_a))];
                    case 16:
                        _g.sent();
                        _g.label = 17;
                    case 17: return [3 /*break*/, 19];
                    case 18:
                        if (e_5) throw e_5.error;
                        return [7 /*endfinally*/];
                    case 19: return [7 /*endfinally*/];
                    case 20: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the files and directories
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the files and directories in pages.
     *
     * @example
     * ```js
     *   let i = 1;
     *   for await (const entity of directoryClient.listFilesAndDirectories()) {
     *     if (entity.kind === "directory") {
     *       console.log(`${i++} - directory\t: ${entity.name}`);
     *     } else {
     *       console.log(`${i++} - file\t: ${entity.name}`);
     *     }
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Generator syntax .next()
     *   let i = 1;
     *   let iter = await directoryClient.listFilesAndDirectories();
     *   let entity = await iter.next();
     *   while (!entity.done) {
     *     if (entity.value.kind === "directory") {
     *       console.log(`${i++} - directory\t: ${entity.value.name}`);
     *     } else {
     *       console.log(`${i++} - file\t: ${entity.value.name}`);
     *     }
     *     entity = await iter.next();
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Example for .byPage()
     *   // passing optional maxPageSize in the page settings
     *   let i = 1;
     *   for await (const response of directoryClient
     *     .listFilesAndDirectories()
     *     .byPage({ maxPageSize: 20 })) {
     *     for (const fileItem of response.segment.fileItems) {
     *       console.log(`${i++} - file\t: ${fileItem.name}`);
     *     }
     *     for (const dirItem of response.segment.directoryItems) {
     *       console.log(`${i++} - directory\t: ${dirItem.name}`);
     *     }
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Passing marker as an argument (similar to the previous example)
     *   let i = 1;
     *   let iterator = directoryClient.listFilesAndDirectories().byPage({ maxPageSize: 3 });
     *   let response = (await iterator.next()).value;
     *   // Prints 3 file and directory names
     *   for (const fileItem of response.segment.fileItems) {
     *     console.log(`${i++} - file\t: ${fileItem.name}`);
     *   }
     *   for (const dirItem of response.segment.directoryItems) {
     *     console.log(`${i++} - directory\t: ${dirItem.name}`);
     *   }
     *   // Gets next marker
     *   let dirMarker = response.continuationToken;
     *   // Passing next marker as continuationToken
     *   iterator = directoryClient
     *     .listFilesAndDirectories()
     *     .byPage({ continuationToken: dirMarker, maxPageSize: 4 });
     *   response = (await iterator.next()).value;
     *   // Prints 10 file and directory names
     *   for (const fileItem of response.segment.fileItems) {
     *     console.log(`${i++} - file\t: ${fileItem.name}`);
     *   }
     *   for (const dirItem of response.segment.directoryItems) {
     *     console.log(`${i++} - directory\t: ${dirItem.name}`);
     *   }
     * ```
     *
     * @param {DirectoryListFilesAndDirectoriesOptions} [options] Options to list files and directories operation.
     * @memberof ShareDirectoryClient
     * @returns {PagedAsyncIterableIterator<{ kind: "file" } & FileItem | { kind: "directory" } , DirectoryListFilesAndDirectoriesSegmentResponse>}
     * An asyncIterableIterator that supports paging.
     */
    ShareDirectoryClient.prototype.listFilesAndDirectories = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        // AsyncIterableIterator to iterate over files and directories
        var iter = this.listFilesAndDirectoriesItems(options);
        return _a = {
                /**
                 * @member {Promise} [next] The next method, part of the iteration protocol
                 */
                next: function () {
                    return tslib.__awaiter(this, void 0, void 0, function () {
                        return tslib.__generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateFilesAndDirectoriesSegments(settings.continuationToken, tslib.__assign({ maxResults: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the
     * contents only for a single level of the directory hierarchy.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-directories-and-files
     *
     * @param {string} [marker] A string value that identifies the portion of the list to be returned with the next list operation.
     * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to Directory List Files and Directories Segment operation.
     * @returns {Promise<DirectoryListFilesAndDirectoriesSegmentResponse>} Response data for the Directory List Files and Directories operation.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.listFilesAndDirectoriesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareDirectoryClient-listFilesAndDirectoriesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.listFilesAndDirectoriesSegment(tslib.__assign(tslib.__assign({ marker: marker }, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for DirectoryListHandlesResponse
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {DirectoryListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<DirectoryListHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.iterateHandleSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function iterateHandleSegments_1() {
            var listHandlesResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!marker || marker === undefined)) return [3 /*break*/, 7];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(this.listHandlesSegment(marker, options))];
                    case 2:
                        listHandlesResponse = _a.sent();
                        marker = listHandlesResponse.continuationToken;
                        return [4 /*yield*/, tslib.__await(listHandlesResponse)];
                    case 3: return [4 /*yield*/, tslib.__await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @private
     * @param {DirectoryListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<HandleItem>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.listHandleItems = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listHandleItems_1() {
            var marker, _a, _b, listHandlesResponse, _i, _c, handle, e_6_1;
            var e_6, _d;
            return tslib.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _e.trys.push([0, 9, 10, 15]);
                        _a = tslib.__asyncValues(this.iterateHandleSegments(marker, options));
                        _e.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 2:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 8];
                        listHandlesResponse = _b.value;
                        if (!listHandlesResponse.handleList) return [3 /*break*/, 7];
                        _i = 0, _c = listHandlesResponse.handleList;
                        _e.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3 /*break*/, 7];
                        handle = _c[_i];
                        return [4 /*yield*/, tslib.__await(handle)];
                    case 4: return [4 /*yield*/, _e.sent()];
                    case 5:
                        _e.sent();
                        _e.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 1];
                    case 8: return [3 /*break*/, 15];
                    case 9:
                        e_6_1 = _e.sent();
                        e_6 = { error: e_6_1 };
                        return [3 /*break*/, 15];
                    case 10:
                        _e.trys.push([10, , 13, 14]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 12];
                        return [4 /*yield*/, tslib.__await(_d.call(_a))];
                    case 11:
                        _e.sent();
                        _e.label = 12;
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        if (e_6) throw e_6.error;
                        return [7 /*endfinally*/];
                    case 14: return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * @example
     * ```js
     *   let i = 1;
     *   let iter = dirClient.listHandles();
     *   for await (const handle of iter) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Generator syntax .next()
     *   let i = 1;
     *   let iter = await dirClient.listHandles();
     *   let handleItem = await iter.next();
     *   while (!handleItem.done) {
     *     console.log(`Handle ${i++}: ${handleItem.value.path}, opened time ${handleItem.value.openTime}, clientIp ${handleItem.value.clientIp}`);
     *     handleItem = await iter.next();
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Example for .byPage()
     *   // passing optional maxPageSize in the page settings
     *   let i = 1;
     *   for await (const response of dirClient.listHandles({ recursive: true }).byPage({ maxPageSize: 20 })) {
     *     if (response.handleList) {
     *       for (const handle of response.handleList) {
     *         console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *       }
     *     }
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Passing marker as an argument (similar to the previous example)
     *   let i = 1;
     *   let iterator = dirClient.listHandles().byPage({ maxPageSize: 2 });
     *   let response = await iterator.next();
     *   // Prints 2 handles
     *   if (response.value.handleList) {
     *     for (const handle of response.value.handleList) {
     *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *     }
     *   }
     *   // Gets next marker
     *   let marker = response.value.continuationToken;
     *   // Passing next marker as continuationToken
     *   console.log(`    continuation`);
     *   iterator = dirClient.listHandles().byPage({ continuationToken: marker, maxPageSize: 10 });
     *   response = await iterator.next();
     *   // Prints 2 more handles assuming you have more than four directory/files opened
     *   if (!response.done && response.value.handleList) {
     *     for (const handle of response.value.handleList) {
     *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *     }
     *   }
     * ```
     *
     * @param {DirectoryListHandlesOptions} [options] Options to list handles operation.
     * @memberof ShareDirectoryClient
     * @returns {PagedAsyncIterableIterator<HandleItem, DirectoryListHandlesResponse>}
     * An asyncIterableIterator that supports paging.
     */
    ShareDirectoryClient.prototype.listHandles = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        // an AsyncIterableIterator to iterate over handles
        var iter = this.listHandleItems(options);
        return _a = {
                /**
                 * @member {Promise} [next] The next method, part of the iteration protocol
                 */
                next: function () {
                    return tslib.__awaiter(this, void 0, void 0, function () {
                        return tslib.__generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateHandleSegments(settings.continuationToken, tslib.__assign({ maxResults: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Lists handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {DirectoryListHandlesSegmentOptions} [options={}]
     * @returns {Promise<DirectoryListHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.listHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, e_7;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-listHandlesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.listHandles(tslib.__assign(tslib.__assign({ marker: marker }, options), { spanOptions: spanOptions }))];
                    case 2:
                        response = _b.sent();
                        // TODO: Protocol layer issue that when handle list is in returned XML
                        // response.handleList is an empty string
                        if (response.handleList === "") {
                            response.handleList = undefined;
                        }
                        return [2 /*return*/, response];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param {DirectoryForceCloseHandlesSegmentOptions} [options={}]
     * @returns {Promise<DirectoryForceCloseHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.forceCloseHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareDirectoryClient-forceCloseHandlesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    marker = marker === "" ? undefined : marker;
                    return [2 /*return*/, this.context.forceCloseHandles("*", tslib.__assign(tslib.__assign({ marker: marker }, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {DirectoryForceCloseHandlesSegmentOptions} [options={}]
     * @returns {Promise<number>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.forceCloseAllHandles = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, handlesClosed, marker, response, e_8;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-forceCloseAllHandles", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        handlesClosed = 0;
                        marker = "";
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.forceCloseHandlesSegment(marker, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 3:
                        response = _b.sent();
                        marker = response.marker;
                        response.numberOfHandlesClosed && (handlesClosed += response.numberOfHandlesClosed);
                        _b.label = 4;
                    case 4:
                        if (marker) return [3 /*break*/, 2];
                        _b.label = 5;
                    case 5: return [2 /*return*/, handlesClosed];
                    case 6:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_8.message
                        });
                        throw e_8;
                    case 7:
                        span.end();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close a specific handle for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),
     *                          goto documents of Aborter for more examples about request cancellation
     * @param {string} handleId Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseHandlesSegment() to close all handles.
     * @param {DirectoryForceCloseHandlesOptions} [options={}]
     * @returns {Promise<DirectoryForceCloseHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.forceCloseHandle = function (handleId, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareDirectoryClient-forceCloseHandle", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (handleId === "*") {
                        throw new RangeError("Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.");
                    }
                    return [2 /*return*/, this.context.forceCloseHandles(handleId, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    return ShareDirectoryClient;
}(StorageClient));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * StorageSharedKeyCredentialPolicy is a policy used to sign HTTP request with a shared key.
 *
 * @export
 * @class StorageSharedKeyCredentialPolicy
 * @extends {CredentialPolicy}
 */
var StorageSharedKeyCredentialPolicy = /** @class */ (function (_super) {
    tslib.__extends(StorageSharedKeyCredentialPolicy, _super);
    /**
     * Creates an instance of StorageSharedKeyCredentialPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @param {StorageSharedKeyCredential} factory
     * @memberof StorageSharedKeyCredentialPolicy
     */
    function StorageSharedKeyCredentialPolicy(nextPolicy, options, factory) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.factory = factory;
        return _this;
    }
    /**
     * Signs request.
     *
     * @protected
     * @param {WebResource} request
     * @returns {WebResource}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    StorageSharedKeyCredentialPolicy.prototype.signRequest = function (request) {
        request.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString());
        if (request.body && typeof request.body === "string" && request.body.length > 0) {
            request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
        var stringToSign = [
            request.method.toUpperCase(),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LANGUAGE),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_ENCODING),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LENGTH),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_MD5),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_TYPE),
            this.getHeaderValueToSign(request, HeaderConstants.DATE),
            this.getHeaderValueToSign(request, HeaderConstants.IF_MODIFIED_SINCE),
            this.getHeaderValueToSign(request, HeaderConstants.IF_MATCH),
            this.getHeaderValueToSign(request, HeaderConstants.IF_NONE_MATCH),
            this.getHeaderValueToSign(request, HeaderConstants.IF_UNMODIFIED_SINCE),
            this.getHeaderValueToSign(request, HeaderConstants.RANGE)
        ].join("\n") +
            "\n" +
            this.getCanonicalizedHeadersString(request) +
            this.getCanonicalizedResourceString(request);
        var signature = this.factory.computeHMACSHA256(stringToSign);
        request.headers.set(HeaderConstants.AUTHORIZATION, "SharedKey " + this.factory.accountName + ":" + signature);
        // Workaround for https://github.com/axios/axios/issues/2107
        // We should always keep the 'content-length' header once the issue is solved
        // For a better explanation about this workaround, look here: https://github.com/Azure/azure-sdk-for-js/pull/3273
        if (typeof request.body !== "function" && !(request.body && request.onUploadProgress)) {
            request.headers.remove(HeaderConstants.CONTENT_LENGTH);
        }
        // console.log(`[URL]:${request.url}`);
        // console.log(`[HEADERS]:${request.headers.toString()}`);
        // console.log(`[STRING TO SIGN]:${JSON.stringify(stringToSign)}`);
        // console.log(`[KEY]: ${request.headers.get(HeaderConstants.AUTHORIZATION)}`);
        return request;
    };
    /**
     * Retrieve header value according to shared key sign rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
     *
     * @private
     * @param {WebResource} request
     * @param {string} headerName
     * @returns {string}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    StorageSharedKeyCredentialPolicy.prototype.getHeaderValueToSign = function (request, headerName) {
        var value = request.headers.get(headerName);
        if (!value) {
            return "";
        }
        // When using version 2015-02-21 or later, if Content-Length is zero, then
        // set the Content-Length part of the StringToSign to an empty string.
        // https://docs.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
        if (headerName === HeaderConstants.CONTENT_LENGTH && value === "0") {
            return "";
        }
        return value;
    };
    /**
     * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
     * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
     * 2. Convert each HTTP header name to lowercase.
     * 3. Sort the headers lexicographically by header name, in ascending order.
     *    Each header may appear only once in the string.
     * 4. Replace any linear whitespace in the header value with a single space.
     * 5. Trim any whitespace around the colon in the header.
     * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
     *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
     *
     * @private
     * @param {WebResource} request
     * @returns {string}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    StorageSharedKeyCredentialPolicy.prototype.getCanonicalizedHeadersString = function (request) {
        var headersArray = request.headers.headersArray().filter(function (value) {
            return value.name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE);
        });
        headersArray.sort(function (a, b) {
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
        // Remove duplicate headers
        headersArray = headersArray.filter(function (value, index, array) {
            if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
                return false;
            }
            return true;
        });
        var canonicalizedHeadersStringToSign = "";
        headersArray.forEach(function (header) {
            canonicalizedHeadersStringToSign += header.name
                .toLowerCase()
                .trimRight() + ":" + header.value.trimLeft() + "\n";
        });
        return canonicalizedHeadersStringToSign;
    };
    /**
     * Retrieves the webResource canonicalized resource string.
     *
     * @private
     * @param {WebResource} request
     * @returns {string}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    StorageSharedKeyCredentialPolicy.prototype.getCanonicalizedResourceString = function (request) {
        var path = getURLPath(request.url) || "/";
        var canonicalizedResourceString = "";
        canonicalizedResourceString += "/" + this.factory.accountName + path;
        var queries = getURLQueries(request.url);
        var lowercaseQueries = {};
        if (queries) {
            var queryKeys = [];
            for (var key in queries) {
                if (queries.hasOwnProperty(key)) {
                    var lowercaseKey = key.toLowerCase();
                    lowercaseQueries[lowercaseKey] = queries[key];
                    queryKeys.push(lowercaseKey);
                }
            }
            queryKeys.sort();
            for (var _i = 0, queryKeys_1 = queryKeys; _i < queryKeys_1.length; _i++) {
                var key = queryKeys_1[_i];
                canonicalizedResourceString += "\n" + key + ":" + decodeURIComponent(lowercaseQueries[key]);
            }
        }
        return canonicalizedResourceString;
    };
    return StorageSharedKeyCredentialPolicy;
}(CredentialPolicy));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * StorageSharedKeyCredential for account key authorization of Azure Storage service.
 *
 * @export
 * @class StorageSharedKeyCredential
 * @extends {Credential}
 */
var StorageSharedKeyCredential = /** @class */ (function (_super) {
    tslib.__extends(StorageSharedKeyCredential, _super);
    /**
     * Creates an instance of StorageSharedKeyCredential.
     * @param {string} accountName
     * @param {string} accountKey
     * @memberof StorageSharedKeyCredential
     */
    function StorageSharedKeyCredential(accountName, accountKey) {
        var _this = _super.call(this) || this;
        _this.accountName = accountName;
        _this.accountKey = Buffer.from(accountKey, "base64");
        return _this;
    }
    /**
     * Creates a StorageSharedKeyCredentialPolicy object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {StorageSharedKeyCredentialPolicy}
     * @memberof StorageSharedKeyCredential
     */
    StorageSharedKeyCredential.prototype.create = function (nextPolicy, options) {
        return new StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
    };
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param {string} stringToSign
     * @returns {string}
     * @memberof StorageSharedKeyCredential
     */
    StorageSharedKeyCredential.prototype.computeHMACSHA256 = function (stringToSign) {
        return crypto.createHmac("sha256", this.accountKey)
            .update(stringToSign, "utf8")
            .digest("base64");
    };
    return StorageSharedKeyCredential;
}(Credential));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A ShareClient represents a URL to the Azure Storage share allowing you to manipulate its directories and files.
 *
 * @export
 * @class ShareClient
 */
var ShareClient = /** @class */ (function (_super) {
    tslib.__extends(ShareClient, _super);
    function ShareClient(urlOrConnectionString, credentialOrPipelineOrShareName, options) {
        var _this = this;
        var pipeline;
        var url;
        if (credentialOrPipelineOrShareName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrShareName;
        }
        else if (credentialOrPipelineOrShareName instanceof Credential) {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            pipeline = newPipeline(credentialOrPipelineOrShareName, options);
        }
        else if (!credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName !== "string") {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName === "string") {
            // (connectionString: string, shareName: string, options?: StoragePipelineOptions)
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            var shareName = credentialOrPipelineOrShareName;
            if (extractedCreds.kind === "AccountConnString") {
                {
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(extractedCreds.url, shareName);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url = appendToURLPath(extractedCreds.url, shareName) + "?" + extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for shareName parameter");
        }
        _this = _super.call(this, url, pipeline) || this;
        _this._shareName = getShareNameAndPathFromUrl(_this.url).shareName;
        _this.context = new Share(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareClient.prototype, "shareName", {
        get: function () {
            return this._shareName;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new ShareClient object identical to the source but with the specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base share.
     *
     * @param {string} snapshot The snapshot timestamp.
     * @returns {ShareClient} A new ShareClient object identical to the source but with the specified snapshot timestamp
     * @memberof ShareClient
     */
    ShareClient.prototype.withSnapshot = function (snapshot) {
        return new ShareClient(setURLParameter(this.url, URLConstants.Parameters.SHARE_SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    };
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, the operation fails.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param {ShareCreateOptions} [options] Options to Share Create operation.
     * @returns {Promise<ShareCreateResponse>} Response data for the Share Create operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.create(tslib.__assign(tslib.__assign({}, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Creates a ShareDirectoryClient object.
     *
     * @param directoryName A directory name
     * @returns {ShareDirectoryClient} The ShareDirectoryClient object for the given directory name.
     * @memberof ShareClient
     */
    ShareClient.prototype.getDirectoryClient = function (directoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(directoryName)), this.pipeline);
    };
    Object.defineProperty(ShareClient.prototype, "rootDirectoryClient", {
        /**
         * Gets the directory client for the root directory of this share.
         * Note that the root directory always exists and cannot be deleted.
         *
         * @readonly
         * @type {ShareDirectoryClient} A new ShareDirectoryClient object for the root directory.
         * @memberof ShareClient
         */
        get: function () {
            return this.getDirectoryClient("");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new subdirectory under this share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param {string} directoryName
     * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.
     * @returns {Promise<{ directoryClient: ShareDirectoryClient, directoryCreateResponse: DirectoryCreateResponse }>} Directory creation response data and the corresponding directory client.
     * @memberof ShareClient
     */
    ShareClient.prototype.createDirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, directoryCreateResponse, e_1;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createDirectory", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.create(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        directoryCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                directoryClient: directoryClient,
                                directoryCreateResponse: directoryCreateResponse
                            }];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty sub directory under this share.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param {string} directoryName
     * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.
     * @returns {Promise<DirectoryDeleteResponse>} Directory deletion response data.
     * @memberof ShareClient
     */
    ShareClient.prototype.deleteDirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, e_2;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-deleteDirectory", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.delete(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new file or replaces a file under the root directory of this share.
     * Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param {string} fileName
     * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.
     * @param {FileCreateOptions} [options] Options to File Create operation.
     * @returns {Promise<{ fileClient: ShareFileClient, fileCreateResponse: FileCreateResponse }>} File creation response data and the corresponding file client.
     * @memberof ShareClient
     */
    ShareClient.prototype.createFile = function (fileName, size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, fileClient, fileCreateResponse, e_3;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.rootDirectoryClient;
                        fileClient = directoryClient.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.create(size, tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        fileCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                fileClient: fileClient,
                                fileCreateResponse: fileCreateResponse
                            }];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes a file under the root directory of this share from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param {string} directoryName
     * @param {string} fileName
     * @param {FileDeleteOptions} [options] Options to File Delete operation.
     * @returns Promise<FileDeleteResponse> File Delete response data.
     * @memberof ShareClient
     */
    ShareClient.prototype.deleteFile = function (fileName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, fileClient, e_4;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-deleteFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.rootDirectoryClient;
                        fileClient = directoryClient.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.delete(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata and system properties for the specified
     * share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-properties
     *
     * @returns {Promise<ShareGetPropertiesResponse>} Response data for the Share Get Properties operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.getProperties({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Marks the specified share for deletion. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param {ShareDeleteMethodOptions} [options] Options to Share Delete operation.
     * @returns {Promise<ShareDeleteResponse>} Response data for the Share Delete operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.deleteMethod(tslib.__assign(tslib.__assign({}, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets one or more user-defined name-value pairs for the specified share.
     *
     * If no option provided, or no metadata defined in the option parameter, the share
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-metadata
     *
     * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed.
     * @param {ShareSetMetadataOptions} [option] Options to Share Set Metadata operation.
     * @returns {Promise<ShareSetMetadataResponse>} Response data for the Share Set Metadata operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.setMetadata({
                            abortSignal: options.abortSignal,
                            metadata: metadata,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Gets the permissions for the specified share. The permissions indicate
     * whether share data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-acl
     *
     * @param {ShareGetAccessPolicyOptions} [option] Options to Share Get Access Policy operation.
     * @returns {Promise<ShareGetAccessPolicyResponse>} Response data for the Share Get Access Policy operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.getAccessPolicy = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, res, _i, response_1, identifier, e_5;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getAccessPolicy({
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            date: response.date,
                            etag: response.etag,
                            lastModified: response.lastModified,
                            requestId: response.requestId,
                            signedIdentifiers: [],
                            version: response.version
                        };
                        for (_i = 0, response_1 = response; _i < response_1.length; _i++) {
                            identifier = response_1[_i];
                            res.signedIdentifiers.push({
                                accessPolicy: {
                                    expiry: new Date(identifier.accessPolicy.expiry),
                                    permissions: identifier.accessPolicy.permissions,
                                    start: new Date(identifier.accessPolicy.start)
                                },
                                id: identifier.id
                            });
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the permissions for the specified share. The permissions indicate
     * whether directories or files in a share may be accessed publicly.
     *
     * When you set permissions for a share, the existing permissions are replaced.
     * If no shareAcl provided, the existing share ACL will be
     * removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl
     *
     * @param {SignedIdentifier[]} [shareAcl] Array of signed identifiers, each having a unique Id and details of access policy.
     * @param {ShareSetAccessPolicyOptions} [option] Options to Share Set Access Policy operation.
     * @returns {Promise<ShareSetAccessPolicyResponse>} Response data for the Share Set Access Policy operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.setAccessPolicy = function (shareAcl, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, acl, _i, _b, identifier;
            return tslib.__generator(this, function (_c) {
                _a = createSpan("ShareClient-setAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    acl = [];
                    for (_i = 0, _b = shareAcl || []; _i < _b.length; _i++) {
                        identifier = _b[_i];
                        acl.push({
                            accessPolicy: {
                                expiry: truncatedISO8061Date(identifier.accessPolicy.expiry),
                                permissions: identifier.accessPolicy.permissions,
                                start: truncatedISO8061Date(identifier.accessPolicy.start)
                            },
                            id: identifier.id
                        });
                    }
                    return [2 /*return*/, this.context.setAccessPolicy({
                            abortSignal: options.abortSignal,
                            shareAcl: acl,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Creates a read-only snapshot of a share.
     *
     * @param {ShareCreateSnapshotOptions} [options={}] Options to Share Create Snapshot operation.
     * @returns {Promise<ShareCreateSnapshotResponse>} Response data for the Share Create Snapshot operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.createSnapshot = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareClient-createSnapshot", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.createSnapshot(tslib.__assign(tslib.__assign({ abortSignal: options.abortSignal }, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets quota for the specified share.
     *
     * @param {number} quotaInGB Specifies the maximum size of the share in gigabytes
     * @param {ShareSetQuotaOptions} [option] Options to Share Set Quota operation.
     * @returns {Promise<ShareSetQuotaResponse>} Response data for the Share Get Quota operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.setQuota = function (quotaInGB, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareClient-setQuota", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (quotaInGB <= 0 || quotaInGB > 5120) {
                        throw new RangeError("Share quota must be greater than 0, and less than or equal to 5Tib (5120GB)");
                    }
                    return [2 /*return*/, this.context.setQuota({
                            abortSignal: options.abortSignal,
                            quota: quotaInGB,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Retrieves statistics related to the share.
     *
     * @param {ShareGetStatisticsOptions} [option] Options to Share Get Statistics operation.
     * @returns {Promise<ShareGetStatisticsResponse>} Response data for the Share Get Statistics operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.getStatistics = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, GBBytes, e_6;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getStatistics", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getStatistics({
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        response = _b.sent();
                        GBBytes = 1024 * 1024 * 1024;
                        return [2 /*return*/, tslib.__assign(tslib.__assign({}, response), { shareUsage: Math.ceil(response.shareUsageBytes / GBBytes) })];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a file permission (a security descriptor) at the share level.
     * The created security descriptor can be used for the files/directories in the share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-permission
     *
     * @param {ShareCreatePermissionOptions} [options] Options to Share Create Permission operation.
     * @param filePermission File permission described in the SDDL
     */
    ShareClient.prototype.createPermission = function (filePermission, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareClient-createPermission", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.createPermission({
                            permission: filePermission
                        }, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Gets the Security Descriptor Definition Language (SDDL) for a given file permission key
     * which indicates a security descriptor.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-permission
     *
     * @param {ShareGetPermissionOptions} [options] Options to Share Create Permission operation.
     * @param filePermissionKey File permission key which indicates the security descriptor of the permission.
     */
    ShareClient.prototype.getPermission = function (filePermissionKey, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareClient-getPermission", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.getPermission(filePermissionKey, {
                            aborterSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    return ShareClient;
}(StorageClient));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A ShareServiceClient represents a URL to the Azure Storage File service allowing you
 * to manipulate file shares.
 *
 * @export
 * @class ShareServiceClient
 */
var ShareServiceClient = /** @class */ (function (_super) {
    tslib.__extends(ShareServiceClient, _super);
    function ShareServiceClient(url, credentialOrPipeline, options) {
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        _this.serviceContext = new Service(_this.storageClientContext);
        return _this;
    }
    /**
     *
     * Creates an instance of ShareServiceClient from connection string.
     *
     * @param {string} connectionString Account connection string or a SAS connection string of an Azure storage account.
     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                                  Account connection string example -
     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                                  SAS connection string example -
     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param {StoragePipelineOptions} [options] Options to configure the HTTP pipeline.
     * @returns {ShareServiceClient} A new ShareServiceClient from the given connection string.
     * @memberof ShareServiceClient
     */
    ShareServiceClient.fromConnectionString = function (connectionString, options) {
        var extractedCreds = extractConnectionStringParts(connectionString);
        if (extractedCreds.kind === "AccountConnString") {
            {
                var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                var pipeline = newPipeline(sharedKeyCredential, options);
                return new ShareServiceClient(extractedCreds.url, pipeline);
            }
        }
        else if (extractedCreds.kind === "SASConnString") {
            var pipeline = newPipeline(new AnonymousCredential(), options);
            return new ShareServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
        }
        else {
            throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
    };
    /**
     * Creates a ShareClient object.
     *
     * @param shareName Name of a share.
     * @returns {ShareClient} The ShareClient object for the given share name.
     * @memberof ShareServiceClient
     */
    ShareServiceClient.prototype.getShareClient = function (shareName) {
        return new ShareClient(appendToURLPath(this.url, shareName), this.pipeline);
    };
    /**
     * Creates a Share.
     *
     * @param {string} shareName
     * @param {ShareCreateOptions} [options]
     * @returns {Promise<{ shareCreateResponse: ShareCreateResponse, shareClient: ShareClient }>} Share creation response and the corresponding share client.
     * @memberof ShareServiceClient
     */
    ShareServiceClient.prototype.createShare = function (shareName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, shareClient, shareCreateResponse, e_1;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareServiceClient-createShare", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        shareClient = this.getShareClient(shareName);
                        return [4 /*yield*/, shareClient.create(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        shareCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                shareCreateResponse: shareCreateResponse,
                                shareClient: shareClient
                            }];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Deletes a Share.
     *
     * @param {string} shareName
     * @param {ShareDeleteMethodOptions} [options]
     * @returns {Promise<ShareDeleteResponse>} Share deletion response and the corresponding share client.
     * @memberof ShareServiceClient
     */
    ShareServiceClient.prototype.deleteShare = function (shareName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, shareClient, e_2;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareServiceClient-deleteShare", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        shareClient = this.getShareClient(shareName);
                        return [4 /*yield*/, shareClient.delete(tslib.__assign(tslib.__assign({}, options), { tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: coreTracing.CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the properties of a storage accounts file service, including properties
     * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-service-properties}
     *
     * @param {ServiceGetPropertiesOptions} [options={}] Options to Get Properties operation.
     * @returns {Promise<ServiceGetPropertiesResponse>} Response data for the Get Properties operation.
     * @memberof ShareServiceClient
     */
    ShareServiceClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareServiceClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.serviceContext.getProperties({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets properties for a storage accounts file service endpoint, including properties
     * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-service-properties}
     *
     * @param {FileServiceProperties} properties
     * @param {ServiceSetPropertiesOptions} [options={}] Options to Set Properties operation.
     * @returns {Promise<ServiceSetPropertiesResponse>} Response data for the Set Properties operation.
     * @memberof ShareServiceClient
     */
    ShareServiceClient.prototype.setProperties = function (properties, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareServiceClient-setProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.serviceContext.setProperties(properties, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for ServiceListSharesSegmentResponses
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of
     *                          the list of shares to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all shares remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param {ServiceListSharesSegmentOptions} [options] Options to list shares operation.
     * @returns {AsyncIterableIterator<ServiceListSharesSegmentResponse>}
     * @memberof ShareServiceClient
     */
    ShareServiceClient.prototype.listSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listSegments_1() {
            var listSharesSegmentResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tslib.__await(this.listSharesSegment(marker, options))];
                    case 1:
                        listSharesSegmentResponse = _a.sent();
                        marker = listSharesSegmentResponse.continuationToken;
                        return [4 /*yield*/, tslib.__await(listSharesSegmentResponse)];
                    case 2: return [4 /*yield*/, tslib.__await.apply(void 0, [_a.sent()])];
                    case 3: return [4 /*yield*/, _a.sent()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (marker) return [3 /*break*/, 0];
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for share items
     *
     * @private
     * @param {ServiceListSharesSegmentOptions} [options] Options to list shares operation.
     * @returns {AsyncIterableIterator<ServiceListSharesSegmentResponse>}
     * @memberof ShareServiceClient
     */
    ShareServiceClient.prototype.listItems = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listItems_1() {
            var marker, _a, _b, segment, e_3_1;
            var e_3, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 7, 8, 13]);
                        _a = tslib.__asyncValues(this.listSegments(marker, options));
                        _d.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 2:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 6];
                        segment = _b.value;
                        return [5 /*yield**/, tslib.__values(tslib.__asyncDelegator(tslib.__asyncValues(segment.shareItems)))];
                    case 3: return [4 /*yield*/, tslib.__await.apply(void 0, [_d.sent()])];
                    case 4:
                        _d.sent();
                        _d.label = 5;
                    case 5: return [3 /*break*/, 1];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _d.trys.push([8, , 11, 12]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 9:
                        _d.sent();
                        _d.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the shares
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the shares in pages.
     *
     * @example
     * ```js
     *   let i = 1;
     *   for await (const share of serviceClient.listShares()) {
     *     console.log(`Share ${i++}: ${share.name}`);
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Generator syntax .next()
     *   let i = 1;
     *   let iter = await serviceClient.listShares();
     *   let shareItem = await iter.next();
     *   while (!shareItem.done) {
     *     console.log(`Share ${i++}: ${shareItem.value.name}`);
     *     shareItem = await iter.next();
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Example for .byPage()
     *   // passing optional maxPageSize in the page settings
     *   let i = 1;
     *   for await (const response of serviceClient.listShares().byPage({ maxPageSize: 20 })) {
     *     if (response.shareItems) {
     *       for (const share of response.shareItems) {
     *         console.log(`Share ${i++}: ${share.name}`);
     *       }
     *     }
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Passing marker as an argument (similar to the previous example)
     *   let i = 1;
     *   let iterator = serviceClient.listShares().byPage({ maxPageSize: 2 });
     *   let response = (await iterator.next()).value;
     *   // Prints 2 share names
     *   if (response.shareItems) {
     *     for (const share of response.shareItems) {
     *       console.log(`Share ${i++}: ${share.name}`);
     *     }
     *   }
     *   // Gets next marker
     *   let marker = response.continuationToken;
     *   // Passing next marker as continuationToken
     *   iterator = serviceClient.listShares().byPage({ continuationToken: marker, maxPageSize: 10 });
     *   response = (await iterator.next()).value;
     *   // Prints 10 share names
     *   if (response.shareItems) {
     *     for (const share of response.shareItems) {
     *       console.log(`Share ${i++}: ${share.name}`);
     *     }
     *   }
     * ```
     *
     * @param {ServiceListSharesOptions} [options] Options to list shares operation.
     * @memberof ShareServiceClient
     * @returns {PagedAsyncIterableIterator<ShareItem, ServiceListSharesSegmentResponse>}
     * An asyncIterableIterator that supports paging.
     */
    ShareServiceClient.prototype.listShares = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var include = [];
        if (options.includeMetadata) {
            include.push("metadata");
        }
        if (options.includeSnapshots) {
            include.push("snapshots");
        }
        var updatedOptions = tslib.__assign(tslib.__assign({}, options), (include.length > 0 ? { include: include } : {}));
        // AsyncIterableIterator to iterate over queues
        var iter = this.listItems(updatedOptions);
        return _a = {
                /**
                 * @member {Promise} [next] The next method, part of the iteration protocol
                 */
                next: function () {
                    return iter.next();
                }
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSegments(settings.continuationToken, tslib.__assign({ maxResults: settings.maxPageSize }, updatedOptions));
            },
            _a;
    };
    /**
     * Gets the properties of a storage account's File service, including properties for Storage
     * Analytics metrics and CORS (Cross-Origin Resource Sharing) rules.
     *
     * @param {string} [marker] A string value that identifies the portion of
     *                          the list to be returned with the next list operation. The operation
     *                          returns a marker value within the response body if the list returned was
     *                          not complete. The marker value may then be used in a subsequent call to
     *                          request the next set of list items. The marker value is opaque to the
     *                          client.
     * @param {ServiceListSharesSegmentOptions} [options={}] Options to List Shares Segment operation.
     * @returns {Promise<ServiceListSharesSegmentResponse>} Response data for the List Shares Segment operation.
     * @memberof ShareServiceClient
     */
    ShareServiceClient.prototype.listSharesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareServiceClient-listSharesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.serviceContext.listSharesSegment(tslib.__assign(tslib.__assign({ marker: marker }, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    return ShareServiceClient;
}(StorageClient));

Object.defineProperty(exports, 'BaseRequestPolicy', {
    enumerable: true,
    get: function () {
        return coreHttp.BaseRequestPolicy;
    }
});
Object.defineProperty(exports, 'HttpHeaders', {
    enumerable: true,
    get: function () {
        return coreHttp.HttpHeaders;
    }
});
Object.defineProperty(exports, 'RequestPolicyOptions', {
    enumerable: true,
    get: function () {
        return coreHttp.RequestPolicyOptions;
    }
});
Object.defineProperty(exports, 'RestError', {
    enumerable: true,
    get: function () {
        return coreHttp.RestError;
    }
});
Object.defineProperty(exports, 'WebResource', {
    enumerable: true,
    get: function () {
        return coreHttp.WebResource;
    }
});
Object.defineProperty(exports, 'deserializationPolicy', {
    enumerable: true,
    get: function () {
        return coreHttp.deserializationPolicy;
    }
});
exports.AccountSASPermissions = AccountSASPermissions;
exports.AccountSASResourceTypes = AccountSASResourceTypes;
exports.AccountSASServices = AccountSASServices;
exports.AnonymousCredential = AnonymousCredential;
exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
exports.Credential = Credential;
exports.CredentialPolicy = CredentialPolicy;
exports.FileSASPermissions = FileSASPermissions;
exports.FileSystemAttributes = FileSystemAttributes;
exports.Pipeline = Pipeline;
exports.SASQueryParameters = SASQueryParameters;
exports.ShareClient = ShareClient;
exports.ShareDirectoryClient = ShareDirectoryClient;
exports.ShareFileClient = ShareFileClient;
exports.ShareSASPermissions = ShareSASPermissions;
exports.ShareServiceClient = ShareServiceClient;
exports.StorageBrowserPolicy = StorageBrowserPolicy;
exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
exports.StorageRetryPolicy = StorageRetryPolicy;
exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
exports.generateFileSASQueryParameters = generateFileSASQueryParameters;
exports.logger = logger;
exports.newPipeline = newPipeline;
//# sourceMappingURL=index.js.map
