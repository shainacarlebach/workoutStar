{"version":3,"file":"index.js","sources":["../src/log.ts","../src/receiveHandler.ts","../src/util/constants.ts","../../../../common/temp/node_modules/.registry.npmjs.org/uuid/3.3.3/node_modules/uuid/lib/rng.js","../../../../common/temp/node_modules/.registry.npmjs.org/uuid/3.3.3/node_modules/uuid/lib/bytesToUuid.js","../../../../common/temp/node_modules/.registry.npmjs.org/uuid/3.3.3/node_modules/uuid/v4.js","../src/linkEntity.ts","../src/managementClient.ts","../src/connectionContext.ts","../src/eventData.ts","../src/util/error.ts","../src/diagnostics/instrumentEventData.ts","../src/diagnostics/messageSpan.ts","../src/eventDataBatch.ts","../src/eventHubSender.ts","../src/sender.ts","../src/eventPosition.ts","../src/eventHubReceiver.ts","../src/receiver.ts","../src/eventHubClient.ts","../src/partitionPump.ts","../src/pumpManager.ts","../src/partitionLoadBalancer.ts","../src/eventProcessor.ts","../src/inMemoryPartitionManager.ts","../src/partitionProcessor.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport debugModule from \"debug\";\n/**\n * @ignore\n * log statements for error\n */\nexport const error = debugModule(\"azure:event-hubs:error\");\n/**\n * @ignore\n * log statements for management\n */\nexport const mgmt = debugModule(\"azure:event-hubs:management\");\n/**\n * @ignore\n * log statements for sender\n */\nexport const sender = debugModule(\"azure:event-hubs:sender\");\n/**\n * @ignore\n * log statements for receiver\n */\nexport const receiver = debugModule(\"azure:event-hubs:receiver\");\n/**\n * @ignore\n * log statements for receiverbatching\n */\nexport const batching = debugModule(\"azure:event-hubs:receiverbatching\");\n/**\n * @ignore\n * log statements for receiverstreaming\n */\nexport const streaming = debugModule(\"azure:event-hubs:receiverstreaming\");\n/**\n * @ignore\n * log statements for linkEntity\n */\nexport const link = debugModule(\"azure:event-hubs:linkEntity\");\n/**\n * @ignore\n * log statements for connectionContext\n */\nexport const context = debugModule(\"azure:event-hubs:connectionContext\");\n/**\n * @ignore\n * log statements for client\n */\nexport const client = debugModule(\"azure:event-hubs:client\");\n\n/**\n * @ignore\n * log statements for iothub client\n */\nexport const iotClient = debugModule(\"azure:event-hubs:iothubClient\");\n/**\n * @ignore\n * log statements for partitionManager\n */\nexport const partitionPump = debugModule(\"azure:event-hubs:partitionPump\");\n/**\n * @ignore\n * log statements for pumpManager\n */\nexport const pumpManager = debugModule(\"azure:event-hubs:pumpManager\");\n/**\n * @ignore\n * log statements for eventProcessor\n */\nexport const eventProcessor = debugModule(\"azure:event-hubs:eventProcessor\");\n/**\n * @ignore\n * log statements for partitionLoadBalancer\n */\nexport const partitionLoadBalancer = debugModule(\"azure:event-hubs:partitionLoadBalancer\");\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventHubReceiver } from \"./eventHubReceiver\";\nimport * as log from \"./log\";\n\n/**\n * Describes the receive handler object that is returned from the receive() method with handlers.\n * The ReceiveHandler is used to stop receiving more messages.\n * @class ReceiveHandler\n */\nexport class ReceiveHandler {\n  /**\n   * @property _receiver  The underlying EventHubReceiver.\n   * @private\n   */\n  private _receiver: EventHubReceiver;\n\n  /**\n   * Creates an instance of the ReceiveHandler.\n   * @constructor\n   * @internal\n   * @param receiver The underlying EventHubReceiver.\n   */\n  constructor(receiver: EventHubReceiver) {\n    this._receiver = receiver;\n  }\n\n  /**\n   * @property The partitionId from which the handler is receiving events.\n   * @readonly\n   */\n  get partitionId(): string | undefined {\n    return this._receiver ? this._receiver.partitionId : undefined;\n  }\n\n  /**\n   * @property The consumer group from which the handler is receiving events.\n   * @readonly\n   */\n  get consumerGroup(): string | undefined {\n    return this._receiver ? this._receiver.consumerGroup : undefined;\n  }\n\n  /**\n   * @property Indicates whether the receiver is connected/open.\n   * `true` - is open; `false` otherwise.\n   * @readonly\n   */\n  get isReceiverOpen(): boolean {\n    return this._receiver ? this._receiver.isOpen() : false;\n  }\n\n  /**\n   * Stops the underlying EventHubReceiver from receiving more messages.\n   * @returns Promise<void>\n   * @throws {Error} Thrown if the underlying connection encounters an error while closing.\n   */\n  async stop(): Promise<void> {\n    if (this._receiver) {\n      try {\n        await this._receiver.close();\n      } catch (err) {\n        log.error(\n          \"An error occurred while stopping the receiver '%s' with address '%s': %O\",\n          this._receiver.name,\n          this._receiver.address,\n          err\n        );\n      }\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * @ignore\n */\nexport const packageJsonInfo = {\n  name: \"@azure/event-hubs\",\n  version: \"5.0.0-preview.5\"\n};\n","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport {\n  defaultLock,\n  SharedKeyCredential,\n  AccessToken,\n  Constants,\n  TokenType\n} from \"@azure/core-amqp\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { AwaitableSender, Receiver } from \"rhea-promise\";\nimport * as log from \"./log\";\n\n/**\n * @ignore\n */\nexport interface LinkEntityOptions {\n  /**\n   * @property [name] The unique name for the entity. If not provided then a guid will be\n   * assigned.\n   */\n  name?: string;\n  /**\n   * @property [partitionId] The partitionId associated with the link entity.\n   */\n  partitionId?: string;\n  /**\n   * @property address The link entity address in one of the following forms:\n   */\n  address?: string;\n  /**\n   * @property audience The link entity token audience in one of the following forms:\n   */\n  audience?: string;\n}\n\n/**\n * Describes the base class for entities like EventHub Sender, Receiver and Management link.\n * @internal\n * @ignore\n * @class LinkEntity\n */\nexport class LinkEntity {\n  /**\n   * @property [name] The unique name for the entity (mostly a guid).\n   */\n  name: string;\n  /**\n   * @property address The link entity address in one of the following forms:\n   *\n   * **Sender**\n   * - `\"<hubName>\"`\n   * - `\"<hubName>/Partitions/<partitionId>\"`.\n   *\n   * **Receiver**\n   * - `\"<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`.\n   *\n   * **ManagementClient**\n   * -`\"$management\"`.\n   */\n  address: string;\n  /**\n   * @property audience The link entity token audience in one of the following forms:\n   *\n   * **Sender**\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>\"`.\n   *\n   * **Receiver**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`.\n   *\n   * **ManagementClient**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management\"`.\n   */\n  audience: string;\n  /**\n   * @property [partitionId] The partitionId associated with the link entity.\n   */\n  partitionId?: string;\n  /**\n   * @property isConnecting Indicates whether the link is in the process of connecting\n   * (establishing) itself. Default value: `false`.\n   */\n  isConnecting: boolean = false;\n  /**\n   * @property _context Provides relevant information about the amqp connection,\n   * cbs and $management sessions, token provider, sender and receivers.\n   * @protected\n   */\n  protected _context: ConnectionContext;\n  /**\n   * @property _tokenRenewalTimer The token renewal timer that keeps track of when\n   * the Link Entity is due for token renewal.\n   * @protected\n   */\n  protected _tokenRenewalTimer?: NodeJS.Timer;\n  /**\n   * @property _tokenTimeout Indicates token timeout in milliseconds\n   * @protected\n   */\n  protected _tokenTimeoutInMs?: number;\n  /**\n   * Creates a new LinkEntity instance.\n   * @ignore\n   * @constructor\n   * @param context The connection context.\n   * @param [options] Options that can be provided while creating the LinkEntity.\n   */\n  constructor(context: ConnectionContext, options?: LinkEntityOptions) {\n    if (!options) options = {};\n    this._context = context;\n    this.address = options.address || \"\";\n    this.audience = options.audience || \"\";\n    this.name = `${options.name}-${uuid()}`;\n    this.partitionId = options.partitionId;\n  }\n\n  /**\n   * Negotiates cbs claim for the LinkEntity.\n   * @ignore\n   * @protected\n   * @param [setTokenRenewal] Set the token renewal timer. Default false.\n   * @returns Promise<void>\n   */\n  protected async _negotiateClaim(setTokenRenewal?: boolean): Promise<void> {\n    // Acquire the lock and establish a cbs session if it does not exist on the connection.\n    // Although node.js is single threaded, we need a locking mechanism to ensure that a\n    // race condition does not happen while creating a shared resource (in this case the\n    // cbs session, since we want to have exactly 1 cbs session per connection).\n    log.link(\n      \"[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: \" +\n        \"'%s' with address: '%s'.\",\n      this._context.connectionId,\n      this._context.cbsSession.cbsLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    await defaultLock.acquire(this._context.cbsSession.cbsLock, () => {\n      return this._context.cbsSession.init();\n    });\n    let tokenObject: AccessToken;\n    let tokenType: TokenType;\n    if (this._context.tokenCredential instanceof SharedKeyCredential) {\n      tokenObject = this._context.tokenCredential.getToken(this.audience);\n      tokenType = TokenType.CbsTokenTypeSas;\n      // renew sas token in every 45 minutess\n      this._tokenTimeoutInMs = (3600 - 900) * 1000;\n    } else {\n      const aadToken = await this._context.tokenCredential.getToken(Constants.aadEventHubsScope);\n      if (!aadToken) {\n        throw new Error(`Failed to get token from the provided \"TokenCredential\" object`);\n      }\n      tokenObject = aadToken;\n      tokenType = TokenType.CbsTokenTypeJwt;\n      this._tokenTimeoutInMs = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;\n    }\n\n    log.link(\n      \"[%s] %s: calling negotiateClaim for audience '%s'.\",\n      this._context.connectionId,\n      this._type,\n      this.audience\n    );\n    // Acquire the lock to negotiate the CBS claim.\n    log.link(\n      \"[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.\",\n      this._context.connectionId,\n      this._context.negotiateClaimLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    await defaultLock.acquire(this._context.negotiateClaimLock, () => {\n      return this._context.cbsSession.negotiateClaim(this.audience, tokenObject, tokenType);\n    });\n    log.link(\n      \"[%s] Negotiated claim for %s '%s' with with address: %s\",\n      this._context.connectionId,\n      this._type,\n      this.name,\n      this.address\n    );\n    if (setTokenRenewal) {\n      await this._ensureTokenRenewal();\n    }\n  }\n\n  /**\n   * Ensures that the token is renewed within the predefined renewal margin.\n   * @ignore\n   * @protected\n   * @returns\n   */\n  protected async _ensureTokenRenewal(): Promise<void> {\n    if (!this._tokenTimeoutInMs) {\n      return;\n    }\n    this._tokenRenewalTimer = setTimeout(async () => {\n      try {\n        await this._negotiateClaim(true);\n      } catch (err) {\n        log.error(\n          \"[%s] %s '%s' with address %s, an error occurred while renewing the token: %O\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address,\n          err\n        );\n      }\n    }, this._tokenTimeoutInMs);\n    log.link(\n      \"[%s] %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).\",\n      this._context.connectionId,\n      this._type,\n      this.name,\n      this.address,\n      this._tokenTimeoutInMs,\n      new Date(Date.now() + this._tokenTimeoutInMs).toString()\n    );\n  }\n\n  /**\n   * Closes the Sender|Receiver link and it's underlying session and also removes it from the\n   * internal map.\n   * @ignore\n   * @param [link] The Sender or Receiver link that needs to be closed and\n   * removed.\n   */\n  protected async _closeLink(link?: AwaitableSender | Receiver): Promise<void> {\n    clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n    if (link) {\n      try {\n        // Closing the link and its underlying sessionÂ if the link is open. This should also\n        // remove them from the internal map.\n        await link.close();\n        log.link(\n          \"[%s] %s '%s' with address '%s' closed.\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address\n        );\n      } catch (err) {\n        log.error(\n          \"[%s] An error occurred while closing the %s '%s' with address '%s': %O\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address,\n          err\n        );\n      }\n    }\n  }\n\n  /**\n   * Provides the current type of the LinkEntity.\n   * @returns The entity type.\n   */\n  private get _type(): string {\n    let result = \"LinkEntity\";\n    if ((this as any).constructor && (this as any).constructor.name) {\n      result = (this as any).constructor.name;\n    }\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport {\n  RequestResponseLink,\n  defaultLock,\n  translate,\n  Constants,\n  SendRequestOptions,\n  retry,\n  RetryConfig,\n  RetryOptions,\n  RetryOperationType\n} from \"@azure/core-amqp\";\nimport {\n  Message,\n  EventContext,\n  SenderEvents,\n  ReceiverEvents,\n  SenderOptions,\n  ReceiverOptions,\n  generate_uuid\n} from \"rhea-promise\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport * as log from \"./log\";\nimport { getRetryAttemptTimeoutInMs } from \"./eventHubClient\";\nimport { AbortSignalLike, AbortError } from \"@azure/abort-controller\";\n/**\n * Describes the runtime information of an Event Hub.\n * @interface HubRuntimeInformation\n */\nexport interface EventHubProperties {\n  /**\n   * @property The name of the event hub.\n   */\n  path: string;\n  /**\n   * @property The date and time the hub was created in UTC.\n   */\n  createdAt: Date;\n  /**\n   * @property The slice of string partition identifiers.\n   */\n  partitionIds: string[];\n}\n\n/**\n * Describes the runtime information of an EventHub Partition.\n * @interface PartitionProperties\n */\nexport interface PartitionProperties {\n  /**\n   * @property The name of the Event Hub.\n   */\n  eventHubName: string;\n  /**\n   * @property Identifier of the partition within the Event Hub.\n   */\n  partitionId: string;\n  /**\n   * @property The starting sequence number of the partition's message log.\n   */\n  beginningSequenceNumber: number;\n  /**\n   * @property The last sequence number of the partition's message log.\n   */\n  lastEnqueuedSequenceNumber: number;\n  /**\n   * @property The offset of the last enqueued message in the partition's message log.\n   */\n  lastEnqueuedOffset: number;\n  /**\n   * @property The time of the last enqueued message in the partition's message log in UTC.\n   */\n  lastEnqueuedTimeUtc: Date;\n}\n\n/**\n * @internal\n * @ignore\n */\nexport interface ManagementClientOptions {\n  address?: string;\n  audience?: string;\n}\n\n/**\n * @class ManagementClient\n * @internal\n * @ignore\n * Descibes the EventHubs Management Client that talks\n * to the $management endpoint over AMQP connection.\n */\nexport class ManagementClient extends LinkEntity {\n  readonly managementLock: string = `${Constants.managementRequestKey}-${uuid()}`;\n  /**\n   * @property entityPath - The name/path of the entity (hub name) for which the management\n   * request needs to be made.\n   */\n  entityPath: string;\n  /**\n   * @property replyTo The reply to Guid for the management client.\n   */\n  replyTo: string = uuid();\n  /**\n   * $management sender, receiver on the same session.\n   * @private\n   */\n  private _mgmtReqResLink?: RequestResponseLink;\n\n  /**\n   * Instantiates the management client.\n   * @constructor\n   * @ignore\n   * @param context The connection context.\n   * @param [address] The address for the management endpoint. For IotHub it will be\n   * `/messages/events/$management`.\n   */\n  constructor(context: ConnectionContext, options?: ManagementClientOptions) {\n    super(context, {\n      address: options && options.address ? options.address : Constants.management,\n      audience:\n        options && options.audience ? options.audience : context.config.getManagementAudience()\n    });\n    this._context = context;\n    this.entityPath = context.config.entityPath as string;\n  }\n\n  /**\n   * Provides the eventhub runtime information.\n   * @ignore\n   * @param connection - The established amqp connection\n   * @returns\n   */\n  async getHubRuntimeInformation(options?: {\n    retryOptions?: RetryOptions;\n    abortSignal?: AbortSignalLike;\n  }): Promise<EventHubProperties> {\n    if (!options) {\n      options = {};\n    }\n    const request: Message = {\n      body: Buffer.from(JSON.stringify([])),\n      message_id: uuid(),\n      reply_to: this.replyTo,\n      application_properties: {\n        operation: Constants.readOperation,\n        name: this.entityPath as string,\n        type: `${Constants.vendorString}:${Constants.eventHub}`\n      }\n    };\n\n    const info: any = await this._makeManagementRequest(request, {\n      ...options,\n      requestName: \"getHubRuntimeInformation\"\n    });\n    const runtimeInfo: EventHubProperties = {\n      path: info.name,\n      createdAt: new Date(info.created_at),\n      partitionIds: info.partition_ids\n    };\n    log.mgmt(\"[%s] The hub runtime info is: %O\", this._context.connectionId, runtimeInfo);\n    return runtimeInfo;\n  }\n\n  /**\n   * Provides an array of partitionIds.\n   * @ignore\n   * @param connection - The established amqp connection\n   * @returns\n   */\n  async getPartitionIds(): Promise<Array<string>> {\n    const runtimeInfo = await this.getHubRuntimeInformation();\n    return runtimeInfo.partitionIds;\n  }\n\n  /**\n   * Provides information about the specified partition.\n   * @ignore\n   * @param connection - The established amqp connection\n   * @param partitionId Partition ID for which partition information is required.\n   */\n  async getPartitionProperties(\n    partitionId: string,\n    options?: { retryOptions?: RetryOptions; abortSignal?: AbortSignalLike }\n  ): Promise<PartitionProperties> {\n    if (!options) {\n      options = {};\n    }\n    const request: Message = {\n      body: Buffer.from(JSON.stringify([])),\n      message_id: uuid(),\n      reply_to: this.replyTo,\n      application_properties: {\n        operation: Constants.readOperation,\n        name: this.entityPath as string,\n        type: `${Constants.vendorString}:${Constants.partition}`,\n        partition: `${partitionId}`\n      }\n    };\n\n    const info: any = await this._makeManagementRequest(request, {\n      ...options,\n      requestName: \"getPartitionInformation\"\n    });\n    const partitionInfo: PartitionProperties = {\n      beginningSequenceNumber: info.begin_sequence_number,\n      eventHubName: info.name,\n      lastEnqueuedOffset: info.last_enqueued_offset,\n      lastEnqueuedTimeUtc: new Date(info.last_enqueued_time_utc),\n      lastEnqueuedSequenceNumber: info.last_enqueued_sequence_number,\n      partitionId: info.partition\n    };\n    log.mgmt(\"[%s] The partition info is: %O.\", this._context.connectionId, partitionInfo);\n    return partitionInfo;\n  }\n\n  /**\n   * Closes the AMQP management session to the Event Hub for this client,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @ignore\n   * @returns\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._isMgmtRequestResponseLinkOpen()) {\n        const mgmtLink = this._mgmtReqResLink;\n        this._mgmtReqResLink = undefined;\n        clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n        await mgmtLink!.close();\n        log.mgmt(\"Successfully closed the management session.\");\n      }\n    } catch (err) {\n      const msg = `An error occurred while closing the management session: ${err}`;\n      log.error(msg);\n      throw new Error(msg);\n    }\n  }\n\n  private async _init(): Promise<void> {\n    try {\n      if (!this._isMgmtRequestResponseLinkOpen()) {\n        await this._negotiateClaim();\n        const rxopt: ReceiverOptions = {\n          source: { address: this.address },\n          name: this.replyTo,\n          target: { address: this.replyTo },\n          onSessionError: (context: EventContext) => {\n            const id = context.connection.options.id;\n            const ehError = translate(context.session!.error!);\n            log.error(\n              \"[%s] An error occurred on the session for request/response links for \" +\n                \"$management: %O\",\n              id,\n              ehError\n            );\n          }\n        };\n        const sropt: SenderOptions = { target: { address: this.address } };\n        log.mgmt(\n          \"[%s] Creating sender/receiver links on a session for $management endpoint with \" +\n            \"srOpts: %o, receiverOpts: %O.\",\n          this._context.connectionId,\n          sropt,\n          rxopt\n        );\n        this._mgmtReqResLink = await RequestResponseLink.create(\n          this._context.connection,\n          sropt,\n          rxopt\n        );\n        this._mgmtReqResLink.sender.on(SenderEvents.senderError, (context: EventContext) => {\n          const id = context.connection.options.id;\n          const ehError = translate(context.sender!.error!);\n          log.error(\"[%s] An error occurred on the $management sender link.. %O\", id, ehError);\n        });\n        this._mgmtReqResLink.receiver.on(ReceiverEvents.receiverError, (context: EventContext) => {\n          const id = context.connection.options.id;\n          const ehError = translate(context.receiver!.error!);\n          log.error(\"[%s] An error occurred on the $management receiver link.. %O\", id, ehError);\n        });\n        log.mgmt(\n          \"[%s] Created sender '%s' and receiver '%s' links for $management endpoint.\",\n          this._context.connectionId,\n          this._mgmtReqResLink.sender.name,\n          this._mgmtReqResLink.receiver.name\n        );\n        await this._ensureTokenRenewal();\n      }\n    } catch (err) {\n      err = translate(err);\n      log.error(\n        \"[%s] An error occured while establishing the $management links: %O\",\n        this._context.connectionId,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * @private\n   * Helper method to make the management request\n   * @param request The AMQP message to send\n   * @param options The options to use when sending a request over a $management link\n   */\n  private async _makeManagementRequest(\n    request: Message,\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n      requestName?: string;\n    } = {}\n  ): Promise<any> {\n    const retryOptions = options.retryOptions || {};\n    try {\n      const abortSignal: AbortSignalLike | undefined = options && options.abortSignal;\n\n      const sendOperationPromise = () =>\n        new Promise<Message>(async (resolve, reject) => {\n          let count = 0;\n\n          const retryTimeoutInMs = getRetryAttemptTimeoutInMs(options.retryOptions);\n          let timeTakenByInit = 0;\n\n          const rejectOnAbort = () => {\n            const requestName = options.requestName;\n            const desc: string =\n              `[${this._context.connectionId}] The request \"${requestName}\" ` +\n              `to has been cancelled by the user.`;\n            log.error(desc);\n            const error = new AbortError(\n              `The ${requestName ? requestName + \" \" : \"\"}operation has been cancelled by the user.`\n            );\n\n            reject(error);\n          };\n\n          if (abortSignal) {\n            if (abortSignal.aborted) {\n              return rejectOnAbort();\n            }\n          }\n\n          if (!this._isMgmtRequestResponseLinkOpen()) {\n            log.mgmt(\n              \"[%s] Acquiring lock to get the management req res link.\",\n              this._context.connectionId\n            );\n\n            const initOperationStartTime = Date.now();\n\n            const actionAfterTimeout = () => {\n              const desc: string = `The request with message_id \"${request.message_id}\" timed out. Please try again later.`;\n              const e: Error = {\n                name: \"OperationTimeoutError\",\n                message: desc\n              };\n\n              return reject(translate(e));\n            };\n\n            const waitTimer = setTimeout(actionAfterTimeout, retryTimeoutInMs);\n\n            try {\n              await defaultLock.acquire(this.managementLock, () => {\n                return this._init();\n              });\n            } catch (err) {\n              return reject(translate(err));\n            } finally {\n              clearTimeout(waitTimer);\n            }\n            timeTakenByInit = Date.now() - initOperationStartTime;\n          }\n\n          const remainingOperationTimeoutInMs = retryTimeoutInMs - timeTakenByInit;\n\n          const sendRequestOptions: SendRequestOptions = {\n            abortSignal: options.abortSignal,\n            requestName: options.requestName,\n            timeoutInMs: remainingOperationTimeoutInMs\n          };\n\n          count++;\n          if (count !== 1) {\n            // Generate a new message_id every time after the first attempt\n            request.message_id = generate_uuid();\n          } else if (!request.message_id) {\n            // Set the message_id in the first attempt only if it is not set\n            request.message_id = generate_uuid();\n          }\n\n          try {\n            const result = await this._mgmtReqResLink!.sendRequest(request, sendRequestOptions);\n            resolve(result);\n          } catch (err) {\n            err = translate(err);\n            const address =\n              this._mgmtReqResLink || this._mgmtReqResLink!.sender.address\n                ? \"address\"\n                : this._mgmtReqResLink!.sender.address;\n            log.error(\n              \"[%s] An error occurred during send on management request-response link with address \" +\n                \"'%s': %O\",\n              this._context.connectionId,\n              address,\n              err\n            );\n            reject(err);\n          }\n        });\n\n      const config: RetryConfig<Message> = {\n        operation: sendOperationPromise,\n        connectionId: this._context.connectionId,\n        operationType: RetryOperationType.management,\n        abortSignal: abortSignal,\n        retryOptions: retryOptions\n      };\n      return (await retry<Message>(config)).body;\n    } catch (err) {\n      err = translate(err);\n      log.error(\"An error occurred while making the request to $management endpoint: %O\", err);\n      throw err;\n    }\n  }\n\n  private _isMgmtRequestResponseLinkOpen(): boolean {\n    return this._mgmtReqResLink! && this._mgmtReqResLink!.isOpen();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport * as os from \"os\";\nimport { packageJsonInfo } from \"./util/constants\";\nimport { EventHubReceiver } from \"./eventHubReceiver\";\nimport { EventHubSender } from \"./eventHubSender\";\nimport {\n  Constants,\n  delay,\n  ConnectionContextBase,\n  CreateConnectionContextBaseParameters,\n  EventHubConnectionConfig,\n  TokenCredential,\n  SharedKeyCredential\n} from \"@azure/core-amqp\";\nimport { ManagementClient, ManagementClientOptions } from \"./managementClient\";\nimport { EventHubClientOptions } from \"./eventHubClient\";\nimport { Dictionary, OnAmqpEvent, EventContext, ConnectionEvents } from \"rhea-promise\";\n\n/**\n * @interface ConnectionContext\n * @internal\n * @ignore\n * Provides contextual information like the underlying amqp connection, cbs session, management session,\n * tokenProvider, senders, receivers, etc. about the EventHub client.\n */\nexport interface ConnectionContext extends ConnectionContextBase {\n  /**\n   * @property config The EventHub connection config that is created after\n   * parsing the connection string.\n   */\n  readonly config: EventHubConnectionConfig;\n  /**\n   * @property wasConnectionCloseCalled Indicates whether the close() method was\n   * called on theconnection object.\n   */\n  wasConnectionCloseCalled: boolean;\n  /**\n   * @property receivers A dictionary of the EventHub Receivers associated with this client.\n   */\n  receivers: Dictionary<EventHubReceiver>;\n  /**\n   * @property senders A dictionary of the EventHub Senders associated with this client.\n   */\n  senders: Dictionary<EventHubSender>;\n  /**\n   * @property managementSession A reference to the management session ($management endpoint) on\n   * the underlying amqp connection for the EventHub Client.\n   */\n  managementSession?: ManagementClient;\n}\n\n/**\n * @internal\n * @ignore\n */\nexport interface ConnectionContextOptions extends EventHubClientOptions {\n  managementSessionAddress?: string;\n  managementSessionAudience?: string;\n}\n\n/**\n * @internal\n * @ignore\n */\nexport namespace ConnectionContext {\n  /**\n   * @property userAgent The user agent string for the EventHubs client.\n   * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk\n   */\n  const userAgent: string = `azsdk-js-azureeventhubs/${packageJsonInfo.version} (NODE-VERSION ${\n    process.version\n  }; ${os.type()} ${os.release()})`;\n\n  export function getUserAgent(options: ConnectionContextOptions): string {\n    const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;\n    if (finalUserAgent.length > Constants.maxUserAgentLength) {\n      throw new Error(\n        `The user-agent string cannot be more than ${Constants.maxUserAgentLength} characters in length.` +\n          `The given user-agent string is: ${finalUserAgent} with length: ${finalUserAgent.length}`\n      );\n    }\n    return finalUserAgent;\n  }\n\n  export function create(\n    config: EventHubConnectionConfig,\n    tokenCredential: SharedKeyCredential | TokenCredential,\n    options?: ConnectionContextOptions\n  ): ConnectionContext {\n    if (!options) options = {};\n\n    config.webSocket = options.webSocket;\n    config.webSocketEndpointPath = \"$servicebus/websocket\";\n    config.webSocketConstructorOptions = options.webSocketConstructorOptions;\n\n    const parameters: CreateConnectionContextBaseParameters = {\n      config: config,\n      tokenCredential: tokenCredential,\n      dataTransformer: options.dataTransformer,\n      isEntityPathRequired: true,\n      connectionProperties: {\n        product: \"MSJSClient\",\n        userAgent: getUserAgent(options),\n        version: packageJsonInfo.version\n      }\n    };\n    // Let us create the base context and then add EventHub specific ConnectionContext properties.\n    const connectionContext = ConnectionContextBase.create(parameters) as ConnectionContext;\n    connectionContext.wasConnectionCloseCalled = false;\n    connectionContext.senders = {};\n    connectionContext.receivers = {};\n    const mOptions: ManagementClientOptions = {\n      address: options.managementSessionAddress,\n      audience: options.managementSessionAudience\n    };\n    connectionContext.managementSession = new ManagementClient(connectionContext, mOptions);\n\n    // Define listeners to be added to the connection object for\n    // \"connection_open\" and \"connection_error\" events.\n    const onConnectionOpen: OnAmqpEvent = (context: EventContext) => {\n      connectionContext.wasConnectionCloseCalled = false;\n      log.context(\n        \"[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.\",\n        connectionContext.connection.id,\n        connectionContext.wasConnectionCloseCalled\n      );\n    };\n\n    const disconnected: OnAmqpEvent = async (context: EventContext) => {\n      const connectionError =\n        context.connection && context.connection.error ? context.connection.error : undefined;\n      if (connectionError) {\n        log.error(\n          \"[%s] Error (context.connection.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          connectionError\n        );\n      }\n      const contextError = context.error;\n      if (contextError) {\n        log.error(\n          \"[%s] Error (context.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          contextError\n        );\n      }\n      const state: Readonly<{\n        wasConnectionCloseCalled: boolean;\n        numSenders: number;\n        numReceivers: number;\n      }> = {\n        wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,\n        numSenders: Object.keys(connectionContext.senders).length,\n        numReceivers: Object.keys(connectionContext.receivers).length\n      };\n\n      // Clear internal map maintained by rhea to avoid reconnecting of old links once the\n      // connection is back up.\n      connectionContext.connection.removeAllSessions();\n\n      // Close the cbs session to ensure all the event handlers are released.\n      await connectionContext.cbsSession.close();\n      // Close the management session to ensure all the event handlers are released.\n      await connectionContext.managementSession!.close();\n\n      // The connection should always be brought back up if the sdk did not call connection.close()\n      // and there was atleast one sender/receiver link on the connection before it went down.\n      log.error(\"[%s] state: %O\", connectionContext.connection.id, state);\n      if (!state.wasConnectionCloseCalled && (state.numSenders || state.numReceivers)) {\n        log.error(\n          \"[%s] connection.close() was not called from the sdk and there were some \" +\n            \"sender or receiver links or both. We should reconnect.\",\n          connectionContext.connection.id\n        );\n        await delay(Constants.connectionReconnectDelay);\n        // reconnect senders if any\n        for (const senderName of Object.keys(connectionContext.senders)) {\n          const sender = connectionContext.senders[senderName];\n          if (!sender.isConnecting) {\n            log.error(\n              \"[%s] calling detached on sender '%s' with address '%s'.\",\n              connectionContext.connection.id,\n              sender.name,\n              sender.address\n            );\n            sender.onDetached(connectionError || contextError).catch((err) => {\n              log.error(\n                \"[%s] An error occurred while reconnecting the sender '%s' with adress '%s' %O.\",\n                connectionContext.connection.id,\n                sender.name,\n                sender.address,\n                err\n              );\n            });\n          } else {\n            log.error(\n              \"[%s] sender '%s' with address '%s' is already reconnecting. Hence not \" +\n                \"calling detached on the sender.\",\n              connectionContext.connection.id,\n              sender.name,\n              sender.address\n            );\n          }\n        }\n        // reconnect receivers if any\n        for (const receiverName of Object.keys(connectionContext.receivers)) {\n          const receiver = connectionContext.receivers[receiverName];\n          if (!receiver.isConnecting) {\n            log.error(\n              \"[%s] calling detached on receiver '%s' with address '%s'.\",\n              connectionContext.connection.id,\n              receiver.name,\n              receiver.address\n            );\n            receiver.onDetached(connectionError || contextError).catch((err) => {\n              log.error(\n                \"[%s] An error occurred while reconnecting the receiver '%s' with adress '%s' %O.\",\n                connectionContext.connection.id,\n                receiver.name,\n                receiver.address,\n                err\n              );\n            });\n          } else {\n            log.error(\n              \"[%s] receiver '%s' with address '%s' is already reconnecting. Hence not \" +\n                \"calling detached on the receiver.\",\n              connectionContext.connection.id,\n              receiver.name,\n              receiver.address\n            );\n          }\n        }\n      }\n    };\n\n    const protocolError: OnAmqpEvent = async (context: EventContext) => {\n      if (context.connection && context.connection.error) {\n        log.error(\n          \"[%s] Error (context.connection.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        log.error(\n          \"[%s] Error (context.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    const error: OnAmqpEvent = async (context: EventContext) => {\n      if (context.connection && context.connection.error) {\n        log.error(\n          \"[%s] Error (context.connection.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        log.error(\n          \"[%s] Error (context.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    // Add listeners on the connection object.\n    connectionContext.connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);\n    connectionContext.connection.on(ConnectionEvents.disconnected, disconnected);\n    connectionContext.connection.on(ConnectionEvents.protocolError, protocolError);\n    connectionContext.connection.on(ConnectionEvents.error, error);\n\n    log.context(\"[%s] Created connection context successfully.\", connectionContext.connectionId);\n    return connectionContext;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Message, Dictionary, MessageAnnotations, DeliveryAnnotations } from \"rhea-promise\";\nimport { Constants } from \"@azure/core-amqp\";\n\n/**\n * Describes the delivery annotations.\n * @interface EventHubDeliveryAnnotations\n * @ignore\n */\nexport interface EventHubDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * @property [last_enqueued_offset] The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * @property [last_enqueued_sequence_number] The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * @property [last_enqueued_time_utc] The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * @property [runtime_info_retrieval_time_utc] The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * @property Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * Map containing message attributes that will be held in the message header.\n * @interface EventHubMessageAnnotations\n * @ignore\n */\nexport interface EventHubMessageAnnotations extends MessageAnnotations {\n  /**\n   * @property [x-opt-partition-key] Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * @property [x-opt-sequence-number] Annontation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * @property [x-opt-enqueued-time] Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * @property [x-opt-offset] Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * @property Any other annotation that can be added to the message.\n   */\n  [x: string]: any;\n}\n\n/**\n * Describes the structure of an event to be sent or received from the EventHub.\n * @interface\n * @ignore\n */\nexport interface EventDataInternal {\n  /**\n   * @property body - The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * @property [enqueuedTimeUtc] The enqueued time of the event.\n   */\n  enqueuedTimeUtc?: Date;\n  /**\n   * @property [partitionKey] If specified EventHub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey?: string | null;\n  /**\n   * @property [offset] The offset of the event.\n   */\n  offset?: number;\n  /**\n   * @property [sequenceNumber] The sequence number of the event.\n   */\n  sequenceNumber?: number;\n  /**\n   * @property [properties] The application specific properties.\n   */\n  properties?: Dictionary<any>;\n  /**\n   * @property [lastSequenceNumber] The last sequence number of the event within the partition stream of the Event Hub.\n   */\n  lastSequenceNumber?: number;\n  /**\n   * @property [lastEnqueuedOffset] The offset of the last enqueued event.\n   */\n  lastEnqueuedOffset?: string;\n  /**\n   * @property [lastEnqueuedTime] The enqueued UTC time of the last event.\n   */\n  lastEnqueuedTime?: Date;\n  /**\n   * @property [retrievalTime] The time when the runtime info was retrieved\n   */\n  retrievalTime?: Date;\n  /**\n   * @property [systemProperties] The properties set by the service.\n   */\n  systemProperties?: Dictionary<any>;\n}\n\n/**\n * Converts the AMQP message to an EventData.\n * @param msg The AMQP message that needs to be converted to EventData.\n * @ignore\n */\nexport function fromAmqpMessage(msg: Message): EventDataInternal {\n  const data: EventDataInternal = {\n    body: msg.body\n  };\n\n  if (msg.message_annotations) {\n    for (const annotationKey of Object.keys(msg.message_annotations)) {\n      switch (annotationKey) {\n        case Constants.partitionKey:\n          data.partitionKey = msg.message_annotations[annotationKey];\n          break;\n        case Constants.sequenceNumber:\n          data.sequenceNumber = msg.message_annotations[annotationKey];\n          break;\n        case Constants.enqueuedTime:\n          data.enqueuedTimeUtc = new Date(msg.message_annotations[annotationKey]);\n          break;\n        case Constants.offset:\n          data.offset = msg.message_annotations[annotationKey];\n          break;\n        default:\n          if (!data.systemProperties) {\n            data.systemProperties = {};\n          }\n          data.systemProperties[annotationKey] = msg.message_annotations[annotationKey];\n          break;\n      }\n    }\n  }\n  if (msg.application_properties) {\n    data.properties = msg.application_properties;\n  }\n  if (msg.delivery_annotations) {\n    data.lastEnqueuedOffset = msg.delivery_annotations.last_enqueued_offset;\n    data.lastSequenceNumber = msg.delivery_annotations.last_enqueued_sequence_number;\n    data.lastEnqueuedTime = new Date(msg.delivery_annotations.last_enqueued_time_utc as number);\n    data.retrievalTime = new Date(msg.delivery_annotations\n      .runtime_info_retrieval_time_utc as number);\n  }\n\n  return data;\n}\n\n/**\n * Converts an EventData object to an AMQP message.\n * @param data The EventData object that needs to be converted to an AMQP message.\n * @param partitionKey An optional key to determine the partition that this event should land in.\n * @ignore\n */\nexport function toAmqpMessage(data: EventData, partitionKey?: string): Message {\n  const msg: Message = {\n    body: data.body\n  };\n  // As per the AMQP 1.0 spec If the message-annotations or delivery-annotations section is omitted,\n  // it is equivalent to a message-annotations section containing anempty map of annotations.\n  msg.message_annotations = {};\n  if (data.properties) {\n    msg.application_properties = data.properties;\n  }\n  if (partitionKey != undefined) {\n    msg.message_annotations[Constants.partitionKey] = partitionKey;\n    // Event Hub service cannot route messages to a specific partition based on the partition key\n    // if AMQP message header is an empty object. Hence we make sure that header is always present\n    // with atleast one property. Setting durable to true, helps us achieve that.\n    msg.durable = true;\n  }\n\n  return msg;\n}\n\n/**\n * `EventData` is the interface that describes the event data to be sent to Event Hub.\n * A simple instance can be `{ body: \"your-data\" }`.\n * @interface\n */\nexport interface EventData {\n  /**\n   * @property The message body that needs to be sent.\n   */\n  body: any;\n  /**\n   * @property Set of key value pairs that can be used to set properties specific to user application.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * Describes the structure of an event received from Event Hub.\n */\nexport interface ReceivedEventData {\n  /**\n   * @property The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * @property The application specific properties.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n  /**\n   * @property The enqueued time of the event.\n   */\n  enqueuedTimeUtc: Date;\n  /**\n   * @property When specified Event Hub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey: string | null;\n  /**\n   * @property The offset of the event.\n   */\n  offset: number;\n  /**\n   * @property The sequence number of the event.\n   */\n  sequenceNumber: number;\n  /**\n   * @property The properties set by the service.\n   */\n  systemProperties?: {\n    [key: string]: any;\n  };\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"../log\";\nimport { ConnectionContext } from \"../connectionContext\";\n\n/**\n * @internal\n * @ignore\n * Logs and throws Error if the current AMQP connection is closed.\n * @param context The ConnectionContext associated with the current AMQP connection.\n */\nexport function throwErrorIfConnectionClosed(context: ConnectionContext): void {\n  if (context && context.wasConnectionCloseCalled) {\n    const errorMessage = \"The underlying AMQP connection is closed.\";\n    const error = new Error(errorMessage);\n    log.error(`[${context.connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * @ignore\n * Logs and Throws TypeError if given parameter is undefined or null\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to check\n * @param parameterValue Value of the parameter to check\n */\nexport function throwTypeErrorIfParameterMissing(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any\n): void {\n  if (parameterValue === undefined || parameterValue === null) {\n    const error = new TypeError(`Missing parameter \"${parameterName}\"`);\n    log.error(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  Span,\n  getTraceParentHeader,\n  SpanContext,\n  extractSpanContextFromTraceParentHeader\n} from \"@azure/core-tracing\";\nimport { EventData } from \"../eventData\";\n\n/**\n * @ignore\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * Populates the `EventData` with `SpanContext` info to support trace propagation.\n * Creates and returns a copy of the passed in `EventData` unless the `EventData`\n * has already been instrumented.\n * @param eventData The `EventData` to instrument.\n * @param span The `Span` containing the context to propagate tracing information.\n * @ignore\n */\nexport function instrumentEventData(eventData: EventData, span: Span): EventData {\n  if (eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]) {\n    return eventData;\n  }\n\n  // create a copy so the original isn't modified\n  eventData = { ...eventData, properties: { ...eventData.properties } };\n\n  const traceParent = getTraceParentHeader(span.context());\n  if (traceParent) {\n    eventData.properties![TRACEPARENT_PROPERTY] = traceParent;\n  }\n\n  return eventData;\n}\n\n/**\n * Extracts the `SpanContext` from an `EventData` if the context exists.\n * @param eventData An individual `EventData` object.\n */\nexport function extractSpanContextFromEventData(eventData: EventData): SpanContext | undefined {\n  if (!eventData.properties || !eventData.properties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = eventData.properties[TRACEPARENT_PROPERTY];\n  return extractSpanContextFromTraceParentHeader(diagnosticId);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { SpanContext, Span, getTracer, SpanKind } from \"@azure/core-tracing\";\n\nexport function createMessageSpan(parentSpan?: Span | SpanContext): Span {\n  const tracer = getTracer();\n  const span = tracer.startSpan(\"Azure.EventHubs.message\", {\n    kind: SpanKind.INTERNAL,\n    parent: parentSpan\n  });\n\n  return span;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventData, toAmqpMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { AmqpMessage } from \"@azure/core-amqp\";\nimport { message } from \"rhea-promise\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { Span, SpanContext } from \"@azure/core-tracing\";\nimport { instrumentEventData, TRACEPARENT_PROPERTY } from \"./diagnostics/instrumentEventData\";\nimport { createMessageSpan } from \"./diagnostics/messageSpan\";\n\n/**\n * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.\n * @param eventDataBatch The instance of `EventDataBatch` to verify.\n * @internal\n * @ignore\n */\nexport function isEventDataBatch(eventDataBatch: any): eventDataBatch is EventDataBatch {\n  return (\n    eventDataBatch &&\n    typeof eventDataBatch.tryAdd === \"function\" &&\n    typeof eventDataBatch.count === \"number\" &&\n    typeof eventDataBatch.sizeInBytes === \"number\"\n  );\n}\n\n/**\n * The set of options to configure the behavior of `tryAdd`.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface TryAddOptions {\n  /**\n   * The `Span` or `SpanContext` to use as the `parent` of any spans created while adding events.\n   */\n  parentSpan?: Span | SpanContext;\n}\n\n/**\n * A class representing a batch of events which can be passed to the `send` method of a `EventProducer` instance.\n * This batch is ensured to be under the maximum message size supported by Azure Event Hubs service.\n *\n * Use `createBatch()` method on the `EventHubProducer` to create an instance of `EventDataBatch`\n * instead of using `new EventDataBatch()`. You can specify an upper limit for the size of the batch\n * via options when calling `createBatch()`.\n *\n * Use the `tryAdd` function on the EventDataBatch to add events to the batch. This method will return\n * `false` after the upper limit is reached, therefore check the result before calling `tryAdd()` again.\n * @class\n */\nexport class EventDataBatch {\n  /**\n   * @property Describes the amqp connection context for the Client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * @property A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  private _partitionKey?: string;\n  /**\n   * @property The maximum size allowed for the batch.\n   */\n  private readonly _maxSizeInBytes: number;\n  /**\n   * @property Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * @property Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * @property Number of events in the batch.\n   */\n  private _count: number;\n  /**\n   * @property Encoded batch message.\n   */\n  private _batchMessage: Buffer | undefined;\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: SpanContext[] = [];\n\n  /**\n   * EventDataBatch should not be constructed using `new EventDataBatch()`\n   * Use the `createBatch()` method on your `EventHubProducer` instead.\n   * @constructor\n   * @internal\n   * @ignore\n   */\n  constructor(context: ConnectionContext, maxSizeInBytes: number, partitionKey?: string) {\n    this._context = context;\n    this._maxSizeInBytes = maxSizeInBytes;\n    this._partitionKey = partitionKey;\n    this._sizeInBytes = 0;\n    this._count = 0;\n  }\n\n  /**\n   * @property The partitionKey set during `EventDataBatch` creation. This value is hashed to\n   * produce a partition assignment when the producer is created without a `partitionId`\n   * @readonly\n   */\n  get partitionKey(): string | undefined {\n    return this._partitionKey;\n  }\n\n  /**\n   * @property Size of the `EventDataBatch` instance after the events added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * @property Number of events in the `EventDataBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * @property Represents the single AMQP message which is the result of encoding all the events\n   * added into the `EventDataBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  get batchMessage(): Buffer | undefined {\n    return this._batchMessage;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * @internal\n   * @ignore\n   */\n  get _messageSpanContexts(): SpanContext[] {\n    return this._spanContexts;\n  }\n  /**\n   * Tries to add an event data to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  public tryAdd(eventData: EventData, options: TryAddOptions = {}): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"eventData\", eventData);\n\n    // check if the event has already been instrumented\n    const previouslyInstrumented = Boolean(\n      eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]\n    );\n    if (!previouslyInstrumented) {\n      const messageSpan = createMessageSpan(options.parentSpan);\n      eventData = instrumentEventData(eventData, messageSpan);\n      this._spanContexts.push(messageSpan.context());\n      messageSpan.end();\n    }\n    // Convert EventData to AmqpMessage.\n    const amqpMessage = toAmqpMessage(eventData, this._partitionKey);\n    amqpMessage.body = this._context.dataTransformer.encode(eventData.body);\n\n    // Encode every amqp message and then convert every encoded message to amqp data section\n    this._encodedMessages.push(message.encode(amqpMessage));\n\n    const batchMessage: AmqpMessage = {\n      body: message.data_sections(this._encodedMessages)\n    };\n\n    if (amqpMessage.message_annotations) {\n      batchMessage.message_annotations = amqpMessage.message_annotations;\n    }\n\n    const encodedBatchMessage = message.encode(batchMessage);\n    const currentSize = encodedBatchMessage.length;\n\n    // this._batchMessage will be used for final send operation\n    if (currentSize > this._maxSizeInBytes) {\n      this._encodedMessages.pop();\n      if (\n        !previouslyInstrumented &&\n        Boolean(eventData.properties && eventData.properties[TRACEPARENT_PROPERTY])\n      ) {\n        this._spanContexts.pop();\n      }\n      return false;\n    }\n    this._batchMessage = encodedBatchMessage;\n    this._sizeInBytes = currentSize;\n    this._count++;\n    return true;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport * as log from \"./log\";\nimport {\n  AwaitableSender,\n  EventContext,\n  OnAmqpEvent,\n  AwaitableSenderOptions,\n  message,\n  AmqpError\n} from \"rhea-promise\";\nimport {\n  defaultLock,\n  retry,\n  translate,\n  AmqpMessage,\n  ErrorNameConditionMapper,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  Constants\n} from \"@azure/core-amqp\";\nimport { EventData, toAmqpMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { SendOptions, EventHubProducerOptions, getRetryAttemptTimeoutInMs } from \"./eventHubClient\";\nimport { AbortSignalLike, AbortError } from \"@azure/abort-controller\";\nimport { EventDataBatch } from \"./eventDataBatch\";\n\n/**\n * Describes the EventHubSender that will send event data to EventHub.\n * @class EventHubSender\n * @internal\n * @ignore\n */\nexport class EventHubSender extends LinkEntity {\n  /**\n   * @property senderLock The unqiue lock name per connection that is used to acquire the\n   * lock for establishing a sender link by an entity on that connection.\n   * @readonly\n   */\n  readonly senderLock: string = `sender-${uuid()}`;\n  /**\n   * @property _onAmqpError The handler function to handle errors that happen on the\n   * underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpError: OnAmqpEvent;\n  /**\n   * @property _onAmqpClose The handler function to handle \"sender_close\" event\n   * that happens on the underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpClose: OnAmqpEvent;\n  /**\n   * @property _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_error\" event.\n   * @private\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * @property _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_close\" event.\n   * @private\n   */\n  private _onSessionClose: OnAmqpEvent;\n  /**\n   * @property [_sender] The AMQP sender link.\n   * @private\n   */\n  private _sender?: AwaitableSender;\n\n  /**\n   * Creates a new EventHubSender instance.\n   * @ignore\n   * @constructor\n   * @param context The connection context.\n   * @param [partitionId] The EventHub partition id to which the sender\n   * wants to send the event data.\n   */\n  constructor(context: ConnectionContext, partitionId?: string) {\n    super(context, {\n      name: context.config.getSenderAddress(partitionId),\n      partitionId: partitionId\n    });\n    this.address = context.config.getSenderAddress(partitionId);\n    this.audience = context.config.getSenderAudience(partitionId);\n\n    this._onAmqpError = (context: EventContext) => {\n      const senderError = context.sender && context.sender.error;\n      if (senderError) {\n        const err = translate(senderError);\n        log.error(\n          \"[%s] An error occurred for sender '%s': %O.\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const err = translate(sessionError);\n        log.error(\n          \"[%s] An error occurred on the session of sender '%s': %O.\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      }\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const sender = this._sender || context.sender!;\n      const senderError = context.sender && context.sender.error;\n      if (senderError) {\n        log.error(\n          \"[%s] 'sender_close' event occurred for sender '%s' with address '%s'. \" +\n            \"The associated error is: %O\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          senderError\n        );\n      }\n      if (sender && !sender.isItselfClosed()) {\n        if (!this.isConnecting) {\n          log.error(\n            \"[%s] 'sender_close' event occurred on the sender '%s' with address '%s' \" +\n              \"and the sdk did not initiate this. The sender is not reconnecting. Hence, calling \" +\n              \"detached from the _onAmqpClose() handler.\",\n            this._context.connectionId,\n            this.name,\n            this.address\n          );\n          await this.onDetached(senderError);\n        } else {\n          log.error(\n            \"[%s] 'sender_close' event occurred on the sender '%s' with address '%s' \" +\n              \"and the sdk did not initate this. Moreover the sender is already re-connecting. \" +\n              \"Hence not calling detached from the _onAmqpClose() handler.\",\n            this._context.connectionId,\n            this.name,\n            this.address\n          );\n        }\n      } else {\n        log.error(\n          \"[%s] 'sender_close' event occurred on the sender '%s' with address '%s' \" +\n            \"because the sdk initiated it. Hence not calling detached from the _onAmqpClose\" +\n            \"() handler.\",\n          this._context.connectionId,\n          this.name,\n          this.address\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const sender = this._sender || context.sender!;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        log.error(\n          \"[%s] 'session_close' event occurred for sender '%s' with address '%s'. \" +\n            \"The associated error is: %O\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          sessionError\n        );\n      }\n      if (sender && !sender.isSessionItselfClosed()) {\n        if (!this.isConnecting) {\n          log.error(\n            \"[%s] 'session_close' event occurred on the session of sender '%s' with \" +\n              \"address '%s' and the sdk did not initiate this. Hence calling detached from the \" +\n              \"_onSessionClose() handler.\",\n            this._context.connectionId,\n            this.name,\n            this.address\n          );\n          await this.onDetached(sessionError);\n        } else {\n          log.error(\n            \"[%s] 'session_close' event occurred on the session of sender '%s' with \" +\n              \"address '%s' and the sdk did not initiate this. Moreover the sender is already \" +\n              \"re-connecting. Hence not calling detached from the _onSessionClose() handler.\",\n            this._context.connectionId,\n            this.name,\n            this.address\n          );\n        }\n      } else {\n        log.error(\n          \"[%s] 'session_close' event occurred on the session of sender '%s' with address \" +\n            \"'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose\" +\n            \"() handler.\",\n          this._context.connectionId,\n          this.name,\n          this.address\n        );\n      }\n    };\n  }\n\n  /**\n   * Will reconnect the sender link if necessary.\n   * @ignore\n   * @param [senderError] The sender error if any.\n   * @returns Promise<void>.\n   */\n  async onDetached(senderError?: AmqpError | Error): Promise<void> {\n    try {\n      const wasCloseInitiated = this._sender && this._sender.isItselfClosed();\n      // Clears the token renewal timer. Closes the link and its session if they are open.\n      // Removes the link and its session if they are present in rhea's cache.\n      await this._closeLink(this._sender);\n      // We should attempt to reopen only when the sender(sdk) did not initiate the close\n      let shouldReopen = false;\n      if (senderError && !wasCloseInitiated) {\n        const translatedError = translate(senderError);\n        if (translatedError.retryable) {\n          shouldReopen = true;\n          log.error(\n            \"[%s] close() method of Sender '%s' with address '%s' was not called. There \" +\n              \"was an accompanying error an it is retryable. This is a candidate for re-establishing \" +\n              \"the sender link.\",\n            this._context.connectionId,\n            this.name,\n            this.address\n          );\n        } else {\n          log.error(\n            \"[%s] close() method of Sender '%s' with address '%s' was not called. There \" +\n              \"was an accompanying error and it is NOT retryable. Hence NOT re-establishing \" +\n              \"the sender link.\",\n            this._context.connectionId,\n            this.name,\n            this.address\n          );\n        }\n      } else if (!wasCloseInitiated) {\n        shouldReopen = true;\n        log.error(\n          \"[%s] close() method of Sender '%s' with address '%s' was not called. There \" +\n            \"was no accompanying error as well. This is a candidate for re-establishing \" +\n            \"the sender link.\",\n          this._context.connectionId,\n          this.name,\n          this.address\n        );\n      } else {\n        const state: any = {\n          wasCloseInitiated: wasCloseInitiated,\n          senderError: senderError,\n          _sender: this._sender\n        };\n        log.error(\n          \"[%s] Something went wrong. State of sender '%s' with address '%s' is: %O\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          state\n        );\n      }\n      if (shouldReopen) {\n        await defaultLock.acquire(this.senderLock, () => {\n          const options: AwaitableSenderOptions = this._createSenderOptions(\n            Constants.defaultOperationTimeoutInMs,\n            true\n          );\n          // shall retry forever at an interval of 15 seconds if the error is a retryable error\n          // else bail out when the error is not retryable or the oepration succeeds.\n          const config: RetryConfig<void> = {\n            operation: () => this._init(options),\n            connectionId: this._context.connectionId,\n            operationType: RetryOperationType.senderLink,\n            connectionHost: this._context.config.host,\n            retryOptions: {\n              maxRetries: Constants.defaultMaxRetriesForConnection,\n              retryDelayInMs: 15000\n            }\n          };\n          return retry<void>(config);\n        });\n      }\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while processing onDetached() of Sender '%s' with address \" +\n          \"'%s': %O\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        err\n      );\n    }\n  }\n\n  /**\n   * Deletes the sender fromt the context. Clears the token renewal timer. Closes the sender link.\n   * @ignore\n   * @returns Promise<void>\n   */\n  async close(): Promise<void> {\n    if (this._sender) {\n      log.sender(\n        \"[%s] Closing the Sender for the entity '%s'.\",\n        this._context.connectionId,\n        this._context.config.entityPath\n      );\n      const senderLink = this._sender;\n      this._deleteFromCache();\n      await this._closeLink(senderLink);\n    }\n  }\n\n  /**\n   * Determines whether the AMQP sender link is open. If open then returns true else returns false.\n   * @ignore\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result: boolean = this._sender! && this._sender!.isOpen();\n    log.error(\n      \"[%s] Sender '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n  /**\n   * Returns maximum message size on the AMQP sender link.\n   * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   * @returns Promise<number>\n   * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.\n   */\n  async getMaxMessageSize(\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n    } = {}\n  ): Promise<number> {\n    const abortSignal = options.abortSignal;\n    const retryOptions = options.retryOptions || {};\n    if (this.isOpen()) {\n      return this._sender!.maxMessageSize;\n    }\n    return new Promise<number>(async (resolve, reject) => {\n      const rejectOnAbort = () => {\n        const desc: string = `[${this._context.connectionId}] The create batch operation has been cancelled by the user.`;\n        log.error(desc);\n        const error = new AbortError(`The create batch operation has been cancelled by the user.`);\n        reject(error);\n      };\n\n      const onAbort = () => {\n        if (abortSignal) {\n          abortSignal.removeEventListener(\"abort\", onAbort);\n        }\n        rejectOnAbort();\n      };\n\n      if (abortSignal) {\n        // the aborter may have been triggered between request attempts\n        // so check if it was triggered and reject if needed.\n        if (abortSignal.aborted) {\n          return rejectOnAbort();\n        }\n        abortSignal.addEventListener(\"abort\", onAbort);\n      }\n      try {\n        log.sender(\n          \"Acquiring lock %s for initializing the session, sender and \" +\n            \"possibly the connection.\",\n          this.senderLock\n        );\n        const senderOptions = this._createSenderOptions(Constants.defaultOperationTimeoutInMs);\n        await defaultLock.acquire(this.senderLock, () => {\n          const config: RetryConfig<void> = {\n            operation: () => this._init(senderOptions),\n            connectionId: this._context.connectionId,\n            operationType: RetryOperationType.senderLink,\n            abortSignal: abortSignal,\n            retryOptions: retryOptions\n          };\n\n          return retry<void>(config);\n        });\n        resolve(this._sender!.maxMessageSize);\n      } catch (err) {\n        log.error(\n          \"[%s] An error occurred while creating the sender %s\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n        reject(err);\n      } finally {\n        if (abortSignal) {\n          abortSignal.removeEventListener(\"abort\", onAbort);\n        }\n      }\n    });\n  }\n\n  /**\n   * Send a batch of EventData to the EventHub. The \"message_annotations\",\n   * \"application_properties\" and \"properties\" of the first message will be set as that\n   * of the envelope (batch message).\n   * @ignore\n   * @param events  An array of EventData objects to be sent in a Batch message.\n   * @param options Options to control the way the events are batched along with request options\n   * @return Promise<void>\n   */\n  async send(\n    events: EventData[] | EventDataBatch,\n    options?: SendOptions & EventHubProducerOptions\n  ): Promise<void> {\n    try {\n      // throw an error if partition key and partition id are both defined\n      if (\n        options &&\n        typeof options.partitionKey === \"string\" &&\n        typeof options.partitionId === \"string\"\n      ) {\n        const error = new Error(\n          \"Partition key is not supported when using producers that were created using a partition id.\"\n        );\n        log.error(\n          \"[%s] Partition key is not supported when using producers that were created using a partition id. %O\",\n          this._context.connectionId,\n          error\n        );\n        throw error;\n      }\n\n      // throw an error if partition key is different than the one provided in the options.\n      if (events instanceof EventDataBatch && options && options.partitionKey) {\n        const error = new Error(\n          \"Partition key is not supported when sending a batch message. Pass the partition key when creating the batch message instead.\"\n        );\n        log.error(\n          \"[%s] Partition key is not supported when sending a batch message. Pass the partition key when creating the batch message instead. %O\",\n          this._context.connectionId,\n          error\n        );\n        throw error;\n      }\n\n      log.sender(\n        \"[%s] Sender '%s', trying to send EventData[].\",\n        this._context.connectionId,\n        this.name\n      );\n\n      let encodedBatchMessage: Buffer | undefined;\n      if (events instanceof EventDataBatch) {\n        encodedBatchMessage = events.batchMessage!;\n      } else {\n        const partitionKey = (options && options.partitionKey) || undefined;\n        const messages: AmqpMessage[] = [];\n        // Convert EventData to AmqpMessage.\n        for (let i = 0; i < events.length; i++) {\n          const message = toAmqpMessage(events[i], partitionKey);\n          message.body = this._context.dataTransformer.encode(events[i].body);\n          messages[i] = message;\n        }\n        // Encode every amqp message and then convert every encoded message to amqp data section\n        const batchMessage: AmqpMessage = {\n          body: message.data_sections(messages.map(message.encode))\n        };\n\n        // Set message_annotations of the first message as\n        // that of the envelope (batch message).\n        if (messages[0].message_annotations) {\n          batchMessage.message_annotations = messages[0].message_annotations;\n        }\n\n        // Finally encode the envelope (batch message).\n        encodedBatchMessage = message.encode(batchMessage);\n      }\n      log.sender(\n        \"[%s] Sender '%s', sending encoded batch message.\",\n        this._context.connectionId,\n        this.name,\n        encodedBatchMessage\n      );\n      return await this._trySendBatch(encodedBatchMessage, options);\n    } catch (err) {\n      log.error(\"An error occurred while sending the batch message %O\", err);\n      throw err;\n    }\n  }\n\n  private _deleteFromCache(): void {\n    this._sender = undefined;\n    delete this._context.senders[this.name];\n    log.error(\n      \"[%s] Deleted the sender '%s' with address '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name,\n      this.address\n    );\n  }\n\n  private _createSenderOptions(timeoutInMs: number, newName?: boolean): AwaitableSenderOptions {\n    if (newName) this.name = `${uuid()}`;\n    const srOptions: AwaitableSenderOptions = {\n      name: this.name,\n      target: {\n        address: this.address\n      },\n      onError: this._onAmqpError,\n      onClose: this._onAmqpClose,\n      onSessionError: this._onSessionError,\n      onSessionClose: this._onSessionClose,\n      sendTimeoutInSeconds: timeoutInMs / 1000\n    };\n    log.sender(\"Creating sender with options: %O\", srOptions);\n    return srOptions;\n  }\n\n  /**\n   * Tries to send the message to EventHub if there is enough credit to send them\n   * and the circular buffer has available space to settle the message after sending them.\n   *\n   * We have implemented a synchronous send over here in the sense that we shall be waiting\n   * for the message to be accepted or rejected and accordingly resolve or reject the promise.\n   * @ignore\n   * @param message The message to be sent to EventHub.\n   * @returns Promise<void>\n   */\n  private _trySendBatch(\n    message: AmqpMessage | Buffer,\n    options: SendOptions & EventHubProducerOptions = {}\n  ): Promise<void> {\n    const abortSignal: AbortSignalLike | undefined = options.abortSignal;\n    const retryOptions = options.retryOptions || {};\n    const sendEventPromise = () =>\n      new Promise<void>(async (resolve, reject) => {\n        const rejectOnAbort = () => {\n          const desc: string =\n            `[${this._context.connectionId}] The send operation on the Sender \"${this.name}\" with ` +\n            `address \"${this.address}\" has been cancelled by the user.`;\n          log.error(desc);\n          return reject(new AbortError(\"The send operation has been cancelled by the user.\"));\n        };\n\n        if (abortSignal && abortSignal.aborted) {\n          // operation has been cancelled, so exit quickly\n          return rejectOnAbort();\n        }\n\n        const removeListeners = (): void => {\n          clearTimeout(waitTimer);\n          if (abortSignal) {\n            abortSignal.removeEventListener(\"abort\", onAborted);\n          }\n        };\n\n        const onAborted = () => {\n          removeListeners();\n          return rejectOnAbort();\n        };\n\n        if (abortSignal) {\n          abortSignal.addEventListener(\"abort\", onAborted);\n        }\n\n        const actionAfterTimeout = () => {\n          removeListeners();\n          const desc: string =\n            `[${this._context.connectionId}] Sender \"${this.name}\" with ` +\n            `address \"${this.address}\", was not able to send the message right now, due ` +\n            `to operation timeout.`;\n          log.error(desc);\n          const e: Error = {\n            name: \"OperationTimeoutError\",\n            message: desc\n          };\n          return reject(translate(e));\n        };\n\n        const waitTimer = setTimeout(\n          actionAfterTimeout,\n          getRetryAttemptTimeoutInMs(options.retryOptions)\n        );\n\n        if (!this.isOpen()) {\n          log.sender(\n            \"Acquiring lock %s for initializing the session, sender and \" +\n              \"possibly the connection.\",\n            this.senderLock\n          );\n\n          try {\n            const senderOptions = this._createSenderOptions(\n              getRetryAttemptTimeoutInMs(options.retryOptions)\n            );\n            await defaultLock.acquire(this.senderLock, () => {\n              return this._init(senderOptions);\n            });\n          } catch (err) {\n            removeListeners();\n            err = translate(err);\n            log.error(\n              \"[%s] An error occurred while creating the sender %s\",\n              this._context.connectionId,\n              this.name,\n              err\n            );\n            return reject(err);\n          }\n        }\n\n        log.sender(\n          \"[%s] Sender '%s', credit: %d available: %d\",\n          this._context.connectionId,\n          this.name,\n          this._sender!.credit,\n          this._sender!.session.outgoing.available()\n        );\n        if (this._sender!.sendable()) {\n          log.sender(\n            \"[%s] Sender '%s', sending message with id '%s'.\",\n            this._context.connectionId,\n            this.name\n          );\n\n          try {\n            const delivery = await this._sender!.send(message, undefined, 0x80013700);\n            log.sender(\n              \"[%s] Sender '%s', sent message with delivery id: %d\",\n              this._context.connectionId,\n              this.name,\n              delivery.id\n            );\n            return resolve();\n          } catch (err) {\n            err = translate(err.innerError || err);\n            log.error(\n              \"[%s] An error occurred while sending the message\",\n              this._context.connectionId,\n              err\n            );\n            return reject(err);\n          } finally {\n            removeListeners();\n          }\n        } else {\n          // let us retry to send the message after some time.\n          const msg =\n            `[${this._context.connectionId}] Sender \"${this.name}\", ` +\n            `cannot send the message right now. Please try later.`;\n          log.error(msg);\n          const amqpError: AmqpError = {\n            condition: ErrorNameConditionMapper.SenderBusyError,\n            description: msg\n          };\n          reject(translate(amqpError));\n        }\n      });\n\n    const config: RetryConfig<void> = {\n      operation: sendEventPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.sendMessage,\n      abortSignal: abortSignal,\n      retryOptions: retryOptions\n    };\n    return retry<void>(config);\n  }\n\n  /**\n   * Initializes the sender session on the connection.\n   * @ignore\n   * @returns\n   */\n  private async _init(options: AwaitableSenderOptions): Promise<void> {\n    try {\n      // isOpen isConnecting  Should establish\n      // true     false          No\n      // true     true           No\n      // false    true           No\n      // false    false          Yes\n      if (!this.isOpen() && !this.isConnecting) {\n        log.error(\n          \"[%s] The sender '%s' with address '%s' is not open and is not currently \" +\n            \"establishing itself. Hence let's try to connect.\",\n          this._context.connectionId,\n          this.name,\n          this.address\n        );\n        this.isConnecting = true;\n        await this._negotiateClaim();\n        log.error(\"[%s] Trying to create sender '%s'...\", this._context.connectionId, this.name);\n\n        this._sender = await this._context.connection.createAwaitableSender(options);\n        this.isConnecting = false;\n        log.error(\n          \"[%s] Sender '%s' with address '%s' has established itself.\",\n          this._context.connectionId,\n          this.name,\n          this.address\n        );\n        this._sender.setMaxListeners(1000);\n        log.error(\n          \"[%s] Promise to create the sender resolved. Created sender with name: %s\",\n          this._context.connectionId,\n          this.name\n        );\n        log.error(\n          \"[%s] Sender '%s' created with sender options: %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        // It is possible for someone to close the sender and then start it again.\n        // Thus make sure that the sender is present in the client cache.\n        if (!this._context.senders[this.name]) this._context.senders[this.name] = this;\n        await this._ensureTokenRenewal();\n      } else {\n        log.error(\n          \"[%s] The sender '%s' with address '%s' is open -> %s and is connecting \" +\n            \"-> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err) {\n      this.isConnecting = false;\n      err = translate(err);\n      log.error(\n        \"[%s] An error occurred while creating the sender %s\",\n        this._context.connectionId,\n        this.name,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Creates a new sender to the given event hub, and optionally to a given partition if it is\n   * not present in the context or returns the one present in the context.\n   * @ignore\n   * @static\n   * @param [partitionId] Partition ID to which it will send event data.\n   * @returns\n   */\n  static create(context: ConnectionContext, partitionId?: string): EventHubSender {\n    const ehSender: EventHubSender = new EventHubSender(context, partitionId);\n    if (!context.senders[ehSender.name]) {\n      context.senders[ehSender.name] = ehSender;\n    }\n    return context.senders[ehSender.name];\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventData } from \"./eventData\";\nimport { EventHubSender } from \"./eventHubSender\";\nimport { EventHubProducerOptions, SendOptions, BatchOptions } from \"./eventHubClient\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport * as log from \"./log\";\nimport { throwErrorIfConnectionClosed, throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { EventDataBatch, isEventDataBatch } from \"./eventDataBatch\";\nimport { SpanContext, Span, getTracer, SpanKind, CanonicalCode } from \"@azure/core-tracing\";\nimport { instrumentEventData, TRACEPARENT_PROPERTY } from \"./diagnostics/instrumentEventData\";\nimport { createMessageSpan } from \"./diagnostics/messageSpan\";\n\n/**\n * A producer responsible for sending events to an Event Hub.\n * To create a producer use the `createProducer()` method on your `EventHubClient`.\n * You can pass the below in the `options` when creating a producer.\n * - `partitionId`  : The identifier of the partition that the producer can be bound to.\n * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * If `partitionId` is specified when creating a producer, all event data sent using the producer\n * will be sent to the specified partition.\n * Otherwise, they are automatically routed to an available partition by the Event Hubs service.\n *\n * Automatic routing of partitions is recommended because:\n *  - The sending of events will be highly available.\n *  - The event data will be evenly distributed among all available partitions.\n *\n * @class\n */\nexport class EventHubProducer {\n  /**\n   * @property Describes the amqp connection context for the Client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * @property Denotes if close() was called on this sender\n   */\n  private _isClosed: boolean = false;\n\n  private _senderOptions: EventHubProducerOptions;\n\n  private _eventHubSender: EventHubSender | undefined;\n\n  private _eventHubName: string;\n  private _endpoint: string;\n\n  /**\n   * @property Returns `true` if either the producer or the client that created it has been closed.\n   * @readonly\n   */\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  /**\n   * EventHubProducer should not be constructed using `new EventHubProduer()`\n   * Use the `createProducer()` method on your `EventHubClient` instead.\n   * @private\n   * @constructor\n   * @internal\n   * @ignore\n   */\n  constructor(\n    eventHubName: string,\n    endpoint: string,\n    context: ConnectionContext,\n    options?: EventHubProducerOptions\n  ) {\n    this._context = context;\n    this._senderOptions = options || {};\n    const partitionId =\n      this._senderOptions.partitionId != undefined\n        ? String(this._senderOptions.partitionId)\n        : undefined;\n    this._eventHubSender = EventHubSender.create(this._context, partitionId);\n    this._eventHubName = eventHubName;\n    this._endpoint = endpoint;\n  }\n\n  /**\n   * Creates an instance of `EventDataBatch` to which one can add events until the maximum supported size is reached.\n   * The batch can be passed to the `send()` method of the `EventHubProducer` to be sent to Azure Event Hubs.\n   * @param options  A set of options to configure the behavior of the batch.\n   * - `partitionKey`  : A value that is hashed to produce a partition assignment.\n   * Not applicable if the `EventHubProducer` was created using a `partitionId`.\n   * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   * - `abortSignal`   : A signal the request to cancel the send operation.\n   * @returns Promise<EventDataBatch>\n   */\n  async createBatch(options?: BatchOptions): Promise<EventDataBatch> {\n    this._throwIfSenderOrConnectionClosed();\n    if (!options) {\n      options = {};\n    }\n    // throw an error if partition key and partition id are both defined\n    if (\n      typeof options.partitionKey === \"string\" &&\n      typeof this._senderOptions.partitionId === \"string\"\n    ) {\n      const error = new Error(\n        \"Creating a batch with partition key is not supported when using producers that were created using a partition id.\"\n      );\n      log.error(\n        \"[%s] Creating a batch with partition key is not supported when using producers that were created using a partition id. %O\",\n        this._context.connectionId,\n        error\n      );\n      throw error;\n    }\n\n    let maxMessageSize = await this._eventHubSender!.getMaxMessageSize({\n      retryOptions: this._senderOptions.retryOptions,\n      abortSignal: options.abortSignal\n    });\n    if (options.maxSizeInBytes) {\n      if (options.maxSizeInBytes > maxMessageSize) {\n        const error = new Error(\n          `Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`\n        );\n        log.error(\n          `[${this._context.connectionId}] Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link. ${error}`\n        );\n        throw error;\n      }\n      maxMessageSize = options.maxSizeInBytes;\n    }\n    return new EventDataBatch(this._context, maxMessageSize, options.partitionKey);\n  }\n\n  /**\n   * Send one or more of events to the associated Event Hub.\n   *\n   * @param eventData  An individual `EventData` object, or an array of `EventData` objects or an\n   * instance of `EventDataBatch`.\n   * @param options The set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `partitionKey` : A value that is hashed to produce a partition assignment.\n   * Not applicable if the `EventHubProducer` was created using a `partitionId`.\n   * - `abortSignal`  : A signal the request to cancel the send operation.\n   *\n   * @returns Promise<void>\n   * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.\n   * @throws {MessagingError} Thrown if an error is encountered while sending a message.\n   * @throws {TypeError} Thrown if a required parameter is missing.\n   * @throws {Error} Thrown if the underlying connection or sender has been closed.\n   * @throws {Error} Thrown if a partitionKey is provided when the producer was created with a partitionId.\n   * @throws {Error} Thrown if batch was created with partitionKey different than the one provided in the options.\n   * Create a new producer using the EventHubClient createProducer method.\n   */\n  async send(\n    eventData: EventData | EventData[] | EventDataBatch,\n    options: SendOptions = {}\n  ): Promise<void> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"eventData\", eventData);\n    if (Array.isArray(eventData) && eventData.length === 0) {\n      log.error(`[${this._context.connectionId}] Empty array was passed. No events to send.`);\n      return;\n    }\n    if (eventData instanceof EventDataBatch && eventData.count === 0) {\n      log.error(`[${this._context.connectionId}] Empty batch was passsed. No events to send.`);\n      return;\n    }\n    if (!Array.isArray(eventData) && !(eventData instanceof EventDataBatch)) {\n      eventData = [eventData];\n    }\n\n    // link message span contexts\n    let spanContextsToLink: SpanContext[] = [];\n    if (Array.isArray(eventData)) {\n      for (let i = 0; i < eventData.length; i++) {\n        const event = eventData[i];\n        if (!event.properties || !event.properties[TRACEPARENT_PROPERTY]) {\n          const messageSpan = createMessageSpan(options.parentSpan);\n          // since these message spans are created from same context as the send span,\n          // these message spans don't need to be linked.\n          // replace the original event with the instrumented one\n          eventData[i] = instrumentEventData(eventData[i], messageSpan);\n          messageSpan.end();\n        }\n      }\n    } else if (isEventDataBatch(eventData)) {\n      spanContextsToLink = eventData._messageSpanContexts;\n    }\n\n    const sendSpan = this._createSendSpan(options.parentSpan);\n    for (const spanContext of spanContextsToLink) {\n      sendSpan.addLink(spanContext);\n    }\n\n    try {\n      const result = await this._eventHubSender!.send(eventData, {\n        ...this._senderOptions,\n        ...options\n      });\n      sendSpan.setStatus({ code: CanonicalCode.OK });\n      return result;\n    } catch (err) {\n      sendSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      sendSpan.end();\n    }\n  }\n\n  /**\n   * Closes the underlying AMQP sender link.\n   * Once closed, the producer cannot be used for any further operations.\n   * Use the `createProducer` function on the EventHubClient to instantiate a new EventHubProducer.\n   *\n   * @returns\n   * @throws {Error} Thrown if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._context.connection && this._context.connection.isOpen() && this._eventHubSender) {\n        await this._eventHubSender.close();\n        this._eventHubSender = undefined;\n      }\n      this._isClosed = true;\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while closing the Sender for %s: %O\",\n        this._context.connectionId,\n        this._context.config.entityPath,\n        err\n      );\n      throw err;\n    }\n  }\n\n  private _createSendSpan(parentSpan?: Span | SpanContext): Span {\n    const tracer = getTracer();\n    const span = tracer.startSpan(\"Azure.EventHubs.send\", {\n      kind: SpanKind.PRODUCER,\n      parent: parentSpan\n    });\n\n    span.setAttribute(\"component\", \"eventhubs\");\n    span.setAttribute(\"message_bus.destination\", this._eventHubName);\n    span.setAttribute(\"peer.address\", this._endpoint);\n\n    return span;\n  }\n\n  private _throwIfSenderOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (this.isClosed) {\n      const errorMessage =\n        `The EventHubProducer for \"${this._context.config.entityPath}\" has been closed and can no longer be used. ` +\n        `Please create a new EventHubProducer using the \"createProducer\" function on the EventHubClient.`;\n      const error = new Error(errorMessage);\n      log.error(`[${this._context.connectionId}] %O`, error);\n      throw error;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { translate, Constants, ErrorNameConditionMapper } from \"@azure/core-amqp\";\n\n/**\n * Describes the options that can be set while creating an EventPosition.\n * @internal\n * @ignore\n * @interface EventPositionOptions\n */\nexport interface EventPositionOptions {\n  /**\n   * @property The offset of the event at the position. It can be undefined\n   * if the position is just created from a sequence number or an enqueued time.\n   */\n  offset?: number | \"@latest\";\n  /**\n   * @property Indicates if the current event at the specified offset is\n   * included or not. It is only applicable if offset is set. Default value: false.\n   */\n  isInclusive?: boolean;\n  /**\n   * @property The enqueued time of the event at the position. It can be undefined\n   * if the position is just created from a sequence number or an offset.\n   */\n  enqueuedTime?: Date | number;\n\n  /**\n   * @property The sequence number of the event at the position. It can be undefined\n   * if the position is just created from an enqueued time or an offset.\n   */\n  sequenceNumber?: number;\n}\n\n/**\n * Represents the position of an event in an Event Hub partition, typically used in the creation of\n * an `EventHubConsumer` to specify the position in the partition to begin receiving events from.\n *\n * Make use of the below static helpers to create an instance of `EventPosition`\n * - `fromOffset()`\n * - `fromSequenceNumber()`\n * - `fromEnqueuedTime()`\n * - `earliest()`\n * - `latest()`\n * @class\n */\nexport class EventPosition {\n  /**\n   * @property The token that represents the beginning event in the stream of a partition: `-1`.\n   * @static\n   * @readonly\n   * @ignore\n   */\n  private static readonly startOfStream: number = -1;\n\n  /**\n   * @property The token that represents the last event in the stream of a partition: `\"@latest\"`.\n   * @static\n   * @readonly\n   * @ignore\n   */\n  private static readonly endOfStream = \"@latest\";\n  /**\n   * @property The offset of the event identified by this position.\n   * Expected to be undefined if the position is just created from a sequence number or an enqueued time.\n   *\n   * The offset is the relative position for an event in the context of the partition.\n   * The offset should not be considered a stable value.\n   * The same offset may refer to a different event as events reach the age limit for\n   * retention and are no longer visible within the partition.\n   */\n  offset?: number | \"@latest\";\n  /**\n   * @property Indicates if the specified offset is inclusive of the event which it identifies.\n   * This information is only relevent if the event position was identified by an offset or sequence number.\n   * Default value: `false`.\n   */\n  isInclusive: boolean = false;\n  /**\n   * @property The enqueued time of the event identified by this position.\n   * Expected to be undefined if the position is just created from a sequence number or an offset.\n   */\n  enqueuedTime?: Date | number;\n\n  /**\n   * @property The sequence number of the event identified by this poistion.\n   * Expected to be undefined if the position is just created from an offset or enqueued time.\n   */\n  sequenceNumber?: number;\n\n  /**\n   * Instead of constructing an event position using `new Event Position()`, make use of the below static helpers\n   * - `fromOffset()`\n   * - `fromSequenceNumber()`\n   * - `fromEnqueuedTime()`\n   * - `earliest()`\n   * - `latest()`\n   *\n   * @constructor\n   * @internal\n   * @ignore\n   * @param options\n   */\n  constructor(options?: EventPositionOptions) {\n    if (options) {\n      this.offset = options.offset;\n      this.enqueuedTime = options.enqueuedTime;\n      this.sequenceNumber = options.sequenceNumber;\n      this.isInclusive = options.isInclusive || false;\n    }\n  }\n\n  /**\n   * Gets an instance of `EventPosition` corresponding to the event in the partition at the provided offset.\n   *\n   * @param offset The offset of an event with respect to its relative position in the partition.\n   * @param isInclusive If true, the specified event is included;\n   * otherwise the next event is returned.\n   * Default: `false`.\n   * @returns EventPosition\n   */\n  static fromOffset(offset: number, isInclusive?: boolean): EventPosition {\n    if (typeof offset !== \"number\" && typeof offset !== \"string\") {\n      throw new Error(`Invalid offset \"${offset}\" provided to \"fromOffset\" method.`);\n    }\n    return new EventPosition({ offset: offset, isInclusive: isInclusive });\n  }\n\n  /**\n   * Gets an instance of `EventPosition` corresponding to the event in the partition having a specified sequence number associated with it.\n   *\n   * @param sequenceNumber The sequence number assigned to an event when it was enqueued in the partition.\n   * @param isInclusive If true, event with the `sequenceNumber` is included;\n   * otherwise the next event in sequence will be received.\n   * Default `false`.\n   * @returns EventPosition\n   */\n  static fromSequenceNumber(sequenceNumber: number, isInclusive?: boolean): EventPosition {\n    if (sequenceNumber == undefined) {\n      throw new Error('Missing parameter \"sequenceNumber\"');\n    }\n    if (typeof sequenceNumber !== \"number\") {\n      throw new Error('The parameter \"sequenceNumber\" should be of type \"number\"');\n    }\n    return new EventPosition({ sequenceNumber: sequenceNumber, isInclusive: isInclusive });\n  }\n\n  /**\n   * Gets an instance of `EventPosition` corresponding to a specific date and time within the partition to begin seeking an event;\n   * the event enqueued after the requested `enqueuedTime` will become the current position.\n   *\n   * @param enqueuedTime The date and time, in UTC, from which the next available event should be chosen.\n   * @returns EventPosition\n   */\n  static fromEnqueuedTime(enqueuedTime: Date | number): EventPosition {\n    if (typeof enqueuedTime !== \"number\" && !(enqueuedTime instanceof Date)) {\n      throw new Error(\n        `Invalid enqueuedTime \"${enqueuedTime}\" provided to \"fromEnqueuedTime\" method.`\n      );\n    }\n    return new EventPosition({ enqueuedTime: enqueuedTime });\n  }\n\n  /**\n   * Gets an instance of `EventPosition` corresponding to the location of the the first event present in the partition.\n   * Use this position to begin receiving from the first event that was enqueued in the partition\n   * which has not expired due to the retention policy.\n   * @returns EventPosition\n   */\n\n  static earliest(): EventPosition {\n    return EventPosition.fromOffset(EventPosition.startOfStream);\n  }\n\n  /**\n   * Gets an instance of `EventPosition` corresponding to the end of the partition, where no more events are currently enqueued.\n   * Use this position to begin receiving from the next event to be enqueued in the partion after an ``EventHubConsumer``\n   * is created with this position.\n   * @returns EventPosition\n   */\n\n  static latest(): EventPosition {\n    return new EventPosition({ offset: EventPosition.endOfStream });\n  }\n}\n\n/**\n * @internal\n * @ignore\n * Gets the expression to be set as the filter clause when creating the receiver\n * @return {string} filterExpression\n */\nexport function getEventPositionFilter(eventPosition: EventPosition): string {\n  let result;\n  // order of preference\n  if (eventPosition.offset != undefined) {\n    result = eventPosition.isInclusive\n      ? `${Constants.offsetAnnotation} >= '${eventPosition.offset}'`\n      : `${Constants.offsetAnnotation} > '${eventPosition.offset}'`;\n  } else if (eventPosition.sequenceNumber != undefined) {\n    result = eventPosition.isInclusive\n      ? `${Constants.sequenceNumberAnnotation} >= '${eventPosition.sequenceNumber}'`\n      : `${Constants.sequenceNumberAnnotation} > '${eventPosition.sequenceNumber}'`;\n  } else if (eventPosition.enqueuedTime != undefined) {\n    const time =\n      eventPosition.enqueuedTime instanceof Date\n        ? eventPosition.enqueuedTime.getTime()\n        : eventPosition.enqueuedTime;\n    result = `${Constants.enqueuedTimeAnnotation} > '${time}'`;\n  }\n\n  if (!result) {\n    throw translate({\n      condition: ErrorNameConditionMapper.ArgumentError,\n      description: \"No starting position was set in the EventPosition.\"\n    });\n  }\n  return result;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport * as log from \"./log\";\nimport {\n  Receiver,\n  OnAmqpEvent,\n  EventContext,\n  ReceiverOptions as RheaReceiverOptions,\n  types,\n  AmqpError\n} from \"rhea-promise\";\nimport {\n  delay,\n  translate,\n  Constants,\n  MessagingError,\n  retry,\n  RetryOperationType,\n  RetryConfig\n} from \"@azure/core-amqp\";\nimport { ReceivedEventData, EventDataInternal, fromAmqpMessage } from \"./eventData\";\nimport { EventHubConsumerOptions } from \"./eventHubClient\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { EventPosition, getEventPositionFilter } from \"./eventPosition\";\nimport { AbortSignalLike, AbortError } from \"@azure/abort-controller\";\n\n/**\n * @ignore\n */\ninterface CreateReceiverOptions {\n  onMessage: OnAmqpEvent;\n  onError: OnAmqpEvent;\n  onClose: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSessionClose: OnAmqpEvent;\n  newName?: boolean;\n  eventPosition?: EventPosition;\n}\n\n/**\n * A set of information about the last enqueued event of a partition, as observed by the consumer as\n * events are received from the Event Hubs service\n * @interface LastEnqueuedEventInfo\n */\nexport interface LastEnqueuedEventInfo {\n  /**\n   * @property The sequence number of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  sequenceNumber?: number;\n  /**\n   * @property The date and time, in UTC, that the last event was enqueued into the Event Hub partition from\n   * which this event was received.\n   */\n  enqueuedTime?: Date;\n  /**\n   * @property The offset of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  offset?: string;\n  /**\n   * @property The date and time, in UTC, that the last event was retrieved from the Event Hub partition.\n   */\n  retrievalTime?: Date;\n}\n\n/**\n * Describes the message handler signature.\n */\nexport type OnMessage = (eventData: ReceivedEventData) => void;\n\n/**\n * Describes the error handler signature.\n */\nexport type OnError = (error: MessagingError | Error) => void;\n\n/**\n * Describes the abort handler signature.\n */\nexport type OnAbort = () => void;\n\n/**\n * Describes the EventHubReceiver that will receive event data from EventHub.\n * @class EventHubReceiver\n * @internal\n * @ignore\n */\nexport class EventHubReceiver extends LinkEntity {\n  /**\n   * @property consumerGroup The EventHub consumer group from which the receiver will\n   * receive messages. (Default: \"default\").\n   */\n  consumerGroup: string;\n  /**\n   * @property runtimeInfo The receiver runtime info.\n   */\n  runtimeInfo: LastEnqueuedEventInfo;\n  /**\n   * @property [ownerLevel] The Receiver ownerLevel.\n   */\n  ownerLevel?: number;\n  /**\n   * @property eventPosition The event position in the partition at which to start receiving messages.\n   */\n  eventPosition: EventPosition;\n  /**\n   * @property [options] Optional properties that can be set while creating\n   * the EventHubConsumer.\n   */\n  options: EventHubConsumerOptions;\n  /**\n   * @property [_receiver] The RHEA AMQP-based receiver link.\n   * @private\n   */\n  private _receiver?: Receiver;\n  /**\n   * @property _onMessage The message handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   * @private\n   */\n  private _onMessage?: OnMessage;\n  /**\n   * @property _OnError The error handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   * @private\n   */\n  private _onError?: OnError;\n  /**\n   * @property _onAbort The abort handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   * @private\n   */\n  private _onAbort?: OnAbort;\n  /**\n   * @property _abortSignal An implementation of the `AbortSignalLike` interface to signal cancelling a receiver operation.\n   * @private\n   */\n  private _abortSignal?: AbortSignalLike;\n  /**\n   * @property _checkpoint The sequence number of the most recently received AMQP message.\n   * @private\n   */\n  private _checkpoint: number = -1;\n  /**\n   * @property _internalQueue A queue of events that were received from the AMQP link but not consumed externally by `EventHubConsumer`\n   * @private\n   */\n  private _internalQueue: ReceivedEventData[] = [];\n  /**\n   * @property _usingInternalQueue Indicates that events in the internal queue are being processed to be consumed by `EventHubConsumer`\n   * @private\n   */\n  private _usingInternalQueue: boolean = false;\n  /**\n   * @property _isReceivingMessages Indicates if messages are being received from this receiver.\n   * @private\n   */\n  private _isReceivingMessages: boolean = false;\n  /**\n   * @property _isStreaming Indicated if messages are being received in streaming mode.\n   * @private\n   */\n  private _isStreaming: boolean = false;\n\n  /**\n   * @property Returns sequenceNumber of the last event received from the service. This will not match the\n   * last event received by `EventHubConsumer` when the `_internalQueue` is not empty\n   * @readonly\n   */\n  get checkpoint(): number {\n    return this._checkpoint;\n  }\n\n  /**\n   * @property Indicates if messages are being received from this receiver.\n   * @readonly\n   */\n  get isReceivingMessages(): boolean {\n    return this._isReceivingMessages;\n  }\n\n  /**\n   * Instantiates a receiver that can be used to receive events over an AMQP receiver link in\n   * either batching or streaming mode.\n   * @ignore\n   * @constructor\n   * @param context        The connection context corresponding to the EventHubClient instance\n   * @param consumerGroup  The consumer group from which the receiver should receive events from.\n   * @param partitionId    The Partition ID from which to receive.\n   * @param eventPosition  The position in the stream from where to start receiving events.\n   * @param [options]      Receiver options.\n   */\n  constructor(\n    context: ConnectionContext,\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options: EventHubConsumerOptions = {}\n  ) {\n    super(context, {\n      partitionId: partitionId,\n      name: context.config.getReceiverAddress(partitionId, consumerGroup)\n    });\n    this.consumerGroup = consumerGroup;\n    this.address = context.config.getReceiverAddress(partitionId, this.consumerGroup);\n    this.audience = context.config.getReceiverAudience(partitionId, this.consumerGroup);\n    this.ownerLevel = options.ownerLevel;\n    this.eventPosition = eventPosition;\n    this.options = options;\n    this.runtimeInfo = {};\n  }\n\n  private _onAmqpMessage(context: EventContext): void {\n    if (!context.message) {\n      return;\n    }\n\n    const data: EventDataInternal = fromAmqpMessage(context.message);\n    const receivedEventData: ReceivedEventData = {\n      body: this._context.dataTransformer.decode(context.message.body),\n      properties: data.properties,\n      offset: data.offset!,\n      sequenceNumber: data.sequenceNumber!,\n      enqueuedTimeUtc: data.enqueuedTimeUtc!,\n      partitionKey: data.partitionKey!,\n      systemProperties: data.systemProperties\n    };\n\n    this._checkpoint = receivedEventData.sequenceNumber;\n\n    if (this.options.trackLastEnqueuedEventInfo && data) {\n      this.runtimeInfo.sequenceNumber = data.lastSequenceNumber;\n      this.runtimeInfo.enqueuedTime = data.lastEnqueuedTime;\n      this.runtimeInfo.offset = data.lastEnqueuedOffset;\n      this.runtimeInfo.retrievalTime = data.retrievalTime;\n      log.receiver(\n        \"[%s] RuntimeInfo of Receiver '%s' is %O\",\n        this._context.connectionId,\n        this.name,\n        this.runtimeInfo\n      );\n    }\n\n    // Add to internal queue if\n    // - There are no listeners, we are probably getting events due to pending credits\n    // - Or Events from internal queue are being processed, so add to it to ensure order of processing is retained\n    if (!this._onMessage || this._usingInternalQueue) {\n      this._internalQueue.push(receivedEventData);\n    } else {\n      if (this._isStreaming) {\n        this._addCredit(1);\n      }\n      this._onMessage(receivedEventData);\n    }\n  }\n\n  private _onAmqpError(context: EventContext): void {\n    const rheaReceiver = this._receiver || context.receiver;\n    if (!rheaReceiver) {\n      return;\n    }\n\n    const amqpError = rheaReceiver.error;\n    if (!amqpError) {\n      return;\n    }\n\n    if (rheaReceiver.isItselfClosed()) {\n      log.error(\n        \"[%s] The receiver was closed by the user.\" +\n        \"Hence not notifying the user's error handler.\",\n        this._context.connectionId\n      );\n      return;\n    }\n\n    if (this._onError) {\n      const error = translate(amqpError);\n      log.error(\n        \"[%s] An error occurred for Receiver '%s': %O.\",\n        this._context.connectionId,\n        this.name,\n        error\n      );\n      log.error(\n        \"[%s] Since the user did not close the receiver \" +\n        \"we let the user know about it by calling the user's error handler.\",\n        this._context.connectionId\n      );\n      this._onError(error);\n    }\n  }\n\n  private _onAmqpSessionError(context: EventContext): void {\n    const rheaReceiver = this._receiver || context.receiver;\n    if (!rheaReceiver) {\n      return;\n    }\n\n    const sessionError = context.session && context.session.error;\n    if (!sessionError) {\n      return;\n    }\n\n    if (rheaReceiver.isSessionItselfClosed()) {\n      log.error(\n        \"[%s] The receiver was closed by the user.\" +\n        \"Hence not notifying the user's error handler.\",\n        this._context.connectionId\n      );\n      return;\n    }\n\n    if (this._onError) {\n      const error = translate(sessionError);\n      log.error(\n        \"[%s] An error occurred on the session for Receiver '%s': %O.\",\n        this._context.connectionId,\n        this.name,\n        error\n      );\n\n      log.error(\n        \"[%s] Since the user did not close the receiver, \" +\n        \"we let the user know about it by calling the user's error handler.\",\n        this._context.connectionId\n      );\n      this._onError(error);\n    }\n  }\n\n  private async _onAmqpClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    if (!rheaReceiver || rheaReceiver.isItselfClosed()) {\n      log.error(\n        \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' \" +\n        \"because the sdk initiated it. Hence not calling detached from the _onAmqpClose\" +\n        \"() handler.\",\n        this._context.connectionId,\n        this.name,\n        this.address\n      );\n      return;\n    }\n\n    const amqpError = rheaReceiver.error;\n    if (amqpError) {\n      log.error(\n        \"[%s] 'receiver_close' event occurred for receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        amqpError\n      );\n    }\n\n    if (!this.isConnecting) {\n      log.error(\n        \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' \" +\n        \"and the sdk did not initiate this. The receiver is not reconnecting. Hence, calling \" +\n        \"detached from the _onAmqpClose() handler.\",\n        this._context.connectionId,\n        this.name,\n        this.address\n      );\n      await this.onDetached(amqpError);\n    } else {\n      log.error(\n        \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' \" +\n        \"and the sdk did not initate this. Moreover the receiver is already re-connecting. \" +\n        \"Hence not calling detached from the _onAmqpClose() handler.\",\n        this._context.connectionId,\n        this.name,\n        this.address\n      );\n    }\n  }\n\n  private async _onAmqpSessionClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    if (!rheaReceiver || rheaReceiver.isSessionItselfClosed()) {\n      log.error(\n        \"[%s] 'session_close' event occurred on the session of receiver '%s' with \" +\n        \"address '%s' and the sdk did not initiate this. Moreover the receiver is already \" +\n        \"re-connecting. Hence not calling detached from the _onAmqpSessionClose() handler.\",\n        this._context.connectionId,\n        this.name,\n        this.address\n      );\n      return;\n    }\n\n    const sessionError = context.session && context.session.error;\n    if (sessionError) {\n      log.error(\n        \"[%s] 'session_close' event occurred for receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        sessionError\n      );\n    }\n\n    if (!this.isConnecting) {\n      log.error(\n        \"[%s] 'session_close' event occurred on the session of receiver '%s' with \" +\n        \"address '%s' and the sdk did not initiate this. Hence calling detached from the \" +\n        \"_onAmqpSessionClose() handler.\",\n        this._context.connectionId,\n        this.name,\n        this.address\n      );\n      await this.onDetached(sessionError);\n    } else {\n      log.error(\n        \"[%s] 'session_close' event occurred on the session of receiver '%s' with \" +\n        \"address '%s' and the sdk did not initiate this. Moreover the receiver is already \" +\n        \"re-connecting. Hence not calling detached from the _onAmqpSessionClose() handler.\",\n        this._context.connectionId,\n        this.name,\n        this.address\n      );\n    }\n  }\n\n  async abort(): Promise<void> {\n    const desc: string =\n      `[${this._context.connectionId}] The receive operation on the Receiver \"${this.name}\" with ` +\n      `address \"${this.address}\" has been cancelled by the user.`;\n    log.error(desc);\n    if (this._onError) {\n      const error = new AbortError(\"The receive operation has been cancelled by the user.\");\n      this._onError(error);\n    }\n    this.clearHandlers();\n    await this.close();\n  }\n\n  /**\n   * Will reconnect the receiver link if necessary.\n   * @ignore\n   * @param [receiverError] The receiver error if any.\n   * @returns Promise<void>.\n   */\n  async onDetached(receiverError?: AmqpError | Error): Promise<void> {\n    try {\n      const rheaReceiver = this._receiver;\n      const wasCloseInitiated = rheaReceiver && rheaReceiver.isItselfClosed();\n      // Clears the token renewal timer. Closes the link and its session if they are open.\n      // Removes the link and its session if they are present in rhea's cache.\n      await this._closeLink(rheaReceiver);\n      // We should attempt to reopen only when the receiver(sdk) did not initiate the close\n      let shouldReopen = false;\n      if (receiverError && !wasCloseInitiated) {\n        // if there was an error and it is retryable, recreate the link\n        const translatedError = translate(receiverError);\n        if (translatedError.retryable) {\n          shouldReopen = true;\n          log.error(\n            \"[%s] close() method of Receiver '%s' with address '%s' was not called. There \" +\n            \"was an accompanying error and it is retryable. This is a candidate for re-establishing \" +\n            \"the receiver link.\",\n            this._context.connectionId,\n            this.name,\n            this.address\n          );\n        } else {\n          log.error(\n            \"[%s] close() method of Receiver '%s' with address '%s' was not called. There \" +\n            \"was an accompanying error and it is NOT retryable. Hence NOT re-establishing \" +\n            \"the receiver link.\",\n            this._context.connectionId,\n            this.name,\n            this.address\n          );\n        }\n      } else if (!wasCloseInitiated) {\n        // there wasn't an error, and the client didn't initialize the close; recreate the link\n        shouldReopen = true;\n        log.error(\n          \"[%s] close() method of Receiver '%s' with address '%s' was not called. \" +\n          \"There was no accompanying error as well. This is a candidate for re-establishing \" +\n          \"the receiver link.\",\n          this._context.connectionId,\n          this.name,\n          this.address\n        );\n      } else {\n        const state: any = {\n          wasCloseInitiated: wasCloseInitiated,\n          receiverError: receiverError,\n          _receiver: this._receiver\n        };\n        log.error(\n          \"[%s] Something went wrong. State of Receiver '%s' with address '%s' is: %O\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          state\n        );\n      }\n\n      if (!shouldReopen) {\n        return;\n      }\n\n      const receiverOptions: CreateReceiverOptions = {\n        onMessage: (context: EventContext) => this._onAmqpMessage(context),\n        onError: (context: EventContext) => this._onAmqpError(context),\n        onClose: (context: EventContext) => this._onAmqpClose(context),\n        onSessionClose: (context: EventContext) => this._onAmqpSessionClose(context),\n        onSessionError: (context: EventContext) => this._onAmqpSessionError(context),\n        newName: true // prevents service from sending an error stating that the link is still open\n      };\n\n      if (this.checkpoint > -1) {\n        receiverOptions.eventPosition = EventPosition.fromSequenceNumber(this.checkpoint);\n      }\n\n      // create RHEA receiver options\n      const initOptions = this._createReceiverOptions(receiverOptions);\n\n      // attempt to create the link\n      const linkCreationConfig: RetryConfig<void> = {\n        connectionId: this._context.connectionId,\n        connectionHost: this._context.config.host,\n        operation: () => this.initialize(initOptions),\n        operationType: RetryOperationType.receiverLink,\n        retryOptions: {\n          maxRetries: Constants.defaultMaxRetriesForConnection,\n          retryDelayInMs: 15000\n        }\n      };\n\n      await retry(linkCreationConfig);\n\n      // if the receiver is in streaming mode we need to add credits again.\n      if (this._isStreaming) {\n        this._addCredit(Constants.defaultPrefetchCount);\n      }\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while processing onDetached() of Receiver '%s' with address \" +\n        \"'%s': %O\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        err\n      );\n    }\n  }\n\n  /**\n   * Clears the user-provided handlers and updates the receiving messages flag.\n   * @ignore\n   */\n  clearHandlers(): void {\n    if (this._abortSignal && this._onAbort) {\n      this._abortSignal.removeEventListener(\"abort\", this._onAbort);\n    }\n\n    this._abortSignal = undefined;\n    this._onAbort = undefined;\n    this._onError = undefined;\n    this._onMessage = undefined;\n    this._isReceivingMessages = false;\n    this._isStreaming = false;\n  }\n\n  /**\n   * Closes the underlying AMQP receiver.\n   * @ignore\n   * @returns\n   */\n  async close(): Promise<void> {\n    this.clearHandlers();\n\n    if (!this._receiver) {\n      return;\n    }\n\n    const receiverLink = this._receiver;\n    this._deleteFromCache();\n    await this._closeLink(receiverLink);\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   * @ignore\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result = Boolean(this._receiver && this._receiver.isOpen());\n    log.error(\n      \"[%s] Receiver '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Registers the user's onMessage and onError handlers.\n   * Sends buffered events from the queue before adding additional credits to the AMQP link.\n   * @ignore\n   */\n  registerHandlers(\n    onMessage: OnMessage,\n    onError: OnError,\n    maximumCreditCount: number,\n    isStreaming: boolean,\n    abortSignal?: AbortSignalLike,\n    onAbort?: OnAbort\n  ): void {\n    this._abortSignal = abortSignal;\n    this._onAbort = onAbort;\n    this._onError = onError;\n    this._onMessage = onMessage;\n    this._isStreaming = isStreaming;\n    // indicate that messages are being received.\n    this._isReceivingMessages = true;\n\n    this._useInternalQueue(onMessage, abortSignal)\n      .then(async (processedEventCount) => {\n        if (this._onMessage !== onMessage) {\n          // the original handler has been removed, so no further action required.\n          return;\n        }\n\n        // check if more messages are required\n        if (!isStreaming && maximumCreditCount - processedEventCount <= 0) {\n          return;\n        }\n\n        if (!this.isOpen()) {\n          try {\n            await this.initialize();\n            if (abortSignal && abortSignal.aborted) {\n              await this.abort();\n            }\n          } catch (err) {\n            return this._onError === onError && onError(err);\n          }\n        } else {\n          log.receiver(\n            \"[%s] Receiver link already present, hence reusing it.\",\n            this._context.connectionId\n          );\n        }\n        // add credits\n        const existingCredits = this._receiver ? this._receiver.credit : 0;\n        const prcoessedEventCountToExclude = isStreaming ? 0 : processedEventCount;\n        const creditsToAdd = Math.max(\n          maximumCreditCount - (existingCredits + prcoessedEventCountToExclude),\n          0\n        );\n        this._addCredit(creditsToAdd);\n      })\n      .catch((err) => {\n        // something really unexpected happened, so attempt to call user's error handler\n        if (this._onError === onError) {\n          onError(err);\n        }\n      });\n  }\n\n  private _addCredit(credit: number): void {\n    if (this._receiver) {\n      this._receiver.addCredit(credit);\n    }\n  }\n\n  private _deleteFromCache(): void {\n    this._receiver = undefined;\n    delete this._context.receivers[this.name];\n    log.error(\n      \"[%s] Deleted the receiver '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name\n    );\n  }\n\n  private async _useInternalQueue(\n    onMessage: OnMessage,\n    abortSignal?: AbortSignalLike\n  ): Promise<number> {\n    let processedMessagesCount = 0;\n    // allow the event loop to process any blocking code outside\n    // this code path before sending any events.\n    await delay(0);\n    this._usingInternalQueue = true;\n    while (this._internalQueue.length) {\n      if (!this._onMessage) {\n        break;\n      }\n\n      if (abortSignal && abortSignal.aborted) {\n        break;\n      }\n\n      // These will not be equal if clearHandlers and registerHandlers were called\n      // in the same tick of the event loop. If onMessage isn't the currently active\n      // handler, it should stop getting messages from the queue.\n      if (this._onMessage !== onMessage) {\n        break;\n      }\n      const eventData = this._internalQueue.splice(0, 1)[0];\n      processedMessagesCount++;\n      onMessage(eventData);\n      // allow the event loop to process any blocking code outside\n      // this code path before sending the next event.\n      await delay(0);\n    }\n    this._usingInternalQueue = false;\n    return processedMessagesCount;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   * @ignore\n   * @returns\n   */\n  async initialize(options?: RheaReceiverOptions): Promise<void> {\n    try {\n      if (!this.isOpen() && !this.isConnecting) {\n        log.error(\n          \"[%s] The receiver '%s' with address '%s' is not open and is not currently \" +\n          \"establishing itself. Hence let's try to connect.\",\n          this._context.connectionId,\n          this.name,\n          this.address\n        );\n        // attempt creating a connection\n        this.isConnecting = true;\n        await this._negotiateClaim();\n        if (!options) {\n          const receiverOptions: CreateReceiverOptions = {\n            onClose: (context: EventContext) => this._onAmqpClose(context),\n            onError: (context: EventContext) => this._onAmqpError(context),\n            onMessage: (context: EventContext) => this._onAmqpMessage(context),\n            onSessionClose: (context: EventContext) => this._onAmqpSessionClose(context),\n            onSessionError: (context: EventContext) => this._onAmqpSessionError(context)\n          };\n          if (this.checkpoint > -1) {\n            receiverOptions.eventPosition = EventPosition.fromSequenceNumber(this.checkpoint);\n          }\n          options = this._createReceiverOptions(receiverOptions);\n        }\n\n        log.error(\n          \"[%s] Trying to create receiver '%s' with options %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        this._receiver = await this._context.connection.createReceiver(options);\n        this.isConnecting = false;\n        log.error(\n          \"[%s] Receiver '%s' with address '%s' has established itself.\",\n          this._context.connectionId,\n          this.name,\n          this.address\n        );\n        log.receiver(\n          \"Promise to create the receiver resolved. Created receiver with name: \",\n          this.name\n        );\n        log.receiver(\n          \"[%s] Receiver '%s' created with receiver options: %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        // store the underlying link in a cache\n        this._context.receivers[this.name] = this;\n\n        await this._ensureTokenRenewal();\n      } else {\n        log.error(\n          \"[%s] The receiver '%s' with address '%s' is open -> %s and is connecting \" +\n          \"-> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err) {\n      this.isConnecting = false;\n      const error = translate(err);\n      log.error(\n        \"[%s] An error occured while creating the receiver '%s': %O\",\n        this._context.connectionId,\n        this.name,\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   * @ignore\n   */\n  private _createReceiverOptions(options: CreateReceiverOptions): RheaReceiverOptions {\n    if (options.newName) this.name = uuid();\n    const rcvrOptions: RheaReceiverOptions = {\n      name: this.name,\n      autoaccept: true,\n      source: {\n        address: this.address\n      },\n      credit_window: 0,\n      onMessage: options.onMessage || ((context: EventContext) => this._onAmqpMessage(context)),\n      onError: options.onError || ((context: EventContext) => this._onAmqpError(context)),\n      onClose: options.onClose || ((context: EventContext) => this._onAmqpClose(context)),\n      onSessionError:\n        options.onSessionError || ((context: EventContext) => this._onAmqpSessionError(context)),\n      onSessionClose:\n        options.onSessionClose || ((context: EventContext) => this._onAmqpSessionClose(context))\n    };\n\n    if (typeof this.ownerLevel === \"number\") {\n      rcvrOptions.properties = {\n        [Constants.attachEpoch]: types.wrap_long(this.ownerLevel)\n      };\n    }\n\n    if (this.options.trackLastEnqueuedEventInfo) {\n      rcvrOptions.desired_capabilities = Constants.enableReceiverRuntimeMetricName;\n    }\n\n    const eventPosition = options.eventPosition || this.eventPosition;\n    if (eventPosition) {\n      // Set filter on the receiver if event position is specified.\n      const filterClause = getEventPositionFilter(eventPosition);\n      if (filterClause) {\n        (rcvrOptions.source as any).filter = {\n          \"apache.org:selector-filter:string\": types.wrap_described(filterClause, 0x468c00000004)\n        };\n      }\n    }\n    return rcvrOptions;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { EventHubConsumerOptions } from \"./eventHubClient\";\nimport { OnMessage, OnError, EventHubReceiver, LastEnqueuedEventInfo } from \"./eventHubReceiver\";\nimport { ReceivedEventData } from \"./eventData\";\nimport {\n  RetryConfig,\n  Constants,\n  RetryOperationType,\n  retry,\n  MessagingError,\n  RetryOptions\n} from \"@azure/core-amqp\";\nimport { ReceiveHandler } from \"./receiveHandler\";\nimport { AbortSignalLike, AbortError } from \"@azure/abort-controller\";\nimport { throwErrorIfConnectionClosed } from \"./util/error\";\nimport { EventPosition } from \"./eventPosition\";\nimport \"@azure/core-asynciterator-polyfill\";\n\n/**\n * Options to pass when creating an async iteratable using the `getEventIterator()` method on the\n * `EventHubConsumer`.\n */\nexport interface EventIteratorOptions {\n  /**\n   * Number of events to fetch at a time in the background\n   */\n  // prefetchCount?: number;\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the `EventIterator` to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * A consumer is responsible for reading `EventData` from a specific Event Hub partition\n * in the context of a specific consumer group.\n * To create a consumer use the `createConsumer()` method on your `EventHubClient`.\n *\n * You can pass the below in the `options` when creating a consumer.\n * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other\n * consumers to fail if their `ownerLevel` is lower or doesn't exist.\n * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.\n *\n * Multiple consumers are allowed on the same partition in a consumer group.\n * If there is a need to have an exclusive consumer for a partition in a consumer group,\n * then specify the `ownerLevel` in the `options`.\n * Exclusive consumers were previously referred to as \"Epoch Receivers\".\n *\n * The consumer can be used to receive messages in a batch using `receiveBatch()` or by registering handlers\n * by using `receive()` or via an async iterable got by using `getEventIterator()`\n * @class\n */\nexport class EventHubConsumer {\n  private _baseConsumer?: EventHubReceiver;\n  /**\n   * @property Describes the amqp connection context for the QueueClient.\n   */\n  private _context: ConnectionContext;\n  /**\n   * @property The consumer group from which the receiver should receive events from.\n   */\n  private _consumerGroup: string;\n  /**\n   * @property Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n  /**\n   * @property The identifier of the Event Hub partition that this consumer is associated with.\n   * Events will be read only from this partition.\n   */\n  private _partitionId: string;\n  /**\n   * @property The set of options to configure the behavior of an EventHubConsumer.\n   */\n  private _receiverOptions: EventHubConsumerOptions;\n  /**\n   * @property The set of retry options to configure the receiveBatch operation.\n   */\n  private _retryOptions: RetryOptions;\n  /**\n   * @property A set of information about the last enqueued event of a partition.\n   */\n  private _lastEnqueuedEventInfo: LastEnqueuedEventInfo;\n\n  /**\n   * @property The last enqueued event information. This property will only\n   * be enabled when `trackLastEnqueuedEventInfo` option is set to true in the\n   * `client.createConsumer()` method.\n   * @readonly\n   */\n  public get lastEnqueuedEventInfo(): LastEnqueuedEventInfo {\n    return this._lastEnqueuedEventInfo;\n  }\n\n  /**\n   * @property Returns `true` if the consumer is closed. This can happen either because the consumer\n   * itself has been closed or the client that created it has been closed.\n   * @readonly\n   */\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  /**\n   * @property The identifier of the Event Hub partition that this consumer is associated with.\n   * Events will be read only from this partition.\n   * @readonly\n   */\n  public get partitionId(): string {\n    return this._partitionId;\n  }\n\n  /**\n   * @property The name of the consumer group that this consumer is associated with.\n   * Events will be read only in the context of this group.\n   * @readonly\n   */\n  get consumerGroup(): string {\n    return this._consumerGroup;\n  }\n\n  /**\n   * @property The owner level associated with an exclusive consumer; for a non-exclusive consumer, this value will be null or undefined.\n   *\n   * When provided, the owner level indicates that a consumer is intended to be the exclusive receiver of events for the\n   * requested partition and the associated consumer group.\n   * When multiple consumers exist for the same partition/consumer group pair, then the ones with lower or no\n   * `ownerLevel` will get a `ReceiverDisconnectedError` during the next attempted receive operation.\n   * @readonly\n   */\n  get ownerLevel(): number | undefined {\n    return this._receiverOptions.ownerLevel;\n  }\n\n  /**\n   * Indicates whether the consumer is currently receiving messages or not.\n   * When this returns true, new `receive()` or `receiveBatch()` calls cannot be made.\n   */\n  get isReceivingMessages(): boolean {\n    return Boolean(this._baseConsumer && this._baseConsumer.isReceivingMessages);\n  }\n\n  /**\n   * EventHubConsumer should not be constructed using `new EventHubConsumer()`\n   * Use the `createConsumer()` method on your `EventHubClient` instead.\n   * @private\n   * @constructor\n   * @internal\n   * @ignore\n   */\n  constructor(\n    context: ConnectionContext,\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options?: EventHubConsumerOptions\n  ) {\n    this._context = context;\n    this._consumerGroup = consumerGroup;\n    this._partitionId = partitionId;\n    this._lastEnqueuedEventInfo = {};\n    this._receiverOptions = options || {};\n    this._retryOptions = this._receiverOptions.retryOptions || {};\n    this._baseConsumer = new EventHubReceiver(\n      context,\n      consumerGroup,\n      partitionId,\n      eventPosition,\n      options\n    );\n  }\n  /**\n   * Starts receiving events from the service and calls the user provided message handler for each event.\n   * Returns an object that can be used to query the state of the receiver and to stop receiving events as well.\n   *\n   * @param onMessage The message handler to receive event data objects.\n   * @param onError The error handler for errora that can occur when receiving events.\n   * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   * @returns ReceiveHandler - An object that provides a mechanism to stop receiving more messages.\n   * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.\n   * @throws {TypeError} Thrown if a required parameter is missing.\n   * @throws {Error} Thrown if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws {Error} Thrown if the receiver is already receiving messages.\n   */\n  receive(onMessage: OnMessage, onError: OnError, abortSignal?: AbortSignalLike): ReceiveHandler {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    const baseConsumer = this._baseConsumer!;\n\n    if (typeof onMessage !== \"function\") {\n      throw new TypeError(\"The parameter 'onMessage' must be of type 'function'.\");\n    }\n    if (typeof onError !== \"function\") {\n      throw new TypeError(\"The parameter 'onError' must be of type 'function'.\");\n    }\n\n    // return immediately if the abortSignal is already aborted.\n    if (abortSignal && abortSignal.aborted) {\n      onError(new AbortError(\"The receive operation has been cancelled by the user.\"));\n      // close this receiver when user triggers a cancellation.\n      this.close().catch(() => {}); // no-op close error handler\n      return new ReceiveHandler(baseConsumer);\n    }\n\n    const wrappedOnError = (error: Error) => {\n      // ignore retryable errors\n      if ((error as MessagingError).retryable) {\n        return;\n      }\n\n      log.error(\n        \"[%s] Since the error is not retryable, we let the user know about it by calling the user's error handler.\",\n        this._context.connectionId\n      );\n\n      if (error.name === \"AbortError\") {\n        // close this receiver when user triggers a cancellation.\n        this.close().catch(() => {}); // no-op close error handler\n      }\n      onError(error);\n    };\n\n    const onAbort = () => {\n      if (this._baseConsumer) {\n        this._baseConsumer.abort();\n      }\n    };\n\n    baseConsumer.registerHandlers(\n      onMessage,\n      wrappedOnError,\n      Constants.defaultPrefetchCount,\n      true,\n      abortSignal,\n      onAbort\n    );\n\n    if (\n      this._receiverOptions.trackLastEnqueuedEventInfo &&\n      this._baseConsumer &&\n      this._baseConsumer.runtimeInfo\n    ) {\n      this._lastEnqueuedEventInfo = this._baseConsumer.runtimeInfo;\n    }\n\n    return new ReceiveHandler(baseConsumer);\n  }\n\n  /**\n   * Returns an async iterable that retrieves events.\n   *\n   * The async iterable cannot indicate that it is done.\n   * When using `for await (let event of consumer.getEventIterator()) {}` to iterate over the events returned\n   * by the async iterable, take care to exit the for loop after receiving the\n   * desired number of messages, or provide an `AbortSignal` to control when to exit the loop.\n   *\n   * @param [options] A set of options to apply to an event iterator.\n   */\n  async *getEventIterator(\n    options: EventIteratorOptions = {}\n  ): AsyncIterableIterator<ReceivedEventData> {\n    const maxMessageCount = 1;\n    const maxWaitTimeInSeconds = Constants.defaultOperationTimeoutInMs / 1000;\n\n    while (true) {\n      const currentBatch = await this.receiveBatch(\n        maxMessageCount,\n        maxWaitTimeInSeconds,\n        options.abortSignal\n      );\n      if (!currentBatch || !currentBatch.length) {\n        continue;\n      }\n      yield currentBatch[0];\n    }\n  }\n\n  /**\n   * Returns a promise that resolves to an array of events received from the service.\n   *\n   * @param maxMessageCount The maximum number of messages to receive.\n   * @param maxWaitTimeInSeconds The maximum amount of time to wait to build up the requested message count;\n   * If not provided, it defaults to 60 seconds.\n   * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @returns Promise<ReceivedEventData[]>.\n   * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.\n   * @throws {MessagingError} Thrown if an error is encountered while receiving a message.\n   * @throws {Error} Thrown if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws {Error} Thrown if the receiver is already receiving messages.\n   */\n  async receiveBatch(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds: number = 60,\n    abortSignal?: AbortSignalLike\n  ): Promise<ReceivedEventData[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n\n    // store events across multiple retries\n    const receivedEvents: ReceivedEventData[] = [];\n\n    const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n      return new Promise(async (resolve, reject) => {\n        // if this consumer was closed, _baseConsumer might be undefined.\n        // resolve the operation's promise with the events collected thus far in case\n        // the promise hasn't already been resolved.\n        if (!this._baseConsumer) {\n          return resolve(receivedEvents);\n        }\n\n        let timer: any;\n        const logOnAbort = (): void => {\n          const baseConsumer = this._baseConsumer;\n          const name = baseConsumer && baseConsumer.name;\n          const address = baseConsumer && baseConsumer.address;\n          const desc: string =\n            `[${this._context.connectionId}] The request operation on the Receiver \"${name}\" with ` +\n            `address \"${address}\" has been cancelled by the user.`;\n          log.error(desc);\n        };\n\n        const rejectOnAbort = async (): Promise<void> => {\n          logOnAbort();\n          try {\n            await this.close();\n          } finally {\n            return reject(new AbortError(\"The receive operation has been cancelled by the user.\"));\n          }\n        };\n\n        // operation has been cancelled, so exit immediately\n        if (abortSignal && abortSignal.aborted) {\n          return await rejectOnAbort();\n        }\n\n        // updates the prefetch count so that the baseConsumer adds\n        // the correct number of credits to receive the same number of events.\n        const prefetchCount = Math.max(maxMessageCount - receivedEvents.length, 0);\n        if (prefetchCount === 0) {\n          return resolve(receivedEvents);\n        }\n\n        log.batching(\n          \"[%s] Receiver '%s', setting the prefetch count to %d.\",\n          this._context.connectionId,\n          this._baseConsumer && this._baseConsumer.name,\n          prefetchCount\n        );\n\n        const cleanUpBeforeReturn = (): void => {\n          if (this._baseConsumer) {\n            this._baseConsumer.clearHandlers();\n          }\n          clearTimeout(timer);\n        };\n\n        const onAbort = (): void => {\n          clearTimeout(timer);\n          rejectOnAbort();\n        };\n\n        this._baseConsumer.registerHandlers(\n          (eventData) => {\n            receivedEvents.push(eventData);\n            if (\n              this._receiverOptions.trackLastEnqueuedEventInfo &&\n              this._baseConsumer &&\n              this._baseConsumer.runtimeInfo\n            ) {\n              this._lastEnqueuedEventInfo = this._baseConsumer.runtimeInfo;\n            }\n            // resolve the operation's promise after the requested\n            // number of events are received.\n            if (receivedEvents.length === maxMessageCount) {\n              log.batching(\n                \"[%s] Batching Receiver '%s', %d messages received within %d seconds.\",\n                this._context.connectionId,\n                this._baseConsumer && this._baseConsumer.name,\n                receivedEvents.length,\n                maxWaitTimeInSeconds\n              );\n              cleanUpBeforeReturn();\n              resolve(receivedEvents);\n            }\n          },\n          (err) => {\n            cleanUpBeforeReturn();\n            if (err.name === \"AbortError\") {\n              rejectOnAbort();\n            } else {\n              reject(err);\n            }\n          },\n          maxMessageCount - receivedEvents.length,\n          false,\n          abortSignal,\n          onAbort\n        );\n\n        const addTimeout = (): void => {\n          const msg = \"[%s] Setting the wait timer for %d seconds for receiver '%s'.\";\n          log.batching(\n            msg,\n            this._context.connectionId,\n            maxWaitTimeInSeconds,\n            this._baseConsumer && this._baseConsumer.name\n          );\n\n          // resolve the operation's promise after the requested\n          // max number of seconds have passed.\n          timer = setTimeout(() => {\n            log.batching(\n              \"[%s] Batching Receiver '%s', %d messages received when max wait time in seconds %d is over.\",\n              this._context.connectionId,\n              this._baseConsumer && this._baseConsumer.name,\n              receivedEvents.length,\n              maxWaitTimeInSeconds\n            );\n            cleanUpBeforeReturn();\n            resolve(receivedEvents);\n          }, maxWaitTimeInSeconds * 1000);\n        };\n\n        addTimeout();\n        if (abortSignal && !abortSignal.aborted) {\n          abortSignal.addEventListener(\"abort\", onAbort);\n        }\n      });\n    };\n\n    const retryOptions = this._retryOptions;\n    const config: RetryConfig<ReceivedEventData[]> = {\n      connectionHost: this._context.config.host,\n      connectionId: this._context.connectionId,\n      operation: retrieveEvents,\n      operationType: RetryOperationType.receiveMessage,\n      abortSignal: abortSignal,\n      retryOptions: retryOptions\n    };\n    return retry<ReceivedEventData[]>(config);\n  }\n\n  /**\n   * Closes the underlying AMQP receiver link.\n   * Once closed, the consumer cannot be used for any further operations.\n   * Use the `createConsumer` function on the EventHubClient to instantiate\n   * a new EventHubConsumer.\n   *\n   * @returns\n   * @throws {Error} Thrown if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._context.connection && this._context.connection.isOpen()) {\n        if (this._baseConsumer) {\n          await this._baseConsumer.close();\n          this._baseConsumer = void 0;\n        }\n      }\n    } catch (err) {\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this.isReceivingMessages) {\n      const errorMessage = `The EventHubConsumer for \"${this._context.config.entityPath}\" is already receiving messages.`;\n      const error = new Error(errorMessage);\n      log.error(`[${this._context.connectionId}] %O`, error);\n      throw error;\n    }\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (!this._baseConsumer || this.isClosed) {\n      const errorMessage =\n        `The EventHubConsumer for \"${this._context.config.entityPath}\" has been closed and can no longer be used. ` +\n        `Please create a new EventHubConsumer using the \"createConsumer\" function on the EventHubClient.`;\n      const error = new Error(errorMessage);\n      log.error(`[${this._context.connectionId}] %O`, error);\n      throw error;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport { WebSocketImpl } from \"rhea-promise\";\nimport {\n  DataTransformer,\n  TokenCredential,\n  EventHubConnectionConfig,\n  SharedKeyCredential,\n  ConnectionConfig,\n  isTokenCredential,\n  RetryOptions,\n  Constants,\n  parseConnectionString,\n  EventHubConnectionStringModel\n} from \"@azure/core-amqp\";\n\nimport { ConnectionContext } from \"./connectionContext\";\nimport { PartitionProperties, EventHubProperties } from \"./managementClient\";\nimport { EventPosition } from \"./eventPosition\";\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { EventHubProducer } from \"./sender\";\nimport { EventHubConsumer } from \"./receiver\";\nimport { throwTypeErrorIfParameterMissing, throwErrorIfConnectionClosed } from \"./util/error\";\nimport { SpanContext, Span, getTracer, SpanKind, CanonicalCode } from \"@azure/core-tracing\";\n\ntype OperationNames = \"getProperties\" | \"getPartitionIds\" | \"getPartitionProperties\";\n\n/**\n * @internal\n * @ignore\n */\nexport function getRetryAttemptTimeoutInMs(retryOptions: RetryOptions | undefined): number {\n  const timeoutInMs =\n    retryOptions == undefined ||\n    typeof retryOptions.timeoutInMs !== \"number\" ||\n    !isFinite(retryOptions.timeoutInMs) ||\n    retryOptions.timeoutInMs < Constants.defaultOperationTimeoutInMs\n      ? Constants.defaultOperationTimeoutInMs\n      : retryOptions.timeoutInMs;\n  return timeoutInMs;\n}\n\n/**\n * The set of options to configure request cancellation.\n * - `abortSignal` : A signal used to cancel an asynchronous operation.\n */\nexport interface AbortSignalOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * The set of options to manually propagate `Span` context for distributed tracing.\n * - `parentSpan` : The `Span` or `SpanContext` for the operation to use as a `parent` when creating its own span.\n */\nexport interface ParentSpanOptions {\n  /**\n   * The `Span` or `SpanContext` to use as the `parent` of any spans created while calling operations that make a request to the service.\n   */\n  parentSpan?: Span | SpanContext;\n}\n\n/**\n * The set of options to configure the behavior of `getProperties`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPropertiesOptions extends AbortSignalOptions, ParentSpanOptions {}\n\n/**\n * The set of options to configure the behavior of `getPartitionProperties`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPartitionPropertiesOptions extends AbortSignalOptions, ParentSpanOptions {}\n\n/**\n * The set of options to configure the behavior of `getPartitionIds`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPartitionIdsOptions extends AbortSignalOptions, ParentSpanOptions {}\n\n/**\n * The set of options to configure the behavior of an `EventHubProducer`.\n * These can be specified when creating the producer via the `createProducer` method.\n * - `partitionId`  : The string identifier of the partition that the producer can be bound to.\n * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n */\nexport interface EventHubProducerOptions {\n  /**\n   * @property\n   * The identifier of the partition that the producer will be bound to.\n   * If a value is provided, all events sent using the producer will reach the same partition.\n   * If no value is provided, the service will determine the partition to which the event will be sent.\n   */\n  partitionId?: string;\n  /**\n   * @property\n   * The retry options used to govern retry attempts when an issue is encountered while sending events.\n   * If no value is provided here, the retry options set when creating the `EventHubClient` is used.\n   */\n  retryOptions?: RetryOptions;\n}\n\n/**\n * The set of options to configure the `send` operation on the `EventHubProducer`.\n * - `partitionKey` : A value that is hashed to produce a partition assignment.\n * - `abortSignal`  : A signal used to cancel the send operation.\n *\n * Example usage:\n * ```js\n * {\n *     partitionKey: 'foo'\n * }\n * ```\n */\nexport interface SendOptions {\n  /**\n   * @property\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  partitionKey?: string | null;\n  /**\n   * @property\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * The `Span` or `SpanContext` to use as the `parent` of any spans created while sending events.\n   */\n  parentSpan?: Span | SpanContext;\n}\n\n/**\n * The set of options to configure the `createBatch` operation on the `EventProducer`.\n * - `partitionKey`  : A value that is hashed to produce a partition assignment.\n * Not applicable if the `EventHubProducer` was created using a `partitionId`.\n * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n * - `abortSignal`   : A signal the request to cancel the send operation.\n *\n * Example usage:\n * ```js\n * {\n *     partitionKey: 'foo',\n *     maxSizeInBytes: 1024 * 1024 // 1 MB\n * }\n * ```\n */\nexport interface BatchOptions {\n  /**\n   * @property\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  partitionKey?: string;\n  /**\n   * @property\n   * The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   */\n  maxSizeInBytes?: number;\n  /**\n   * @property\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * The set of options to configure the behavior of an `EventHubConsumer`.\n * These can be specified when creating the consumer using the `createConsumer` method.\n * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other\n * consumers to fail if their `ownerLevel` is lower or doesn't exist.\n * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * Example usage:\n * ```js\n * {\n *     retryOptions: {\n *         maxRetries: 4\n *     },\n *     trackLastEnqueuedEventInfo: false\n * }\n * ```\n */\nexport interface EventHubConsumerOptions {\n  /**\n   * @property\n   * The owner level associated with an exclusive consumer.\n   *\n   * When provided, the owner level indicates that a consumer is intended to be the exclusive receiver of events for the\n   * requested partition and the associated consumer group.\n   * When multiple consumers exist for the same partition/consumer group pair, then the ones with lower or no\n   * `ownerLevel` will get a `ReceiverDisconnectedError` during the next attempted receive operation.\n   */\n  ownerLevel?: number;\n  /**\n   * @property\n   * The retry options used to govern retry attempts when an issue is encountered while receiving events.\n   * If no value is provided here, the retry options set when creating the `EventHubClient` is used.\n   */\n  retryOptions?: RetryOptions;\n  /**\n   * @property\n   * Indicates whether or not the consumer should request information on the last enqueued event on its\n   * associated partition, and track that information as events are received.\n\n   * When information about the partition's last enqueued event is being tracked, each event received \n   * from the Event Hubs service will carry metadata about the partition that it otherwise would not. This results in a small amount of\n   * additional network bandwidth consumption that is generally a favorable trade-off when considered\n   * against periodically making requests for partition properties using the Event Hub client.\n   */\n  trackLastEnqueuedEventInfo?: boolean;\n}\n\n/**\n * Describes the options that can be provided while creating the EventHubClient.\n * - `dataTransformer`: A set of `encode`/`decode` methods to be used to encode an event before sending to service\n * and to decode the event received from the service\n * - `userAgent`      : A string to append to the built in user agent string that is passed as a connection property\n * to the service.\n * - `websocket`      : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n * - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`   : The retry options for all the operations on the client/producer/consumer.\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * Example usage:\n * ```js\n * {\n *     retryOptions: {\n *         maxRetries: 4\n *     }\n * }\n * ```\n * @interface ClientOptions\n */\nexport interface EventHubClientOptions {\n  /**\n   * @property\n   * The data transformer that will be used to encode and decode the sent and received messages respectively.\n   * If not provided then the `DefaultDataTransformer` is used which has the below `encode` & `decode` features\n   * - `encode`:\n   *    - If event body is a Buffer, then the event is sent without any data transformation\n   *    - Else, JSON.stringfy() is run on the body, and then converted to Buffer before sending the event\n   *    - If JSON.stringify() fails at this point, the send operation fails too.\n   * - `decode`\n   *    - The body receivied via the AMQP protocol is always of type Buffer\n   *    - UTF-8 encoding is used to convert Buffer to string, and then JSON.parse() is run on it to get the event body\n   *    - If the JSON.parse() fails at this point, then the originally received Buffer object is returned in the event body.\n   */\n  dataTransformer?: DataTransformer;\n  /**\n   * @property\n   * The user agent that will be appended to the built in user agent string that is passed as a\n   * connection property to the Event Hubs service.\n   */\n  userAgent?: string;\n  /**\n   * @property\n   * The WebSocket constructor used to create an AMQP connection over a WebSocket.\n   * This option should be provided in the below scenarios:\n   * - The TCP port 5671 which is what is used by the AMQP connection to Event Hubs is blocked in your environment.\n   * - Your application needs to be run behind a proxy server\n   * - Your application needs to run in the browser and you want to provide your own choice of Websocket implementation\n   * instead of the built-in WebSocket in the browser.\n   */\n  webSocket?: WebSocketImpl;\n  /**\n   * @property\n   * Options to be passed to the WebSocket constructor when the underlying `rhea` library instantiates\n   * the WebSocket.\n   */\n  webSocketConstructorOptions?: any;\n  /**\n   * @property\n   * The retry options for all the operations on the client/producer/consumer.\n   * This can be overridden by the retry options set on the producer and consumer.\n   */\n  retryOptions?: RetryOptions;\n}\n\n/**\n * @class\n * The client is the main point of interaction with Azure Event Hubs service.\n * It offers connection to a specific Event Hub within the Event Hubs namespace along with\n * operations for sending event data, receiving events, and inspecting the connected Event Hub.\n *\n * There are multiple ways to create an `EventHubClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the fully qualified domain name of your Event Hub namespace like `<yournamespace>.servicebus.windows.net`,\n * and a credentials object.\n *\n */\nexport class EventHubClient {\n  /**\n   * Describes the amqp connection context for the eventhub client.\n   */\n  private _context: ConnectionContext;\n\n  /**\n   * The options passed by the user when creating the EventHubClient instance.\n   */\n  private _clientOptions: EventHubClientOptions;\n\n  /**\n   * The Service Bus endpoint.\n   */\n  private _endpoint: string;\n\n  /**\n   * @property\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._context.config.entityPath;\n  }\n\n  /**\n   * @property\n   * @readonly\n   * The fully qualified Event Hubs namespace for which this client is created. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._context.config.host;\n  }\n\n  /**\n   * @constructor\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `dataTransformer`: A set of `encode`/`decode` methods to be used to encode an event before sending to service\n   * and to decode the event received from the service\n   * - `userAgent`      : A string to append to the built in user agent string that is passed as a connection property\n   * to the service.\n   * - `websocket`      : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n   * over a WebSocket.\n   * - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n   * over a WebSocket.\n   * - `retryOptions`   : The retry options for all the operations on the client/producer/consumer.\n   * A simple usage can be `{ \"maxRetries\": 4 }`.\n   */\n  constructor(connectionString: string, options?: EventHubClientOptions);\n  /**\n   * @constructor\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace;\n   * it is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The path of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `dataTransformer`: A set of `encode`/`decode` methods to be used to encode an event before sending to service\n   * and to decode the event received from the service\n   * - `userAgent`      : A string to append to the built in user agent string that is passed as a connection property\n   * to the service.\n   * - `websocket`      : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n   * over a WebSocket.\n   * - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n   * over a WebSocket.\n   * - `retryOptions`   : The retry options for all the operations on the client/producer/consumer.\n   * A simple usage can be `{ \"maxRetries\": 4 }`.\n   */\n  constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions);\n  /**\n   * @constructor\n   * @param host - The fully qualified host name for the Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The path of the specific Event Hub to connect the client to.\n   * @param credential - SharedKeyCredential object or your credential that implements the TokenCredential interface.\n   * @param options - A set of options to apply when configuring the client.\n   * - `dataTransformer`: A set of `encode`/`decode` methods to be used to encode an event before sending to service\n   * and to decode the event received from the service\n   * - `userAgent`      : A string to append to the built in user agent string that is passed as a connection property\n   * to the service.\n   * - `websocket`      : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n   * over a WebSocket.\n   * - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n   * over a WebSocket.\n   * - `retryOptions`   : The retry options for all the operations on the client/producer/consumer.\n   * A simple usage can be `{ \"maxRetries\": 4 }`.\n   */\n  constructor(\n    host: string,\n    eventHubName: string,\n    credential: TokenCredential,\n    options?: EventHubClientOptions\n  );\n  constructor(\n    hostOrConnectionString: string,\n    eventHubNameOrOptions?: string | EventHubClientOptions,\n    credentialOrOptions?: TokenCredential | EventHubClientOptions,\n    options?: EventHubClientOptions\n  ) {\n    let connectionString;\n    let config;\n    let credential: TokenCredential | SharedKeyCredential;\n    hostOrConnectionString = String(hostOrConnectionString);\n\n    if (!isTokenCredential(credentialOrOptions)) {\n      const parsedCS = parseConnectionString<EventHubConnectionStringModel>(hostOrConnectionString);\n      if (\n        !(\n          parsedCS.EntityPath ||\n          (typeof eventHubNameOrOptions === \"string\" && eventHubNameOrOptions)\n        )\n      ) {\n        throw new TypeError(\n          `Either provide \"eventHubName\" or the \"connectionString\": \"${hostOrConnectionString}\", ` +\n            `must contain \"EntityPath=<your-event-hub-name>\".`\n        );\n      }\n      if (\n        parsedCS.EntityPath &&\n        typeof eventHubNameOrOptions === \"string\" &&\n        eventHubNameOrOptions &&\n        parsedCS.EntityPath !== eventHubNameOrOptions\n      ) {\n        throw new TypeError(\n          `The entity path \"${parsedCS.EntityPath}\" in connectionString: \"${hostOrConnectionString}\" ` +\n            `doesn't match with eventHubName: \"${eventHubNameOrOptions}\".`\n        );\n      }\n      connectionString = hostOrConnectionString;\n      if (typeof eventHubNameOrOptions !== \"string\") {\n        // connectionstring and/or options were passed to constructor\n        config = EventHubConnectionConfig.create(connectionString);\n        options = eventHubNameOrOptions;\n      } else {\n        // connectionstring, eventHubName and/or options were passed to constructor\n        const eventHubName = eventHubNameOrOptions;\n        config = EventHubConnectionConfig.create(connectionString, eventHubName);\n        options = credentialOrOptions;\n      }\n      // Since connectionstring was passed, create a SharedKeyCredential\n      credential = new SharedKeyCredential(config.sharedAccessKeyName, config.sharedAccessKey);\n    } else {\n      // host, eventHubName, a TokenCredential and/or options were passed to constructor\n      const eventHubName = eventHubNameOrOptions;\n      let host = hostOrConnectionString;\n      credential = credentialOrOptions;\n      if (!eventHubName) {\n        throw new TypeError(`\"eventHubName\" is missing`);\n      }\n\n      if (!host.endsWith(\"/\")) host += \"/\";\n      connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;EntityPath=${eventHubName}`;\n      config = EventHubConnectionConfig.create(connectionString);\n    }\n\n    ConnectionConfig.validate(config);\n\n    this._endpoint = config.endpoint;\n\n    this._clientOptions = options || {};\n    this._context = ConnectionContext.create(config, credential, this._clientOptions);\n  }\n\n  private _createClientSpan(operationName: OperationNames, parentSpan?: Span | SpanContext): Span {\n    const tracer = getTracer();\n    const span = tracer.startSpan(`Azure.EventHubs.${operationName}`, {\n      kind: SpanKind.CLIENT,\n      parent: parentSpan\n    });\n\n    span.setAttribute(\"component\", \"eventhubs\");\n    span.setAttribute(\"message_bus.destination\", this.eventHubName);\n    span.setAttribute(\"peer.address\", this._endpoint);\n\n    return span;\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws {Error} Thrown if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._context.connection.isOpen()) {\n        // Close all the senders.\n        for (const senderName of Object.keys(this._context.senders)) {\n          await this._context.senders[senderName].close();\n        }\n        // Close all the receivers.\n        for (const receiverName of Object.keys(this._context.receivers)) {\n          await this._context.receivers[receiverName].close();\n        }\n        // Close the cbs session;\n        await this._context.cbsSession.close();\n        // Close the management session\n        await this._context.managementSession!.close();\n        await this._context.connection.close();\n        this._context.wasConnectionCloseCalled = true;\n        log.client(\"Closed the amqp connection '%s' on the client.\", this._context.connectionId);\n      }\n    } catch (err) {\n      err = err instanceof Error ? err : JSON.stringify(err);\n      log.error(\n        `An error occurred while closing the connection \"${this._context.connectionId}\":\\n${err}`\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Creates an Event Hub producer that can send events to the Event Hub.\n   * If `partitionId` is specified in the `options`, all event data sent using the producer\n   * will be sent to the specified partition.\n   * Otherwise, they are automatically routed to an available partition by the Event Hubs service.\n   *\n   * Automatic routing of partitions is recommended because:\n   *  - The sending of events will be highly available.\n   *  - The event data will be evenly distributed among all available partitions.\n   *\n   * @param options The set of options to apply when creating the producer.\n   * - `partitionId`  : The identifier of the partition that the producer can be bound to.\n   * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.\n   * A simple usage can be `{ \"maxRetries\": 4 }`.\n   *\n   * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.\n   * @returns EventHubProducer\n   */\n  createProducer(options?: EventHubProducerOptions): EventHubProducer {\n    if (!options) {\n      options = {};\n    }\n    if (!options.retryOptions) {\n      options.retryOptions = this._clientOptions.retryOptions;\n    }\n    throwErrorIfConnectionClosed(this._context);\n    return new EventHubProducer(this.eventHubName, this._endpoint, this._context, options);\n  }\n\n  /**\n   * Creates an Event Hub consumer that can receive events from a specific Event Hub partition,\n   * in the context of a specific consumer group.\n   *\n   * Multiple consumers are allowed on the same partition in a consumer group.\n   * If there is a need to have an exclusive consumer for a partition in a consumer group,\n   * then specify the `ownerLevel` in the `options`.\n   * Exclusive consumers were previously referred to as \"Epoch Receivers\".\n   *\n   * @param consumerGroup The name of the consumer group this consumer is associated with.\n   * Events are read in the context of this group. You can get this information from Azure portal.\n   * @param partitionId The identifier of the Event Hub partition from which events will be received.\n   * You can get identifiers for all partitions by using the `getPartitionProperties` method on the `EventHubClient`.\n   * @param eventPosition The position within the partition where the consumer should begin reading events.\n   * The easiest way to create an instance of EventPosition is to use the static helpers on it like\n   * - `EventPosition.fromOffset()`\n   * - `EventPosition.fromSequenceNumber()`\n   * - `EventPosition.fromEnqueuedTime()`\n   * - `EventPosition.earliest()`\n   * - `EventPosition.latest()`\n   * @param options The set of options to apply when creating the consumer.\n   * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other\n   * consumers to fail if their `ownerLevel` is lower or doesn't exist.\n   * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.\n   * A simple usage can be `{ \"maxRetries\": 4 }`.\n   *\n   * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.\n   * @throws {TypeError} Thrown if a required parameter is missing.\n   */\n  createConsumer(\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options?: EventHubConsumerOptions\n  ): EventHubConsumer {\n    if (!options) {\n      options = {};\n    }\n    if (!options.retryOptions) {\n      options.retryOptions = this._clientOptions.retryOptions;\n    }\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"consumerGroup\", consumerGroup);\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"partitionId\", partitionId);\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"eventPosition\", eventPosition);\n    partitionId = String(partitionId);\n    return new EventHubConsumer(this._context, consumerGroup, partitionId, eventPosition, options);\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param [options] The set of options to apply to the operation call.\n   * @returns A promise that resolves with EventHubProperties.\n   * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.\n   * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.\n   */\n  async getProperties(options: GetPropertiesOptions = {}): Promise<EventHubProperties> {\n    throwErrorIfConnectionClosed(this._context);\n    const clientSpan = this._createClientSpan(\"getProperties\", options.parentSpan);\n    try {\n      const result = await this._context.managementSession!.getHubRuntimeInformation({\n        retryOptions: this._clientOptions.retryOptions,\n        abortSignal: options.abortSignal\n      });\n      clientSpan.setStatus({ code: CanonicalCode.OK });\n      return result;\n    } catch (err) {\n      clientSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n      log.error(\"An error occurred while getting the hub runtime information: %O\", err);\n      throw err;\n    } finally {\n      clientSpan.end();\n    }\n  }\n\n  /**\n   * Provides an array of partitionIds.\n   * @param [options] The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings.\n   * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.\n   * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.\n   */\n  async getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    throwErrorIfConnectionClosed(this._context);\n    const clientSpan = this._createClientSpan(\"getPartitionIds\", options.parentSpan);\n    try {\n      const runtimeInfo = await this.getProperties({\n        ...options,\n        parentSpan: clientSpan\n      });\n      clientSpan.setStatus({ code: CanonicalCode.OK });\n      return runtimeInfo.partitionIds;\n    } catch (err) {\n      clientSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n      log.error(\"An error occurred while getting the partition ids: %O\", err);\n      throw err;\n    } finally {\n      clientSpan.end();\n    }\n  }\n\n  /**\n   * Provides information about the specified partition.\n   * @param partitionId Partition ID for which partition information is required.\n   * @param [options] The set of options to apply to the operation call.\n   * @returns A promise that resoloves with PartitionProperties.\n   * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.\n   * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.\n   */\n  async getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"partitionId\", partitionId);\n    partitionId = String(partitionId);\n    const clientSpan = this._createClientSpan(\"getPartitionProperties\", options.parentSpan);\n    try {\n      const result = await this._context.managementSession!.getPartitionProperties(partitionId, {\n        retryOptions: this._clientOptions.retryOptions,\n        abortSignal: options.abortSignal\n      });\n      clientSpan.setStatus({ code: CanonicalCode.OK });\n      return result;\n    } catch (err) {\n      clientSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n      log.error(\"An error occurred while getting the partition information: %O\", err);\n      throw err;\n    } finally {\n      clientSpan.end();\n    }\n  }\n\n  /**\n   * @property\n   * The name of the default consumer group in the Event Hubs service.\n   */\n  static defaultConsumerGroupName: string = Constants.defaultConsumerGroup;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport { EventProcessorOptions, CloseReason } from \"./eventProcessor\";\nimport { EventHubClient } from \"./eventHubClient\";\nimport { EventPosition } from \"./eventPosition\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { EventHubConsumer } from \"./receiver\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { MessagingError } from \"@azure/core-amqp\";\n\nexport class PartitionPump {\n  private _eventHubClient: EventHubClient;\n  private _partitionProcessor: PartitionProcessor;\n  private _processorOptions: EventProcessorOptions;\n  private _receiver: EventHubConsumer | undefined;\n  private _initialEventPosition: EventPosition;\n  private _isReceiving: boolean = false;\n  private _abortController: AbortController;\n\n  constructor(\n    eventHubClient: EventHubClient,\n    partitionProcessor: PartitionProcessor,\n    initialEventPosition: EventPosition,\n    options?: EventProcessorOptions\n  ) {\n    if (!options) options = {};\n    this._eventHubClient = eventHubClient;\n    this._partitionProcessor = partitionProcessor;\n    this._initialEventPosition = initialEventPosition;\n    this._processorOptions = options;\n    this._abortController = new AbortController();\n  }\n\n  public get isReceiving(): boolean {\n    return this._isReceiving;\n  }\n\n  async start(): Promise<void> {\n    this._isReceiving = true;\n    try {\n      await this._partitionProcessor.initialize();\n    } catch {\n      // swallow the error from the user-defined code\n    }\n    this._receiveEvents(this._partitionProcessor.partitionId);\n    log.partitionPump(\"Successfully started the receiver.\");\n  }\n\n  private async _receiveEvents(partitionId: string): Promise<void> {\n    this._receiver = this._eventHubClient.createConsumer(\n      this._partitionProcessor.consumerGroupName,\n      partitionId,\n      this._initialEventPosition,\n      {\n        ownerLevel: 0,\n        trackLastEnqueuedEventInfo: this._processorOptions.trackLastEnqueuedEventInfo\n      }\n    );\n\n    while (this._isReceiving) {\n      try {\n        const receivedEvents = await this._receiver.receiveBatch(\n          this._processorOptions.maxBatchSize || 1,\n          this._processorOptions.maxWaitTimeInSeconds,\n          this._abortController.signal\n        );\n        if (\n          this._processorOptions.trackLastEnqueuedEventInfo &&\n          this._receiver.lastEnqueuedEventInfo\n        ) {\n          this._partitionProcessor.lastEnqueuedEventInfo = this._receiver.lastEnqueuedEventInfo;\n        }\n        // avoid calling user's processEvents handler if the pump was stopped while receiving events\n        if (!this._isReceiving) {\n          return;\n        }\n        await this._partitionProcessor.processEvents(receivedEvents);\n      } catch (err) {\n        // check if this pump is still receiving\n        // it may not be if the EventProcessor was stopped during processEvents\n        if (!this._isReceiving) {\n          // no longer receiving, so close was called from somewhere else\n          return;\n        }\n\n        // forward error to user's processError and swallow errors they may throw\n        try {\n          await this._partitionProcessor.processError(err);\n        } catch (err) {\n          log.error(\"An error was thrown by user's processError method: \", err);\n        }\n\n        // close the partition processor if a non-retryable error was encountered\n        if (typeof err !== \"object\" || !(err as MessagingError).retryable) {\n          try {\n            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel\n            // started consuming the partition), update the closeReason\n            if (err.name === \"ReceiverDisconnectedError\") {\n              return await this.stop(CloseReason.OwnershipLost);\n            }\n            // this will close the pump and will break us out of the while loop\n            return await this.stop(CloseReason.Shutdown);\n          } catch (err) {\n            log.error(\n              `An error occurred while closing the receiver with reason ${CloseReason.Shutdown}: `,\n              err\n            );\n          }\n        }\n      }\n    }\n  }\n\n  async stop(reason: CloseReason): Promise<void> {\n    this._isReceiving = false;\n    try {\n      if (this._receiver) {\n        await this._receiver.close();\n      }\n      this._abortController.abort();\n      await this._partitionProcessor.close(reason);\n    } catch (err) {\n      log.error(\"An error occurred while closing the receiver.\", err);\n      throw err;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventHubClient } from \"./eventHubClient\";\nimport { EventPosition } from \"./eventPosition\";\nimport { EventProcessorOptions, CloseReason } from \"./eventProcessor\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { PartitionPump } from \"./partitionPump\";\nimport * as log from \"./log\";\n\n/**\n * The PumpManager handles the creation and removal of PartitionPumps.\n * It also starts a PartitionPump when it is created, and stops a\n * PartitionPump when it is removed.\n * @ignore\n */\nexport class PumpManager {\n  private readonly _eventProcessorName: string;\n  private readonly _options: EventProcessorOptions;\n  private _partitionIdToPumps: {\n    [partitionId: string]: PartitionPump | undefined;\n  } = {};\n\n  /**\n   * @ignore\n   */\n  constructor(eventProcessorName: string, eventProcessorOptions: EventProcessorOptions = {}) {\n    this._eventProcessorName = eventProcessorName;\n    this._options = eventProcessorOptions;\n  }\n\n  /**\n   * Returns a list of partitionIds that are actively receiving messages.\n   * @ignore\n   */\n  public receivingFromPartitions(): string[] {\n    return Object.keys(this._partitionIdToPumps).filter((id) => {\n      const pump = this._partitionIdToPumps[id];\n      return Boolean(pump && pump.isReceiving);\n    });\n  }\n\n  /**\n   * Creates and starts a PartitionPump.\n   * @param eventHubClient The EventHubClient to forward to the PartitionPump.\n   * @param initialEventPosition The EventPosition to forward to the PartitionPump.\n   * @param partitionProcessor The PartitionProcessor to forward to the PartitionPump.\n   * @param abortSignal Used to cancel pump creation.\n   * @ignore\n   */\n  public async createPump(\n    eventHubClient: EventHubClient,\n    initialEventPosition: EventPosition,\n    partitionProcessor: PartitionProcessor\n  ): Promise<void> {\n    const partitionId = partitionProcessor.partitionId;\n    // attempt to get an existing pump\n    const existingPump = this._partitionIdToPumps[partitionId];\n    if (existingPump) {\n      if (existingPump.isReceiving) {\n        log.pumpManager(\n          `[${this._eventProcessorName}] [${partitionId}] The existing pump is running.`\n        );\n        return;\n      }\n      log.pumpManager(\n        `[${this._eventProcessorName}] [${partitionId}] The existing pump is not running.`\n      );\n      await this.removePump(partitionId, CloseReason.OwnershipLost);\n    }\n\n    log.pumpManager(`[${this._eventProcessorName}] [${partitionId}] Creating a new pump.`);\n\n    const pump = new PartitionPump(\n      eventHubClient,\n      partitionProcessor,\n      initialEventPosition,\n      this._options\n    );\n\n    try {\n      await pump.start();\n      this._partitionIdToPumps[partitionId] = pump;\n    } catch (err) {\n      log.error(\n        `[${this._eventProcessorName}] [${partitionId}] An error occured while adding/updating a pump: ${err}`\n      );\n    }\n  }\n\n  /**\n   * Stop a PartitionPump and removes it from the internal map.\n   * @param partitionId The partitionId to remove the associated PartitionPump from.\n   * @param reason The reason for removing the pump.\n   * @ignore\n   */\n  public async removePump(partitionId: string, reason: CloseReason): Promise<void> {\n    try {\n      const pump = this._partitionIdToPumps[partitionId];\n      if (pump) {\n        delete this._partitionIdToPumps[partitionId];\n        log.pumpManager(`[${this._eventProcessorName}] [${partitionId}] Stopping the pump.`);\n        await pump.stop(reason);\n      } else {\n        log.pumpManager(\n          `[${this._eventProcessorName}] [${partitionId}] No pump was found to remove.`\n        );\n      }\n    } catch (err) {\n      log.error(\n        `[${this._eventProcessorName}] [${partitionId}] An error occured while removing a pump: ${err}`\n      );\n    }\n  }\n\n  /**\n   * Stops all PartitionPumps and removes them from the internal map.\n   * @param reason The reason for removing the pump.\n   * @ignore\n   */\n  public async removeAllPumps(reason: CloseReason): Promise<void> {\n    const partitionIds = Object.keys(this._partitionIdToPumps);\n\n    log.pumpManager(`[${this._eventProcessorName}] Removing all pumps due to reason ${reason}.`);\n\n    const tasks: PromiseLike<void>[] = [];\n    for (const partitionId of partitionIds) {\n      const pump = this._partitionIdToPumps[partitionId];\n      if (pump) {\n        tasks.push(pump.stop(reason));\n      }\n    }\n\n    try {\n      await Promise.all(tasks);\n    } catch (err) {\n      log.error(`[${this._eventProcessorName}] An error occured while removing all pumps: ${err}`);\n    } finally {\n      this._partitionIdToPumps = {};\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { PartitionOwnership } from \"./eventProcessor\";\nimport * as log from \"./log\";\n\n/**\n * This class is responsible for balancing the load of processing events from all partitions of an Event Hub by\n * distributing the number of partitions uniformly among all the active EventProcessors.\n *\n * This load balancer will retrieve partition ownership details from the PartitionManager to find the number of\n * active EventProcessor. It uses the last modified time to decide if an EventProcessor is active. If a\n * partition ownership entry has not be updated for a specified duration of time, the owner of that partition is\n * considered inactive and the partition is available for other EventProcessors to own.\n * @class PartitionLoadBalancer\n */\nexport class PartitionLoadBalancer {\n  private _ownerId: string;\n  private _inactiveTimeLimitInMS: number;\n\n  /**\n   * Creates an instance of PartitionBasedLoadBalancer.\n   *\n   * @param ownerId The identifier of the Event Processor that owns this load balancer.\n   * @param inactiveTimeLimitInMS The time to wait for an update on an ownership record before\n   * assuming the owner of the partition is inactive.\n   * */\n  constructor(ownerId: string, inactiveTimeLimitInMS: number) {\n    this._ownerId = ownerId;\n    this._inactiveTimeLimitInMS = inactiveTimeLimitInMS;\n  }\n\n  /*\n   * Find the event processor that owns the maximum number of partitions and steal a random partition\n   * from it.\n   */\n  private _findPartitionToSteal(ownerPartitionMap: Map<string, PartitionOwnership[]>): string {\n    let maxList: PartitionOwnership[] = [];\n    let maxPartitionsOwnedByAnyEventProcessor = Number.MIN_VALUE;\n    let ownerId;\n    ownerPartitionMap.forEach((ownershipList: PartitionOwnership[], ownerId: string) => {\n      if (ownershipList.length > maxPartitionsOwnedByAnyEventProcessor) {\n        maxPartitionsOwnedByAnyEventProcessor = ownershipList.length;\n        maxList = ownershipList;\n        ownerId = ownerId;\n      }\n    });\n    log.partitionLoadBalancer(\n      `[${this._ownerId}] Owner id ${ownerId} owns ${maxList.length} partitions, stealing a partition from it.`\n    );\n    return maxList[Math.floor(Math.random() * maxList.length)].partitionId;\n  }\n\n  /*\n   * This method is called after determining that the load is not balanced. This method will evaluate\n   * if the current event processor should own more partitions. Specifically, this method returns true if the\n   * current event processor owns less than the minimum number of partitions or if it owns the minimum number\n   * and no other event processor owns lesser number of partitions than this event processor.\n   */\n  private _shouldOwnMorePartitions(\n    minPartitionsPerEventProcessor: number,\n    partitionIds: string[],\n    ownerPartitionMap: Map<string, PartitionOwnership[]>\n  ): boolean {\n    const numberOfPartitionsOwned = ownerPartitionMap.get(this._ownerId)!.length;\n\n    let sumOfPartitionsOwnedByAnyProcessor = 0;\n    for (const ownershipList of ownerPartitionMap.values()) {\n      sumOfPartitionsOwnedByAnyProcessor =\n        sumOfPartitionsOwnedByAnyProcessor + ownershipList.length;\n    }\n    return (\n      numberOfPartitionsOwned < minPartitionsPerEventProcessor ||\n      (sumOfPartitionsOwnedByAnyProcessor < partitionIds.length &&\n        numberOfPartitionsOwned < minPartitionsPerEventProcessor + 1)\n    );\n  }\n\n  /*\n   * When the load is balanced, all active event processors own at least minPartitionsPerEventProcessor\n   * and only numberOfEventProcessorsWithAdditionalPartition event processors will own 1 additional\n   * partition.\n   */\n  private _isLoadBalanced(\n    minPartitionsPerEventProcessor: number,\n    numberOfEventProcessorsWithAdditionalPartition: number,\n    ownerPartitionMap: Map<string, PartitionOwnership[]>\n  ): boolean {\n    let count = 0;\n    for (const ownershipList of ownerPartitionMap.values()) {\n      const numberOfPartitions = ownershipList.length;\n      if (\n        numberOfPartitions < minPartitionsPerEventProcessor ||\n        numberOfPartitions > minPartitionsPerEventProcessor + 1\n      ) {\n        return false;\n      }\n      if (numberOfPartitions === minPartitionsPerEventProcessor + 1) {\n        count++;\n      }\n    }\n    return count === numberOfEventProcessorsWithAdditionalPartition;\n  }\n\n  /*\n   * This method will create a new map of partition id and PartitionOwnership containing only those partitions\n   * that are actively owned. All entries in the original map returned by PartitionManager that haven't been\n   * modified for a duration of time greater than the allowed inactivity time limit are assumed to be owned by\n   * dead event processors. These will not be included in the map returned by this method.\n   */\n  private _removeInactivePartitionOwnerships(\n    partitionOwnershipMap: Map<string, PartitionOwnership>\n  ): Map<string, PartitionOwnership> {\n    const activePartitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n    partitionOwnershipMap.forEach((partitionOwnership: PartitionOwnership, partitionId: string) => {\n      var date = new Date();\n      if (\n        partitionOwnership.lastModifiedTimeInMS &&\n        date.getTime() - partitionOwnership.lastModifiedTimeInMS < this._inactiveTimeLimitInMS &&\n        partitionOwnership.ownerId\n      ) {\n        activePartitionOwnershipMap.set(partitionId, partitionOwnership);\n      }\n    });\n\n    return activePartitionOwnershipMap;\n  }\n\n  /*\n   * This method works with the given partition ownership details and Event Hub partitions to evaluate whether the\n   * current Event Processor should take on the responsibility of processing more partitions.\n   */\n  loadBalance(\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionsToAdd: string[]\n  ): string {\n    //  Remove all partitions ownership that have not been modified within the configured period of time. This means that the previous\n    //  event processor that owned the partition is probably down and the partition is now eligible to be\n    //  claimed by other event processors.\n    const activePartitionOwnershipMap = this._removeInactivePartitionOwnerships(\n      partitionOwnershipMap\n    );\n    log.partitionLoadBalancer(\n      `[${this._ownerId}] Number of active ownership records: ${activePartitionOwnershipMap.size}.`\n    );\n    if (activePartitionOwnershipMap.size === 0) {\n      // If the active partition ownership map is empty, this is the first time an event processor is\n      // running or all Event Processors are down for this Event Hub, consumer group combination. All\n      // partitions in this Event Hub are available to claim. Choose a random partition to claim ownership.\n      return partitionsToAdd[Math.floor(Math.random() * partitionsToAdd.length)];\n    }\n\n    // Create a map of owner id and a list of partitions it owns\n    const ownerPartitionMap: Map<string, PartitionOwnership[]> = new Map();\n    for (const activePartitionOwnership of activePartitionOwnershipMap.values()) {\n      const partitionOwnershipArray = ownerPartitionMap.get(activePartitionOwnership.ownerId) || [];\n      partitionOwnershipArray.push(activePartitionOwnership);\n      ownerPartitionMap.set(activePartitionOwnership.ownerId, partitionOwnershipArray);\n    }\n\n    // add the current event processor to the map if it doesn't exist\n    if (!ownerPartitionMap.has(this._ownerId)) {\n      ownerPartitionMap.set(this._ownerId, []);\n    }\n    log.partitionLoadBalancer(\n      `[${this._ownerId}] Number of active event processors: ${ownerPartitionMap.size}.`\n    );\n\n    // Find the minimum number of partitions every event processor should own when the load is\n    // evenly distributed.\n    const minPartitionsPerEventProcessor = Math.floor(\n      partitionsToAdd.length / ownerPartitionMap.size\n    );\n    // If the number of partitions in Event Hub is not evenly divisible by number of active event processors,\n    // a few Event Processors may own 1 additional partition than the minimum when the load is balanced. Calculate\n    // the number of event processors that can own additional partition.\n    const numberOfEventProcessorsWithAdditionalPartition =\n      partitionsToAdd.length % ownerPartitionMap.size;\n\n    log.partitionLoadBalancer(\n      `[${this._ownerId}] Expected minimum number of partitions per event processor: ${minPartitionsPerEventProcessor}, \n      expected number of event processors with additional partition: ${numberOfEventProcessorsWithAdditionalPartition}.`\n    );\n\n    if (\n      this._isLoadBalanced(\n        minPartitionsPerEventProcessor,\n        numberOfEventProcessorsWithAdditionalPartition,\n        ownerPartitionMap\n      )\n    ) {\n      log.partitionLoadBalancer(`[${this._ownerId}] Load is balanced.`);\n      // If the partitions are evenly distributed among all active event processors, no change required.\n      return \"\";\n    }\n\n    if (\n      !this._shouldOwnMorePartitions(\n        minPartitionsPerEventProcessor,\n        partitionsToAdd,\n        ownerPartitionMap\n      )\n    ) {\n      log.partitionLoadBalancer(\n        `[${this._ownerId}] This event processor owns ${\n          ownerPartitionMap.get(this._ownerId)!.length\n        } partitions and shouldn't own more.`\n      );\n      // This event processor already has enough partitions and shouldn't own more yet\n      return \"\";\n    }\n    log.partitionLoadBalancer(\n      `[${this._ownerId}] Load is unbalanced and this event processor should own more partitions.`\n    );\n    // If we have reached this stage, this event processor has to claim/steal ownership of at least 1 more partition\n\n    //  If some partitions are unclaimed, this could be because an event processor is down and\n    //  it's partitions are now available for others to own or because event processors are just\n    //  starting up and gradually claiming partitions to own or new partitions were added to Event Hub.\n    //  Find any partition that is not actively owned and claim it.\n\n    //   OR\n\n    //  Find a partition to steal from another event processor. Pick the event processor that owns the highest\n    //  number of partitions.\n    const unOwnedPartitionIds = [];\n    let partitionToClaim: string | undefined;\n    for (const partitionId of partitionsToAdd) {\n      if (!activePartitionOwnershipMap.has(partitionId)) {\n        unOwnedPartitionIds.push(partitionId);\n      }\n    }\n    if (unOwnedPartitionIds.length === 0) {\n      log.partitionLoadBalancer(\n        `[${this._ownerId}] No unclaimed partitions, stealing from another event processor.`\n      );\n      partitionToClaim = this._findPartitionToSteal(ownerPartitionMap);\n    } else {\n      partitionToClaim =\n        unOwnedPartitionIds[Math.floor(Math.random() * unOwnedPartitionIds.length)];\n    }\n\n    return partitionToClaim;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport { EventHubClient } from \"./eventHubClient\";\nimport { EventPosition } from \"./eventPosition\";\nimport { PumpManager } from \"./pumpManager\";\nimport { AbortController, AbortSignalLike } from \"@azure/abort-controller\";\nimport * as log from \"./log\";\nimport { PartitionLoadBalancer } from \"./partitionLoadBalancer\";\nimport { delay } from \"@azure/core-amqp\";\nimport { PartitionProcessor, Checkpoint } from \"./partitionProcessor\";\n\n/**\n * An enum representing the different reasons for an `EventProcessor` to stop processing\n * events from a partition in a consumer group of an Event Hub instance.\n */\nexport enum CloseReason {\n  /**\n   * Ownership of the partition was lost or transitioned to a new processor instance.\n   */\n  OwnershipLost = \"OwnershipLost\",\n  /**\n   * The EventProcessor was shutdown.\n   */\n  Shutdown = \"Shutdown\"\n}\n\n/**\n * An interface representing the details on which instance of a `EventProcessor` owns processing\n * of a given partition from a consumer group of an Event Hub instance.\n *\n * **Note**: This is used internally by the `EventProcessor` and user never has to create it directly.\n */\nexport interface PartitionOwnership {\n  /**\n   * @property The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * @property The event hub name\n   */\n  eventHubName: string;\n  /**\n   * @property The consumer group name\n   */\n  consumerGroupName: string;\n  /**\n   * @property The unique identifier of the event processor.\n   */\n  ownerId: string;\n  /**\n   * @property The identifier of the Event Hub partition\n   */\n  partitionId: string;\n  /**\n   * @property\n   * The owner level\n   */\n  ownerLevel: number;\n  /**\n   * @property The offset of the event.\n   */\n  offset?: number;\n  /**\n   * @property The sequence number of the event.\n   */\n  sequenceNumber?: number;\n  /**\n   * @property The last modified time.\n   */\n  lastModifiedTimeInMS?: number;\n  /**\n   * @property The unique identifier for the operation.\n   */\n  eTag?: string;\n}\n\n/**\n * A Partition manager stores and retrieves partition ownership information and checkpoint details\n * for each partition in a given consumer group of an event hub instance.\n *\n * Users are not meant to implement an `PartitionManager`.\n * Users are expected to choose existing implementations of this interface, instantiate it, and pass\n * it to the constructor of `EventProcessor`.\n *\n * To get started, you can use the `InMemoryPartitionManager` which will store the relevant information in memory.\n * But in production, you should choose an implementation of the `PartitionManager` interface that will\n * store the checkpoints and partition ownerships to a durable store instead.\n *\n * Implementations of `PartitionManager` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.\n */\nexport interface PartitionManager {\n  /**\n   * Called to get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName The event hub name.\n   * @param consumerGroupName The consumer group name.\n   * @return A list of partition ownership details of all the partitions that have/had an owner.\n   */\n  listOwnership(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroupName: string\n  ): Promise<PartitionOwnership[]>;\n  /**\n   * Called to claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership The list of partition ownership this instance is claiming to own.\n   * @return A list of partitions this instance successfully claimed ownership.\n   */\n  claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]>;\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint The checkpoint.\n   * @return The new eTag on successful update.\n   */\n  updateCheckpoint(checkpoint: Checkpoint): Promise<string>;\n}\n\n/**\n * A set of options to pass to the constructor of `EventProcessor`.\n * You can specify\n * - `maxBatchSize`: The max size of the batch of events passed each time to user code for processing.\n * - `maxWaitTimeInSeconds`: The maximum amount of time to wait to build up the requested message count before\n * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n *\n * Example usage with default values:\n * ```ts\n * {\n *     maxBatchSize: 1,\n *     maxWaitTimeInSeconds: 60\n * }\n * ```\n */\nexport interface EventProcessorOptions {\n  /**\n   * The max size of the batch of events passed each time to user code for processing.\n   */\n  maxBatchSize?: number;\n  /**\n   * The maximum amount of time to wait to build up the requested message count before\n   * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n   */\n  maxWaitTimeInSeconds?: number;\n  /**\n   * @property\n   * Indicates whether or not the consumer should request information on the last enqueued event on its\n   * associated partition, and track that information as events are received.\n\n   * When information about the partition's last enqueued event is being tracked, each event received \n   * from the Event Hubs service will carry metadata about the partition that it otherwise would not. This results in a small amount of\n   * additional network bandwidth consumption that is generally a favorable trade-off when considered\n   * against periodically making requests for partition properties using the Event Hub client.\n   */\n  trackLastEnqueuedEventInfo?: boolean;\n}\n\n/**\n * Event Processor based applications consist of one or more instances of EventProcessor which have been\n * configured to consume events from the same Event Hub and consumer group. They balance the\n * workload across different instances by distributing the partitions to be processed among themselves.\n * They also allow the user to track progress when events are processed using checkpoints.\n *\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * You need the below to create an instance of `EventProcessor`\n * - The name of the consumer group from which you want to process events\n * - An instance of `EventHubClient` class that was created for the Event Hub instance.\n * - A user implemented class that extends the `PartitionProcessor` class. To get started, you can use the\n * base class `PartitionProcessor` which simply logs the incoming events. To provide your code to process incoming\n * events, extend this class and override the `processEvents()` method. For example:\n * ```js\n * class SamplePartitionProcessor extends PartitionProcessor {\n *     async processEvents(events) {\n *        // user code to process events here\n *        // Information on the partition being processed is available as properties on the `SamplePartitionProcessor` class\n *        // use `this.updateCheckpoint()` method to update checkpoints as needed\n *     }\n * }\n * ```\n * - An instance of `PartitionManager`. To get started, you can pass an instance of `InMemoryPartitionManager`.\n * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.\n * Implementations of `PartitionManager` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.\n *\n * @class EventProcessor\n */\nexport class EventProcessor {\n  private _consumerGroupName: string;\n  private _eventHubClient: EventHubClient;\n  private _partitionProcessorClass: typeof PartitionProcessor;\n  private _processorOptions: EventProcessorOptions;\n  private _pumpManager: PumpManager;\n  private _id: string = uuid();\n  private _isRunning: boolean = false;\n  private _loopTask?: PromiseLike<void>;\n  private _abortController?: AbortController;\n  private _partitionManager: PartitionManager;\n  private _partitionLoadBalancer: PartitionLoadBalancer;\n\n  /**\n   * @param consumerGroupName The name of the consumer group from which you want to process events.\n   * @param eventHubClient An instance of `EventHubClient` that was created for the Event Hub instance.\n   * @param PartitionProcessorClass A user-provided class that extends the `PartitionProcessor` class.\n   * This class will be responsible for processing and checkpointing events.\n   * @param partitionManager An instance of `PartitionManager`. To get started, you can pass an instance of `InMemoryPartitionManager`.\n   * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.\n   * @param options A set of options to configure the Event Processor\n   * - `maxBatchSize`         : The max size of the batch of events passed each time to user code for processing.\n   * - `maxWaitTimeInSeconds` : The maximum amount of time to wait to build up the requested message count before\n   * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n   */\n  constructor(\n    consumerGroupName: string,\n    eventHubClient: EventHubClient,\n    PartitionProcessorClass: typeof PartitionProcessor,\n    partitionManager: PartitionManager,\n    options?: EventProcessorOptions\n  ) {\n    if (!options) options = {};\n\n    this._consumerGroupName = consumerGroupName;\n    this._eventHubClient = eventHubClient;\n    this._partitionProcessorClass = PartitionProcessorClass;\n    this._partitionManager = partitionManager;\n    this._processorOptions = options;\n    this._pumpManager = new PumpManager(this._id, this._processorOptions);\n    const inactiveTimeLimitInMS = 60000; // ownership expiration time (1 mintue)\n    this._partitionLoadBalancer = new PartitionLoadBalancer(this._id, inactiveTimeLimitInMS);\n  }\n\n  /**\n   * The unique identifier for the EventProcessor.\n   *\n   * @return {string}\n   */\n  get id(): string {\n    return this._id;\n  }\n\n  private _createPartitionOwnershipRequest(\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIdToClaim: string\n  ): PartitionOwnership {\n    const previousPartitionOwnership = partitionOwnershipMap.get(partitionIdToClaim);\n    const partitionOwnership: PartitionOwnership = {\n      ownerId: this._id,\n      partitionId: partitionIdToClaim,\n      fullyQualifiedNamespace: this._eventHubClient.fullyQualifiedNamespace,\n      consumerGroupName: this._consumerGroupName,\n      eventHubName: this._eventHubClient.eventHubName,\n      sequenceNumber: previousPartitionOwnership\n        ? previousPartitionOwnership.sequenceNumber\n        : undefined,\n      offset: previousPartitionOwnership ? previousPartitionOwnership.offset : undefined,\n      eTag: previousPartitionOwnership ? previousPartitionOwnership.eTag : undefined,\n      ownerLevel: 0\n    };\n\n    return partitionOwnership;\n  }\n\n  /*\n   * Claim ownership of the given partition if it's available\n   */\n  private async _claimOwnership(\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIdToClaim: string\n  ): Promise<void> {\n    log.partitionLoadBalancer(\n      `[${this._id}] Attempting to claim ownership of partition ${partitionIdToClaim}.`\n    );\n    const ownershipRequest = this._createPartitionOwnershipRequest(\n      partitionOwnershipMap,\n      partitionIdToClaim\n    );\n    try {\n      await this._partitionManager.claimOwnership([ownershipRequest]);\n      log.partitionLoadBalancer(\n        `[${this._id}] Successfully claimed ownership of partition ${partitionIdToClaim}.`\n      );\n\n      log.partitionLoadBalancer(\n        `[${this._id}] [${partitionIdToClaim}] Calling user-provided PartitionProcessorFactory.`\n      );\n      const partitionProcessor = new this._partitionProcessorClass();\n      partitionProcessor.fullyQualifiedNamespace = this._eventHubClient.fullyQualifiedNamespace;\n      partitionProcessor.eventHubName = this._eventHubClient.eventHubName;\n      partitionProcessor.consumerGroupName = this._consumerGroupName;\n      partitionProcessor.partitionId = ownershipRequest.partitionId;\n      partitionProcessor.partitionManager = this._partitionManager;\n      partitionProcessor.eventProcessorId = this.id;\n\n      const eventPosition = ownershipRequest.sequenceNumber\n        ? EventPosition.fromSequenceNumber(ownershipRequest.sequenceNumber)\n        : EventPosition.earliest();\n\n      await this._pumpManager.createPump(this._eventHubClient, eventPosition, partitionProcessor);\n      log.partitionLoadBalancer(`[${this._id}] PartitionPump created successfully.`);\n    } catch (err) {\n      log.error(\n        `[${this.id}] Failed to claim ownership of partition ${ownershipRequest.partitionId}`\n      );\n    }\n  }\n\n  /**\n   * Every loop to this method will result in this EventProcessor owning at most one new partition.\n   *\n   * The load is considered balanced when no active EventProcessor owns 2 partitions more than any other active\n   * EventProcessor. Given that each invocation to this method results in ownership claim of at most one partition,\n   * this algorithm converges gradually towards a steady state.\n   *\n   * When a new partition is claimed, this method is also responsible for starting a partition pump that creates an\n   * EventHubConsumer for processing events from that partition.\n   */\n\n  private async _runLoop(abortSignal: AbortSignalLike): Promise<void> {\n    // periodically check if there is any partition not being processed and process it\n    const waitIntervalInMs = 10000;\n    while (!abortSignal.aborted) {\n      try {\n        const partitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n        // Retrieve current partition ownership details from the datastore.\n        const partitionOwnership = await this._partitionManager.listOwnership(\n          this._eventHubClient.fullyQualifiedNamespace,\n          this._eventHubClient.eventHubName,\n          this._consumerGroupName\n        );\n        for (const ownership of partitionOwnership) {\n          partitionOwnershipMap.set(ownership.partitionId, ownership);\n        }\n        const partitionIds = await this._eventHubClient.getPartitionIds();\n        if (abortSignal.aborted) {\n          return;\n        }\n\n        if (partitionIds.length > 0) {\n          const partitionToClaim = this._partitionLoadBalancer.loadBalance(\n            partitionOwnershipMap,\n            partitionIds\n          );\n          if (partitionToClaim) {\n            await this._claimOwnership(partitionOwnershipMap, partitionToClaim);\n          }\n        }\n\n        // sleep\n        log.eventProcessor(\n          `[${this._id}] Pausing the EventProcessor loop for ${waitIntervalInMs} ms.`\n        );\n        await delay(waitIntervalInMs, abortSignal);\n      } catch (err) {\n        log.error(`[${this._id}] An error occured within the EventProcessor loop: ${err}`);\n      }\n    }\n  }\n\n  /**\n   * Starts the `EventProcessor`. Based on the number of instances of `EventProcessor` that are running for the\n   * same consumer group, the partitions are distributed among these instances to process events.\n   *\n   * For each partition, the user provided `PartitionProcessor` is instantiated.\n   *\n   * Subsequent calls to start will be ignored if this event processor is already running.\n   * Calling `start()` after `stop()` is called will restart this event processor.\n   *\n   * @return {void}\n   */\n  start(): void {\n    if (this._isRunning) {\n      log.eventProcessor(`[${this._id}] Attempted to start an already running EventProcessor.`);\n      return;\n    }\n\n    this._isRunning = true;\n    this._abortController = new AbortController();\n    log.eventProcessor(`[${this._id}] Starting an EventProcessor.`);\n    this._loopTask = this._runLoop(this._abortController.signal);\n  }\n\n  /**\n   * Stops processing events for all partitions owned by this event processor.\n   * All `PartitionProcessor` will be shutdown and any open resources will be closed.\n   *\n   * Subsequent calls to stop will be ignored if the event processor is not running.\n   *\n   */\n  async stop(): Promise<void> {\n    log.eventProcessor(`[${this._id}] Stopping an EventProcessor.`);\n    if (this._abortController) {\n      // cancel the event processor loop\n      this._abortController.abort();\n    }\n\n    this._isRunning = false;\n    try {\n      // remove all existing pumps\n      await this._pumpManager.removeAllPumps(CloseReason.Shutdown);\n\n      // waits for the event processor loop to complete\n      // will complete immediately if _loopTask is undefined\n      await this._loopTask;\n    } catch (err) {\n      log.error(`[${this._id}] An error occured while stopping the EventProcessor: ${err}`);\n    } finally {\n      log.eventProcessor(`[${this._id}] EventProcessor stopped.`);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { PartitionManager, PartitionOwnership } from \"./eventProcessor\";\nimport { Checkpoint } from \"./partitionProcessor\";\nimport { generate_uuid } from \"rhea-promise\";\n\n/**\n * The `EventProcessor` relies on a `PartitionManager` to store checkpoints and handle partition\n * ownerships. `InMemoryPartitionManager` is simple partition manager that stores checkpoints and\n * partition ownerships in memory of your program.\n *\n * You can use the `InMemoryPartitionManager` to get started with using the `EventProcessor`.\n * But in production, you should choose an implementation of the `PartitionManager` interface that will\n * store the checkpoints and partition ownerships to a durable store instead.\n *\n * @class\n */\nexport class InMemoryPartitionManager implements PartitionManager {\n  private _partitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n\n  /**\n   * Get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName The event hub name.\n   * @param consumerGroupName The consumer group name.\n   * @return Partition ownership details of all the partitions that have/had an owner..\n   */\n  async listOwnership(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroupName: string\n  ): Promise<PartitionOwnership[]> {\n    return Array.from(this._partitionOwnershipMap.values());\n  }\n\n  /**\n   * Claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership The list of partition ownership this instance is claiming to own.\n   * @return A list partitions this instance successfully claimed ownership.\n   */\n  async claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]> {\n    for (const ownership of partitionOwnership) {\n      if (\n        !this._partitionOwnershipMap.has(ownership.partitionId) ||\n        this._partitionOwnershipMap.get(ownership.partitionId)!.eTag === ownership.eTag\n      ) {\n        ownership.eTag = generate_uuid();\n        var date = new Date();\n        ownership.lastModifiedTimeInMS = date.getTime();\n        this._partitionOwnershipMap.set(ownership.partitionId, ownership);\n      }\n    }\n    return partitionOwnership;\n  }\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint The checkpoint.\n   * @return The new eTag on successful update\n   */\n  async updateCheckpoint(checkpoint: Checkpoint): Promise<string> {\n    const partitionOwnership = this._partitionOwnershipMap.get(checkpoint.partitionId);\n    if (partitionOwnership) {\n      partitionOwnership.sequenceNumber = checkpoint.sequenceNumber;\n      partitionOwnership.offset = checkpoint.offset;\n      partitionOwnership.eTag = generate_uuid();\n      return partitionOwnership.eTag;\n    }\n    return \"\";\n  }\n}\n","import { CloseReason, PartitionManager } from \"./eventProcessor\";\nimport { ReceivedEventData } from \"./eventData\";\nimport { LastEnqueuedEventInfo } from \"./eventHubReceiver\";\n\n/**\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * When the `updateCheckpoint()` method on the `PartitionProcessor` class is called by the user, a\n * `Checkpoint` is created internally. It is then stored in the storage solution implemented by the\n * `PartitionManager` chosen by the user when creating an `EventProcessor`.\n *\n * Users are never expected to interact with `Checkpoint` directly. This interface exists to support the\n * internal workings of `EventProcessor` and `PartitionManager`.\n **/\nexport interface Checkpoint {\n  /**\n   * @property The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * @property The event hub name\n   */\n  eventHubName: string;\n  /**\n   * @property The consumer group name\n   */\n  consumerGroupName: string;\n  /**\n   * @property The unique identifier of the event processor\n   */\n  ownerId: string;\n  /**\n   * @property The identifier of the Event Hub partition\n   */\n  partitionId: string;\n  /**\n   * @property The sequence number of the event\n   */\n  sequenceNumber: number;\n  /**\n   * @property The offset of the event.\n   */\n  offset: number;\n  /**\n   * @property The unique identifier for the operation\n   */\n  eTag: string;\n}\n\n/**\n * The `PartitionProcessor` is responsible for processing events received from Event Hubs when using `EventProcessor`\n *\n * The EventProcessor creates a new instance of the PartitionProcessor for each partition of the event hub it starts processing. When you extend the `PartitionProcessor` in order to customize it as you see fit,\n * - Override the `processEvents()` method to add the code to process the received events. This is also a good place to update the checkpoints using the `updateCheckpoint()` method\n * - Optionally override the `processError()` method to handle any error that might have occurred when processing the events.\n * - Optionally override the `initialize()` method to implement any set up related tasks you would want to carry out before starting to receive events from the partition\n * - Optionally override the `close()` method to implement any tear down or clean up tasks you would want to carry out.\n */\nexport class PartitionProcessor {\n  private _partitionManager: PartitionManager | undefined;\n  private _consumerGroupName: string | undefined;\n  private _fullyQualifiedNamespace: string | undefined;\n  private _eventHubName: string | undefined;\n  private _eventProcessorId: string | undefined;\n  private _partitionId: string | undefined;\n  private _eTag: string = \"\";\n  private _lastEnqueuedEventInfo: LastEnqueuedEventInfo | undefined;\n\n  /**\n   * @property Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventInfo` option is set to true\n   * when creating an instance of EventProcessor\n   * @readonly\n   */\n  public get lastEnqueuedEventInfo(): LastEnqueuedEventInfo {\n    return this._lastEnqueuedEventInfo!;\n  }\n\n  /**\n   * @property Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventInfo` option is set to true\n   * when creating an instance of EventProcessor\n   */\n  public set lastEnqueuedEventInfo(lastEnqueuedEventInfo: LastEnqueuedEventInfo) {\n    this._lastEnqueuedEventInfo = lastEnqueuedEventInfo;\n  }\n\n  /**\n   * @property The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get fullyQualifiedNamespace() {\n    return this._fullyQualifiedNamespace!;\n  }\n\n  /**\n   * @property The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`\n   */\n  public set fullyQualifiedNamespace(fullyQualifiedNamespace: string) {\n    if (!this._fullyQualifiedNamespace) {\n      this._fullyQualifiedNamespace = fullyQualifiedNamespace;\n    }\n  }\n\n  /**\n   * @property The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get consumerGroupName() {\n    return this._consumerGroupName!;\n  }\n\n  /**\n   * @property The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`\n   */\n  public set consumerGroupName(consumerGroupName: string) {\n    if (!this._consumerGroupName) {\n      this._consumerGroupName = consumerGroupName;\n    }\n  }\n\n  /**\n   * @property The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get eventHubName() {\n    return this._eventHubName!;\n  }\n\n  /**\n   * @property The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`\n   */\n  public set eventHubName(eventHubName: string) {\n    if (!this._eventHubName) {\n      this._eventHubName = eventHubName;\n    }\n  }\n\n  /**\n   * @property The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get partitionId() {\n    return this._partitionId!;\n  }\n\n  /**\n   * @property The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`\n   */\n  public set partitionId(partitionId: string) {\n    if (!this._partitionId) {\n      this._partitionId = partitionId;\n    }\n  }\n\n  /**\n   * @property The unique identifier of the `EventProcessor` that has spawned the current instance of `PartitionProcessor`. This is set by the `EventProcessor`\n   */\n  public set eventProcessorId(eventProcessorId: string) {\n    if (!this._eventProcessorId) {\n      this._eventProcessorId = eventProcessorId;\n    }\n  }\n\n  /**\n   * @property The Partition Manager used for checkpointing events. This is set by the `EventProcessor`\n   */\n  public set partitionManager(partitionManager: PartitionManager) {\n    if (!this._partitionManager) {\n      this._partitionManager = partitionManager;\n    }\n  }\n\n  /**\n   * This method is called when the `EventProcessor` takes ownership of a new partition and before any\n   * events are received.\n   *\n   * @return {Promise<void>}\n   */\n  async initialize(): Promise<void> {}\n\n  /**\n   * This method is called before the partition processor is closed by the EventProcessor.\n   *\n   * @param reason The reason for closing this partition processor.\n   * @return {Promise<void>}\n   */\n  async close(reason: CloseReason): Promise<void> {}\n\n  /**\n   * This method is called when new events are received.\n   *\n   * This is also a good place to update checkpoints as appropriate.\n   *\n   * @param events The received events to be processed.\n   * @return {Promise<void>}\n   */\n  async processEvents(events: ReceivedEventData[]): Promise<void> {}\n\n  /**\n   * This method is called when an error occurs while receiving events from Event Hubs.\n   *\n   * @param error The error to be processed.\n   * @return {Promise<void>}\n   */\n  async processError(error: Error): Promise<void> {}\n\n  /**\n   * Updates the checkpoint using the event data.\n   *\n   * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n   * partition of a consumer group in an Event Hub instance.\n   *\n   * @param eventData The event that you want to update the checkpoint with.\n   * @return Promise<void>\n   */\n  public async updateCheckpoint(eventData: ReceivedEventData): Promise<void>;\n  /**\n   * Updates the checkpoint using the given offset and sequence number.\n   *\n   * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n   * partition of a consumer group in an Event Hub instance.\n   *\n   * @param sequenceNumber The sequence number of the event that you want to update the checkpoint with.\n   * @param offset The offset of the event that you want to update the checkpoint with.\n   * @return  Promise<void>.\n   */\n  public async updateCheckpoint(sequenceNumber: number, offset: number): Promise<void>;\n  public async updateCheckpoint(\n    eventDataOrSequenceNumber: ReceivedEventData | number,\n    offset?: number\n  ): Promise<void> {\n    const checkpoint: Checkpoint = {\n      fullyQualifiedNamespace: this._fullyQualifiedNamespace!,\n      eventHubName: this._eventHubName!,\n      consumerGroupName: this._consumerGroupName!,\n      ownerId: this._eventProcessorId!,\n      partitionId: this._partitionId!,\n      sequenceNumber:\n        typeof eventDataOrSequenceNumber === \"number\"\n          ? eventDataOrSequenceNumber\n          : eventDataOrSequenceNumber.sequenceNumber,\n      offset:\n        typeof offset === \"number\"\n          ? offset\n          : (eventDataOrSequenceNumber as ReceivedEventData).offset,\n      eTag: this._eTag\n    };\n\n    this._eTag = await this._partitionManager!.updateCheckpoint(checkpoint);\n  }\n}\n"],"names":["log.error","bytesToUuid","uuid","log.link","defaultLock","SharedKeyCredential","TokenType","Constants","link","log.mgmt","translate","RequestResponseLink","SenderEvents","ReceiverEvents","error","AbortError","generate_uuid","RetryOperationType","retry","os.type","os.release","ConnectionContextBase","context","log.context","delay","ConnectionEvents","getTraceParentHeader","extractSpanContextFromTraceParentHeader","getTracer","SpanKind","message","log.sender","ErrorNameConditionMapper","CanonicalCode","log.receiver","types","log.batching","isTokenCredential","parseConnectionString","EventHubConnectionConfig","ConnectionConfig","log.client","AbortController","log.partitionPump","CloseReason","log.pumpManager","log.partitionLoadBalancer","log.eventProcessor"],"mappings":"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"}